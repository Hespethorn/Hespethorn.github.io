<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World 系统化学习之旅</title>
    <url>/posts/f9d777ad/</url>
    <content><![CDATA[<h2 id="🌟Welcome-to-My-Technical-Diary"><a href="#🌟Welcome-to-My-Technical-Diary" class="headerlink" title="🌟Welcome to My Technical Diary"></a>🌟Welcome to My Technical Diary</h2><blockquote>
<p>This is my first vlog! I’ll use this blog to document my journey from learning C to mastering Go (Golang). Over time, I hope to share insights, code snippets, and lessons learned along the way.</p>
</blockquote>
<blockquote>
<p>Let&#39;s engineer our way from &quot;Hello World&quot; to production-grade systems!</p>
</blockquote>
<h2 id="🧭-Navigation-System-Overview"><a href="#🧭-Navigation-System-Overview" class="headerlink" title="🧭 Navigation System Overview"></a>🧭 Navigation System Overview</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Home (Landing Page)</span><br><span class="line">- Daily progress reports | Technical retrospectives </span><br><span class="line"></span><br><span class="line">Tech Stack Panel (Sidebar)</span><br><span class="line">- **Tag Cloud**: `#Go` `#C`  </span><br><span class="line">  *(Click tags to filter content)*</span><br><span class="line">- **Chronology**: Full article timeline with timestamps  </span><br><span class="line"></span><br><span class="line">Resource Repository (Links)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="📌-Development-Discipline"><a href="#📌-Development-Discipline" class="headerlink" title="📌 Development Discipline"></a>📌 Development Discipline</h2><h3 id="核心理念"><a href="#核心理念" class="headerlink" title="核心理念"></a>核心理念</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ Core Doctrines:</span><br><span class="line">   1. Daily effective code (Minimum 3 production-ready lines)</span><br><span class="line">   2. Error log as primary learning artifact</span><br><span class="line">   3. Weekly code refactoring cycle</span><br><span class="line"></span><br><span class="line">! Anti-pattern Prohibitions:</span><br><span class="line">   ❌ Code pasting without comprehension  </span><br><span class="line">   ❌ Error message suppression  </span><br><span class="line">   ❌ Premature toolchain upgrades</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🚀-Immediate-Action-Plan"><a href="#🚀-Immediate-Action-Plan" class="headerlink" title="🚀 Immediate Action Plan"></a>🚀 Immediate Action Plan</h2><h3 id="Daily-Commitment-Checklist-✅"><a href="#Daily-Commitment-Checklist-✅" class="headerlink" title="Daily Commitment Checklist ✅"></a>Daily Commitment Checklist ✅</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### Daily Commitments</span><br><span class="line">1. Submit valid code (even if only comments)</span><br><span class="line">2. Document debugging sessions (full error logs)</span><br><span class="line">3. Update progress metrics</span><br><span class="line"></span><br><span class="line">### Join the Journey</span><br><span class="line">&gt; &quot;Technology is not an island, but a guiding light&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>&quot;Technology is not an island, but a guiding light.&quot;</p>
</blockquote>
]]></content>
      <categories>
        <category>个人文章</category>
      </categories>
      <tags>
        <tag>LearningJournal</tag>
        <tag>ProgrammingEducation</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言日期工具完整实现</title>
    <url>/posts/39679951/</url>
    <content><![CDATA[<hr>
<hr>
<h2 id="引言：为什么需要自己写日期工具？"><a href="#引言：为什么需要自己写日期工具？" class="headerlink" title="引言：为什么需要自己写日期工具？"></a>引言：为什么需要自己写日期工具？</h2><p>在开发日程管理、财务统计或数据分析类应用时，日期处理是绕不开的需求。虽然C标准库提供了&#96;&#96;，但实际场景中往往需要更灵活的功能——比如精确计算两个日期的天数差、自定义格式打印月历，或验证用户输入的日期合法性。今天我们就用C语言手写一个<strong>全功能日期工具</strong>，覆盖从基础判断到复杂交互的全流程，并拆解核心算法原理。</p>
<hr>
<h2 id="核心功能清单"><a href="#核心功能清单" class="headerlink" title="核心功能清单"></a>核心功能清单</h2><p>这个日期工具实现了5大核心功能，覆盖日常开发中最常用的日期操作场景：</p>
<ul>
<li>✅ <strong>计算日期差</strong>：精确计算任意两个日期之间的天数间隔；</li>
<li>✅ <strong>查询星期几</strong>：输入年月日，快速得到对应的星期名称；</li>
<li>✅ <strong>打印月历</strong>：以表格形式展示当月日期与星期的对应关系；</li>
<li>✅ <strong>打印年历</strong>：按月份分开展示全年日历；</li>
<li>✅ <strong>输入验证</strong>：自动检查日期合法性（如闰年二月是否有29天）。</li>
</ul>
<hr>
<h2 id="关键数据与算法：日期计算的底层逻辑"><a href="#关键数据与算法：日期计算的底层逻辑" class="headerlink" title="关键数据与算法：日期计算的底层逻辑"></a>关键数据与算法：日期计算的底层逻辑</h2><h3 id="基础数据：月份天数与星期映射"><a href="#基础数据：月份天数与星期映射" class="headerlink" title="基础数据：月份天数与星期映射"></a>基础数据：月份天数与星期映射</h3><p>代码中定义了两个全局常量数组，它们是整个工具的「数据基石」：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int mon[12] = &#123; 31,28,31,30,31,30,31,31,30,31,30,31 &#125;;  </span><br><span class="line">// 平年各月天数（索引0=1月）</span><br><span class="line">const char *week_day[7] = &#123; &quot;周日&quot;, &quot;周一&quot;, &quot;周二&quot;, &quot;周三&quot;, &quot;周四&quot;, &quot;周五&quot;, &quot;周六&quot; &#125;;  </span><br><span class="line">// 星期名称映射</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mon</code>数组：存储平年各月的天数（如1月31天，2月28天）；</li>
<li><code>week_day</code>数组：将0-6映射到「周日-周六」，用于后续星期几的输出。</li>
</ul>
<h3 id="闰年判断：时间的「校正器」"><a href="#闰年判断：时间的「校正器」" class="headerlink" title="闰年判断：时间的「校正器」"></a>闰年判断：时间的「校正器」</h3><p>闰年的规则是：能被4整除但不能被100整除，或能被400整除的年份。这个函数是日期计算的「时间校正器」：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool is_leap_year(int year) &#123;</span><br><span class="line">    return ((year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么需要闰年？</strong> 地球绕太阳公转周期约为365.2422天，平年365天会累积误差，闰年通过增加2月1天（29天）来修正。</p>
<h3 id="计算每月第一天的星期：月历的「定位仪」"><a href="#计算每月第一天的星期：月历的「定位仪」" class="headerlink" title="计算每月第一天的星期：月历的「定位仪」"></a>计算每月第一天的星期：月历的「定位仪」</h3><p>这个函数是月历打印的「定位仪」，它的作用是：计算「从公元1年1月1日到目标年月1日」的总天数，再通过取模7得到星期几（0&#x3D;周日，1&#x3D;周一...6&#x3D;周六）。实现步骤如下：</p>
<ol>
<li><strong>累计基准天数</strong>：<code>(year - 1) * 365</code>计算所有完整年的天数，加上闰年修正项<code>(year - 1)/4 - (year - 1)/100 + (year - 1)/400</code>（每4年一闰，每100年去闰，每400年加闰）；</li>
<li><strong>闰年修正</strong>：若当前年是闰年且月份&gt;2（2月已过），总天数加1；</li>
<li><strong>月份累计</strong>：从当年1月开始累加前几个月的天数（如计算3月1日，需累加1月和2月的天数）。</li>
</ol>
<p><strong>示例验证</strong>（2024年3月1日）：</p>
<ul>
<li>基准年（2023年及之前）：2023×365 + 2023&#x2F;4 - 2023&#x2F;100 + 2023&#x2F;400 &#x3D; 738315 + 505 - 20 + 5 &#x3D; 738805天；</li>
<li>闰年修正：2024是闰年且月份&gt;2，加1天 → 738806天；</li>
<li>月份累计：1月（31）+2月（29，闰年）&#x3D;60天 → 总天数738806+60&#x3D;738866天；</li>
<li>738866 % 7 &#x3D; 2 → 2024年3月1日是周二（<code>week_day[2]</code>）。</li>
</ul>
<hr>
<h2 id="功能实现：从代码到交互的全链路"><a href="#功能实现：从代码到交互的全链路" class="headerlink" title="功能实现：从代码到交互的全链路"></a>功能实现：从代码到交互的全链路</h2><h3 id="月历打印：对齐的艺术"><a href="#月历打印：对齐的艺术" class="headerlink" title="月历打印：对齐的艺术"></a>月历打印：对齐的艺术</h3><p>月历的核心是「对齐」——根据每月第一天的星期，在月初填充空白，然后逐行打印日期。代码实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void calendar_month(int year, int month) &#123;</span><br><span class="line">    printf(&quot;日\t一\t二\t三\t四\t五\t六\n&quot;);  // 表头</span><br><span class="line">    for (int i = 0; i &lt; 51; i++) printf(&quot;=&quot;);  // 分隔线</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    int first_day = month_first_day(year, month) % 7;  // 当月1日的星期（0=周日）</span><br><span class="line">    for (int i = 0; i &lt; first_day; i++) printf(&quot;\t&quot;);  // 填充月初空白</span><br><span class="line"></span><br><span class="line">    // 打印日期（1日到月末）</span><br><span class="line">    for (int d = 1; d &lt;= mon[month - 1]; d++) &#123;</span><br><span class="line">        printf(&quot;%d\t&quot;, d);</span><br><span class="line">        if ((first_day + d) % 7 == 0) printf(&quot;\n&quot;);  // 每7天换行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出示例</strong>（2024年3月）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">日	一	二	三	四	五	六</span><br><span class="line">===============================</span><br><span class="line">                1	2	3	4	5</span><br><span class="line">6	7	8	9	10	11	12</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="计算日期差：总天数相减的巧思"><a href="#计算日期差：总天数相减的巧思" class="headerlink" title="计算日期差：总天数相减的巧思"></a>计算日期差：总天数相减的巧思</h3><p>计算两个日期的天数差，本质是「总天数相减」。代码通过<code>month_first_day</code>获取两个日期到年初的总天数，再求差值的绝对值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case 1: &#123;</span><br><span class="line">    int days = month_first_day(year, month) + day;  // 当前日期到年初的总天数</span><br><span class="line">    printf(&quot;请输入第二个日期，例如2025年6月2日\n&quot;);</span><br><span class="line">    scanf(&quot;%d年%d月%d日&quot;, &amp;year, &amp;month, &amp;day);</span><br><span class="line">    days = days - (month_first_day(year, month) + day);  // 减去第二个日期的总天数</span><br><span class="line">    printf(&quot;天数差为：%d\n&quot;, abs(days));  // 取绝对值</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询星期几：星期的「解码器」"><a href="#查询星期几：星期的「解码器」" class="headerlink" title="查询星期几：星期的「解码器」"></a>查询星期几：星期的「解码器」</h3><p>通过<code>month_first_day</code>获取当月1日的星期，再加上日期数减1（因为1日是第0天），最后取模7得到星期索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case 2: &#123;</span><br><span class="line">    int week_index = (month_first_day(year, month) % 7 + day - 1) % 7;</span><br><span class="line">    printf(&quot;%d年%d月%d日是 %s\n&quot;, year, month, day, week_day[week_index]);</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输入验证：防错设计"><a href="#输入验证：防错设计" class="headerlink" title="输入验证：防错设计"></a>输入验证：防错设计</h3><p>代码通过多重校验确保用户输入的日期合法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 日期合法性校验（case 1-4共用）</span><br><span class="line">int max_day = mon[month - 1];  // 当月最大天数（平年）</span><br><span class="line">if (month == 2 &amp;&amp; is_leap_year(year)) max_day++;  // 闰年二月修正</span><br><span class="line">if (day &lt; 1 || day &gt; max_day || month &lt; 1 || month &gt; 12 || year &lt; 0) &#123;</span><br><span class="line">    printf(&quot;错误，重新输入\n&quot;);</span><br><span class="line">    continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="交互设计：从命令行到用户体验"><a href="#交互设计：从命令行到用户体验" class="headerlink" title="交互设计：从命令行到用户体验"></a>交互设计：从命令行到用户体验</h2><p>主函数通过<code>do-while</code>循环实现菜单驱动的交互界面，核心流程如下：</p>
<ol>
<li><strong>清空输入缓冲区</strong>：避免因输入错误（如输入字母）导致的死循环；</li>
<li><strong>菜单引导</strong>：清晰的选项提示（1-5）；</li>
<li><strong>错误处理</strong>：对非法输入（如月份13、日期32）进行友好提示；</li>
<li><strong>功能分发</strong>：根据用户选择调用对应函数。</li>
</ol>
<p><strong>示例交互流程</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请输入你想选择的功能：</span><br><span class="line">1.计算指定日期间的天数</span><br><span class="line">2.计算指定日期是星期几</span><br><span class="line">3.打印指定日期的月历</span><br><span class="line">4.打印指定日期年历</span><br><span class="line">5.退出</span><br><span class="line">1</span><br><span class="line">请输入日期，例如2025年6月2日</span><br><span class="line">2024年3月1日</span><br><span class="line">请输入第二个日期，例如2025年6月2日</span><br><span class="line">2024年3月2日</span><br><span class="line">计算指定日期间的天数差为：1</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="完整源代码"><a href="#完整源代码" class="headerlink" title="完整源代码"></a>完整源代码</h2><p>以下是项目的完整C语言源代码，可直接复制编译运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&quot;function.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">	</span><br><span class="line">	do &#123;</span><br><span class="line">		printf(&quot;请输入你想选择的功能：\n1.计算指定日期间的天数\n2.计算指定日期是星期几\n3.打印指定日期的月历\n4.打印指定日期年历\n5.退出\n&quot;);</span><br><span class="line">		scanf(&quot; %d&quot;, &amp;num);</span><br><span class="line">		while (getchar() != &#x27;\n&#x27;);</span><br><span class="line">		if (num &gt; 0 &amp;&amp; num &lt; 5)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;请输入日期，例如2025年6月2日\n&quot;);</span><br><span class="line">			if (scanf(&quot;%d年%d月%d日&quot;, &amp;year, &amp;month, &amp;day) != 3) &#123;</span><br><span class="line">				while (getchar() != &#x27;\n&#x27;);</span><br><span class="line">				printf(&quot;输入格式错误！\n&quot;);</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			if (day &gt; mon[month - 1] || is_leap_year(year) &amp;&amp; month == 2 &amp;&amp; day &gt; mon[1] + 1 || month &gt; 12 || day &lt; 0 || month &lt; 0 || year &lt; 0)</span><br><span class="line">			&#123;</span><br><span class="line">				printf(&quot;错误，重新输入\n&quot;);</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		switch (num) &#123;</span><br><span class="line">		case 1:</span><br><span class="line">		&#123;</span><br><span class="line">			days = month_first_day(year, month) + day;</span><br><span class="line">			printf(&quot;请输入第二个日期，例如2025年6月2日\n&quot;);</span><br><span class="line">			while (scanf(&quot;%d年%d月%d日&quot;, &amp;year, &amp;month, &amp;day) != 3) &#123;</span><br><span class="line">				while (getchar() != &#x27;\n&#x27;);</span><br><span class="line">				printf(&quot;输入格式错误2！\n&quot;);</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			days = days - (month_first_day(year, month) + day);</span><br><span class="line">			days = days &lt; 0 ? -days : days;</span><br><span class="line">			printf(&quot;计算指定日期间的天数差为%d\n&quot;, days);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		case 2:</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;%d年%d月%d日是 %s\n&quot;, year, month, day, week_day[(month_first_day(year, month) % 7 + day - 1) % 7]);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		case 3:</span><br><span class="line">		&#123;</span><br><span class="line">			calendar_month(year, month, day);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		case 4:</span><br><span class="line">		&#123;</span><br><span class="line">			for (int month = 1; month &lt; 13; month++)</span><br><span class="line">			&#123;</span><br><span class="line">				day = 1;</span><br><span class="line">				printf(&quot;\n\n&quot;);</span><br><span class="line">				printf(&quot;\t\t     %d年%d月\t\t\t&quot;, year, month);</span><br><span class="line">				printf(&quot;\n\n&quot;);</span><br><span class="line">				calendar_month(year, month, 1);</span><br><span class="line">				printf(&quot;\n&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		default:</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; while (num != 5);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="代码亮点总结"><a href="#代码亮点总结" class="headerlink" title="代码亮点总结"></a>代码亮点总结</h2><ul>
<li><strong>模块化设计</strong>：通过函数拆分（如<code>is_leap_year</code>、<code>month_first_day</code>）实现逻辑解耦，便于维护；</li>
<li><strong>输入验证</strong>：使用<code>while (getchar() != &#39; &#39;)</code>清空缓冲区，避免因输入错误导致的死循环；</li>
<li><strong>高效算法</strong>：基于总天数差计算日期间隔，避免逐月累加的低效操作；</li>
<li><strong>友好的交互</strong>：清晰的菜单引导和错误提示，提升用户体验。</li>
</ul>
<p>通过本文的完整代码，读者可直接运行并体验日期工具的所有功能，同时深入理解日期处理的底层逻辑！</p>
]]></content>
      <categories>
        <category>CODE</category>
      </categories>
      <tags>
        <tag>CODE</tag>
        <tag>C语言</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言实现简易书籍管理系统</title>
    <url>/posts/12989e68/</url>
    <content><![CDATA[<hr>
<h2 id="引言：为什么需要书籍管理系统？"><a href="#引言：为什么需要书籍管理系统？" class="headerlink" title="引言：为什么需要书籍管理系统？"></a>引言：为什么需要书籍管理系统？</h2><p>在日常生活中，我们常常需要整理自己的书籍收藏：可能是个人阅读清单、家庭藏书目录，或是小型图书馆的管理需求。手动记录书籍信息（如书名、作者、类别）容易出错，且查询效率低下。今天，我们将用C语言实现一个<strong>简易书籍管理系统</strong>，通过结构化的数据存储和友好的用户交互，解决这一痛点。</p>
<p>这个系统将实现以下核心功能：</p>
<ul>
<li>存储书籍的基础信息（编号、书名、作者、类别）；</li>
<li>按类别快速筛选书籍；</li>
<li>清晰展示所有书籍信息；</li>
<li>提供用户友好的交互界面。</li>
</ul>
<p>通过这个项目，你将掌握C语言中枚举、结构体、函数封装、用户输入处理等核心技术的实际应用。</p>
<hr>
<h2 id="核心数据结构：用枚举和结构体组织信息"><a href="#核心数据结构：用枚举和结构体组织信息" class="headerlink" title="核心数据结构：用枚举和结构体组织信息"></a>核心数据结构：用枚举和结构体组织信息</h2><h3 id="枚举类型：定义书籍类别"><a href="#枚举类型：定义书籍类别" class="headerlink" title="枚举类型：定义书籍类别"></a>枚举类型：定义书籍类别</h3><p>书籍的类别是固定的（如科幻、文学、历史等），使用枚举（<code>enum</code>）可以避免魔法数字，提高代码可读性。在头文件<code>function.h</code>中定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef enum Genre &#123;</span><br><span class="line">    SCIENCE_FICTION = 0,  // 科幻</span><br><span class="line">    LITERATURE = 1,       // 文学</span><br><span class="line">    HISTORY = 2,          // 历史</span><br><span class="line">    TECHNOLOGY = 3,       // 科技</span><br><span class="line">    OTHER = 4             // 其他</span><br><span class="line">&#125; Genre;</span><br></pre></td></tr></table></figure>

<h3 id="结构体：封装书籍信息"><a href="#结构体：封装书籍信息" class="headerlink" title="结构体：封装书籍信息"></a>结构体：封装书籍信息</h3><p>每本书的信息可以封装为一个结构体（<code>struct</code>），将相关数据绑定在一起。结构体<code>Book</code>包含编号、书名、作者和类别四个字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct Book &#123;</span><br><span class="line">    int num;              // 编号（唯一标识）</span><br><span class="line">    char name[15];        // 书名（最多14字符+终止符）</span><br><span class="line">    char author[20];      // 作者（最多19字符+终止符）</span><br><span class="line">    Genre genre;          // 类别（使用枚举类型）</span><br><span class="line">&#125; Book;</span><br></pre></td></tr></table></figure>

<h3 id="初始化书籍数组"><a href="#初始化书籍数组" class="headerlink" title="初始化书籍数组"></a>初始化书籍数组</h3><p>为了演示功能，我们在源文件<code>main.c</code>中预先初始化一个包含10本书的数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Book books[MAX_BOOKS] = &#123;</span><br><span class="line">    &#123;1, &quot;三体&quot;, &quot;刘慈欣&quot;, SCIENCE_FICTION&#125;,</span><br><span class="line">    &#123;2, &quot;红楼梦&quot;, &quot;曹雪芹&quot;, LITERATURE&#125;,</span><br><span class="line">    &#123;3, &quot;中国通史&quot;, &quot;吕思勉&quot;, HISTORY&#125;,</span><br><span class="line">    &#123;4, &quot;时间简史&quot;, &quot;史蒂芬_霍金&quot;, TECHNOLOGY&#125;,</span><br><span class="line">    &#123;5, &quot;围城&quot;, &quot;钱钟书&quot;, LITERATURE&#125;,</span><br><span class="line">    &#123;6, &quot;傲慢与偏见&quot;, &quot;简_奥斯汀&quot;, LITERATURE&#125;,</span><br><span class="line">    &#123;7, &quot;呼啸山庄&quot;, &quot;艾米莉_勃朗特&quot;, LITERATURE&#125;,</span><br><span class="line">    &#123;8, &quot;活着&quot;, &quot;余华&quot;, LITERATURE&#125;,</span><br><span class="line">    &#123;9, &quot;明朝那些事儿&quot;, &quot;当年明月&quot;, HISTORY&#125;,</span><br><span class="line">    &#123;10, &quot;乌合之众&quot;, &quot;古斯塔夫_勒庞&quot;, OTHER&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="功能实现：从数据打印到类别筛选"><a href="#功能实现：从数据打印到类别筛选" class="headerlink" title="功能实现：从数据打印到类别筛选"></a>功能实现：从数据打印到类别筛选</h2><h3 id="函数1：Genre-Zn——枚举转中文"><a href="#函数1：Genre-Zn——枚举转中文" class="headerlink" title="函数1：Genre_Zn——枚举转中文"></a>函数1：<code>Genre_Zn</code>——枚举转中文</h3><p>枚举值（如<code>SCIENCE_FICTION</code>）是数字，直接打印不直观。通过<code>switch</code>语句将其转换为中文字符串，增强可读性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const char *Genre_Zn(Genre i) &#123;</span><br><span class="line">    switch (i) &#123;</span><br><span class="line">        case SCIENCE_FICTION: return &quot;科幻&quot;;</span><br><span class="line">        case LITERATURE:         return &quot;文学&quot;;</span><br><span class="line">        case HISTORY:          return &quot;历史&quot;;</span><br><span class="line">        case TECHNOLOGY:          return &quot;科技&quot;;</span><br><span class="line">        case OTHER:          return &quot;其他&quot;;</span><br><span class="line">        default:              return &quot;未知&quot;;  // 处理非法输入</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数2：print-book-info——打印所有书籍信息"><a href="#函数2：print-book-info——打印所有书籍信息" class="headerlink" title="函数2：print_book_info——打印所有书籍信息"></a>函数2：<code>print_book_info</code>——打印所有书籍信息</h3><p>该函数遍历书籍数组，按固定格式打印每本书的详细信息。为了美观，使用分隔线增强可读性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void print_book_info(Book *books, int count) &#123;</span><br><span class="line">    // 打印分隔线（21个&quot;-&quot;）</span><br><span class="line">    for (int i = 0; i &lt; 21; i++) printf(&quot;-&quot;);</span><br><span class="line">    printf(&quot; 所有的书籍信息 &quot;);</span><br><span class="line">    for (int i = 0; i &lt; 21; i++) printf(&quot;-&quot;);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 遍历并打印每本书</span><br><span class="line">    for (int i = 0; i &lt; MAX_BOOKS; i++) &#123;</span><br><span class="line">        printf(&quot;编号:%-2d  书名:%-12s  作者:%-13s   类别:%-8s\n&quot;,books[i].num, books[i].name,books[i].author,Genre_Zn(books[i].genre));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数3：find-books-by-genre——按类别筛选书籍"><a href="#函数3：find-books-by-genre——按类别筛选书籍" class="headerlink" title="函数3：find_books_by_genre——按类别筛选书籍"></a>函数3：<code>find_books_by_genre</code>——按类别筛选书籍</h3><p>用户输入类别编号后，该函数遍历数组，只打印符合条件的书籍：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void find_books_by_genre(Book *books, int count, Genre genre) &#123;</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        if (books[i].genre == genre) &#123;</span><br><span class="line">            printf(&quot;编号:%-2d  书名:%-12s  作者:%-13s   类别:%-8s\n&quot;,books[i].num, books[i].name,books[i].author,Genre_Zn(books[i].genre));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="主函数：用户交互流程"><a href="#主函数：用户交互流程" class="headerlink" title="主函数：用户交互流程"></a>主函数：用户交互流程</h2><p>主函数负责调用上述函数，提供交互界面。用户可以查看所有书籍，或按类别筛选书籍，输入<code>5</code>退出程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main(void) &#123;</span><br><span class="line">    // 打印所有书籍信息</span><br><span class="line">    print_book_info(books, MAX_BOOKS);</span><br><span class="line"></span><br><span class="line">    // 用户按类别查询循环</span><br><span class="line">    Genre gen;</span><br><span class="line">    do &#123;</span><br><span class="line">        printf(&quot;\n请输入书籍类别编号（0:科幻 1.文学 2.历史 3.科技 4.其他 5.退出）\n&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;gen);  // 读取用户输入的类别编号</span><br><span class="line">        find_books_by_genre(books, MAX_BOOKS, gen);  // 筛选并打印</span><br><span class="line">    &#125; while (gen != 5);  // 输入5时退出循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="测试与验证：运行效果展示"><a href="#测试与验证：运行效果展示" class="headerlink" title="测试与验证：运行效果展示"></a>测试与验证：运行效果展示</h2><h3 id="初始书籍列表打印"><a href="#初始书籍列表打印" class="headerlink" title="初始书籍列表打印"></a>初始书籍列表打印</h3><p>程序启动后，首先打印所有书籍的信息，输出类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--------------------- 所有的书籍信息 ---------------------</span><br><span class="line"></span><br><span class="line">编号:1  书名:三体        作者:刘慈欣       类别:科幻    </span><br><span class="line">编号:2  书名:红楼梦      作者:曹雪芹       类别:文学    </span><br><span class="line">编号:3  书名:中国通史    作者:吕思勉       类别:历史    </span><br><span class="line">编号:4  书名:时间简史    作者:史蒂芬_霍金   类别:科技    </span><br><span class="line">编号:5  书名:围城        作者:钱钟书       类别:文学    </span><br><span class="line">编号:6  书名:傲慢与偏见  作者:简_奥斯汀    类别:文学    </span><br><span class="line">编号:7  书名:呼啸山庄    作者:艾米莉_勃朗特 类别:文学    </span><br><span class="line">编号:8  书名:活着        作者:余华         类别:文学    </span><br><span class="line">编号:9  书名:明朝那些事儿  作者:当年明月     类别:历史    </span><br><span class="line">编号:10 书名:乌合之众    作者:古斯塔夫_勒庞 类别:其他    </span><br></pre></td></tr></table></figure>

<h3 id="按类别查询功能"><a href="#按类别查询功能" class="headerlink" title="按类别查询功能"></a>按类别查询功能</h3><p>用户输入<code>1</code>（文学），程序筛选并打印所有文学类书籍：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编号:2  书名:红楼梦      作者:曹雪芹       类别:文学    </span><br><span class="line">编号:5  书名:围城        作者:钱钟书       类别:文学    </span><br><span class="line">编号:6  书名:傲慢与偏见  作者:简_奥斯汀    类别:文学    </span><br><span class="line">编号:7  书名:呼啸山庄    作者:艾米莉_勃朗特 类别:文学    </span><br><span class="line">编号:8  书名:活着        作者:余华         类别:文学    </span><br></pre></td></tr></table></figure>

<p>输入<code>5</code>后，程序退出。</p>
<hr>
<h2 id="潜在问题"><a href="#潜在问题" class="headerlink" title="潜在问题"></a>潜在问题</h2><h3 id="问题1：MAX-BOOKS未定义"><a href="#问题1：MAX-BOOKS未定义" class="headerlink" title="问题1：MAX_BOOKS未定义"></a>问题1：<code>MAX_BOOKS</code>未定义</h3><p>当前代码中<code>MAX_BOOKS</code>在<code>function.h</code>中定义为<code>10</code>，但需确保源文件<code>main.c</code>和<code>function.c</code>中一致。若书籍数量超过<code>MAX_BOOKS</code>，会导致数组越界。需要在<code>function.h</code>中明确定义，并在使用时检查边界。</p>
<h3 id="改进建议1：增加书籍属性"><a href="#改进建议1：增加书籍属性" class="headerlink" title="改进建议1：增加书籍属性"></a>改进建议1：增加书籍属性</h3><p>可以扩展<code>Book</code>结构体，添加出版年份、ISBN、页数等字段，丰富信息维度：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct Book &#123;</span><br><span class="line">    int num;              // 编号</span><br><span class="line">    char name[15];        // 书名</span><br><span class="line">    char author[20];      // 作者</span><br><span class="line">    Genre genre;          // 类别</span><br><span class="line">    int publish_year;     // 出版年份（新增）</span><br><span class="line">    char isbn[13];        // ISBN（新增）</span><br><span class="line">&#125; Book;</span><br></pre></td></tr></table></figure>

<h3 id="改进建议2：数据持久化"><a href="#改进建议2：数据持久化" class="headerlink" title="改进建议2：数据持久化"></a>改进建议2：数据持久化</h3><p>当前书籍数据是硬编码的，重启程序后数据丢失。可以将数据保存到文件（如<code>books.txt</code>），启动时读取，实现持久化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 示例：从文件读取书籍数据</span><br><span class="line">FILE *fp = fopen(&quot;books.txt&quot;, &quot;r&quot;);</span><br><span class="line">if (fp) &#123;</span><br><span class="line">    fscanf(fp, &quot;%d&quot;, &amp;count);  // 读取书籍数量</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        fscanf(fp, &quot;%d %s %s %d&quot;, &amp;books[i].num, books[i].name, books[i].author, &amp;books[i].genre);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="改进建议3：图形化界面"><a href="#改进建议3：图形化界面" class="headerlink" title="改进建议3：图形化界面"></a>改进建议3：图形化界面</h3><p>当前交互是命令行形式，可通过<code>SDL</code>或<code>Qt</code>等库开发图形界面（GUI），提升用户体验。</p>
<hr>
<h2 id="总结：从代码到能力的提升"><a href="#总结：从代码到能力的提升" class="headerlink" title="总结：从代码到能力的提升"></a>总结：从代码到能力的提升</h2><p>通过这个简易书籍管理系统，我们实践了C语言的核心知识点：</p>
<ul>
<li><strong>枚举类型</strong>：定义固定类别，提高代码可读性；</li>
<li><strong>结构体</strong>：封装复杂数据，组织信息更清晰；</li>
<li><strong>函数封装</strong>：将功能拆分为独立函数，提升代码复用性；</li>
<li><strong>用户交互</strong>：处理输入输出，实现基础的CLI（命令行界面）。</li>
</ul>
<p>这些经验是后续开发更复杂系统（如学生管理系统、库存管理系统）的基础。不妨尝试扩展本文的功能（如添加书籍、删除书籍），在实践中进一步提升编程能力！</p>
<hr>
<h2 id="完整源代码"><a href="#完整源代码" class="headerlink" title="完整源代码"></a>完整源代码</h2><h3 id="头文件-function-h"><a href="#头文件-function-h" class="headerlink" title="头文件 function.h"></a>头文件 function.h</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef FUNCTION_H</span><br><span class="line">#define FUNCTION_H</span><br><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#define MAX_BOOKS 10</span><br><span class="line"></span><br><span class="line">typedef enum Genre &#123;</span><br><span class="line">    SCIENCE_FICTION = 0,</span><br><span class="line">    LITERATURE = 1,</span><br><span class="line">    HISTORY = 2,</span><br><span class="line">    TECHNOLOGY = 3,</span><br><span class="line">    OTHER = 4</span><br><span class="line">&#125; Genre;</span><br><span class="line"></span><br><span class="line">typedef struct Book &#123;</span><br><span class="line">    int num;</span><br><span class="line">    char name[15];</span><br><span class="line">    char author[20];</span><br><span class="line">    Genre genre;</span><br><span class="line">&#125; Book;</span><br><span class="line"></span><br><span class="line">const char *Genre_Zn(Genre i);</span><br><span class="line">void print_book_info(Book *books, int count);</span><br><span class="line">void find_books_by_genre(Book *books, int count, Genre genre);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h3 id="源文件-main-c"><a href="#源文件-main-c" class="headerlink" title="源文件 main.c"></a>源文件 main.c</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &quot;function.h&quot;</span><br><span class="line"></span><br><span class="line">Book books[MAX_BOOKS] = &#123;</span><br><span class="line">    &#123;1, &quot;三体&quot;, &quot;刘慈欣&quot;, SCIENCE_FICTION&#125;,</span><br><span class="line">    &#123;2, &quot;红楼梦&quot;, &quot;曹雪芹&quot;, LITERATURE&#125;,</span><br><span class="line">    &#123;3, &quot;中国通史&quot;, &quot;吕思勉&quot;, HISTORY&#125;,</span><br><span class="line">    &#123;4, &quot;时间简史&quot;, &quot;史蒂芬_霍金&quot;, TECHNOLOGY&#125;,</span><br><span class="line">    &#123;5, &quot;围城&quot;, &quot;钱钟书&quot;, LITERATURE&#125;,</span><br><span class="line">    &#123;6, &quot;傲慢与偏见&quot;, &quot;简_奥斯汀&quot;, LITERATURE&#125;,</span><br><span class="line">    &#123;7, &quot;呼啸山庄&quot;, &quot;艾米莉_勃朗特&quot;, LITERATURE&#125;,</span><br><span class="line">    &#123;8, &quot;活着&quot;, &quot;余华&quot;, LITERATURE&#125;,</span><br><span class="line">    &#123;9, &quot;明朝那些事儿&quot;, &quot;当年明月&quot;, HISTORY&#125;,</span><br><span class="line">    &#123;10, &quot;乌合之众&quot;, &quot;古斯塔夫_勒庞&quot;, OTHER&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    print_book_info(books, MAX_BOOKS);</span><br><span class="line">    Genre gen;</span><br><span class="line">    do &#123;</span><br><span class="line">        printf(&quot;\n请输入书籍类别编号（0:科幻 1.文学 2.历史 3.科技 4.其他 5.退出）\n&quot;);</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;gen);</span><br><span class="line">        find_books_by_genre(books, MAX_BOOKS, gen);</span><br><span class="line">    &#125; while (gen != 5);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="源文件-function-c"><a href="#源文件-function-c" class="headerlink" title="源文件 function.c"></a>源文件 function.c</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &quot;function.h&quot;</span><br><span class="line"></span><br><span class="line">const char *Genre_Zn(Genre i) &#123;</span><br><span class="line">	switch (i) &#123;</span><br><span class="line">	case SCIENCE_FICTION: return &quot;科幻&quot;;</span><br><span class="line">	case LITERATURE:         return &quot;文学&quot;;</span><br><span class="line">	case HISTORY:          return &quot;历史&quot;;</span><br><span class="line">	case TECHNOLOGY:          return &quot;科技&quot;;</span><br><span class="line">	case OTHER:          return &quot;其他&quot;;</span><br><span class="line">	default:              return &quot;未知&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_book_info(Book *books, int count) &#123;</span><br><span class="line">	for (int i = 0; i &lt; 21; i++) printf(&quot;-&quot;);</span><br><span class="line">	printf(&quot; 所有的书籍信息 &quot;);</span><br><span class="line">	for (int i = 0; i &lt; 21; i++) printf(&quot;-&quot;);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; MAX_BOOKS; i++) &#123;</span><br><span class="line">		printf(&quot;编号:%-2d  书名:%-12s  作者:%-13s   类别:%-8s\n&quot;, books[i].num, books[i].name, books[i].author, Genre_Zn(books[i].genre));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void find_books_by_genre(Book *books, int count, Genre genre) &#123;</span><br><span class="line">	for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">		if (books[i].genre == genre) &#123;</span><br><span class="line">			printf(&quot;编号:%-2d  书名:%-12s  作者:%-13s   类别:%-8s\n&quot;, books[i].num, books[i].name, books[i].author, Genre_Zn(books[i].genre));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODE</category>
      </categories>
      <tags>
        <tag>CODE</tag>
        <tag>C语言</tag>
        <tag>结构体</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>C标准库字符串函数复现</title>
    <url>/posts/83143407/</url>
    <content><![CDATA[<hr>
<h2 id="引言：为什么需要复现标准库字符串函数？"><a href="#引言：为什么需要复现标准库字符串函数？" class="headerlink" title="引言：为什么需要复现标准库字符串函数？"></a>引言：为什么需要复现标准库字符串函数？</h2><p>在C语言开发中，&#96;&#96;提供的字符串函数（如<code>strlen</code>、<code>strcpy</code>）是最常用的工具之一。但这些函数的底层实现逻辑你真的清楚吗？</p>
<ul>
<li><strong>学习价值</strong>：复现标准库函数能帮你深入理解字符串操作的底层逻辑（如空终止符的作用、内存复制的安全性）；</li>
<li><strong>工程实践</strong>：在嵌入式开发、操作系统内核等场景中，可能因内存限制或安全要求无法直接使用标准库，需自定义实现；</li>
<li><strong>避坑指南</strong>：了解标准库函数的潜在问题（如<code>strcpy</code>的缓冲区溢出风险），能帮助你在实际开发中写出更安全的代码。</li>
</ul>
<p>今天，我们就通过复现6个核心字符串函数（<code>strlen</code>、<code>strcpy</code>、<code>strncpy</code>、<code>strcat</code>、<code>strncat</code>、<code>strcmp</code>），彻底掌握字符串操作的底层原理！</p>
<hr>
<h2 id="复现1：my-strlen——计算字符串长度"><a href="#复现1：my-strlen——计算字符串长度" class="headerlink" title="复现1：my_strlen——计算字符串长度"></a>复现1：<code>my_strlen</code>——计算字符串长度</h2><h3 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h3><p><code>my_strlen</code>用于计算字符串的有效字符数（不包含空终止符<code>\0</code>）。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>从字符串起始地址开始遍历，每遇到一个非<code>\0</code>字符计数加1，直到遇到<code>\0</code>停止。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">size_t my_strlen(const char *p) &#123;</span><br><span class="line">    size_t count = 0;</span><br><span class="line">    while (*p != &#x27;\0&#x27;) &#123;  // 遍历直到空终止符</span><br><span class="line">        count++;</span><br><span class="line">        p++;              // 移动到下一个字符</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li>使用<code>size_t</code>类型避免负数问题（长度不可能为负）；</li>
<li>时间复杂度为O(n)（n为字符串长度），空间复杂度为O(1)（仅用计数器）。</li>
</ul>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char p[30] = &quot;122345&quot;; </span><br><span class="line">printf(&quot;%zu\n&quot;, my_strlen(p));  // 输出6（字符&#x27;1&#x27;,&#x27;2&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;）</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="复现2：my-strcpy——复制字符串内容"><a href="#复现2：my-strcpy——复制字符串内容" class="headerlink" title="复现2：my_strcpy——复制字符串内容"></a>复现2：<code>my_strcpy</code>——复制字符串内容</h2><h3 id="功能说明-1"><a href="#功能说明-1" class="headerlink" title="功能说明"></a>功能说明</h3><p><code>my_strcpy</code>将源字符串（<code>src</code>）的内容复制到目标字符串（<code>dest</code>），并确保<code>dest</code>以<code>\0</code>结尾。</p>
<h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><ol>
<li>保存<code>dest</code>的起始地址（用于返回）；</li>
<li>逐个复制<code>src</code>的字符到<code>dest</code>，直到遇到<code>src</code>的<code>\0</code>；</li>
<li>手动在<code>dest</code>末尾添加<code>\0</code>（确保目标字符串合法）。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *my_strcpy(char *dest, const char *src) &#123;</span><br><span class="line">    char *tmp = dest;       // 保存目标起始地址</span><br><span class="line">    while (*src != &#x27;\0&#x27;) &#123;  // 复制直到源字符串结束</span><br><span class="line">        *dest++ = *src++;   // 逐个字符复制（后置++避免覆盖）</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = &#x27;\0&#x27;;           // 手动添加空终止符</span><br><span class="line">    return tmp;             // 返回目标起始地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li>必须确保<code>dest</code>有足够空间容纳<code>src</code>的内容（否则会导致缓冲区溢出）；</li>
<li>返回<code>dest</code>的起始地址是为了支持链式调用（如<code>strcpy(dest, strcpy(tmp, src))</code>）。</li>
</ul>
<h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char p[30] = &quot;122345&quot;; </span><br><span class="line">char q[] = &quot;12234&quot;; </span><br><span class="line">printf(&quot;%s\n&quot;, my_strcpy(p, q));  // 输出&quot;12234&quot;（p被覆盖为q的内容）</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="复现3：my-strncpy——安全复制（限制长度）"><a href="#复现3：my-strncpy——安全复制（限制长度）" class="headerlink" title="复现3：my_strncpy——安全复制（限制长度）"></a>复现3：<code>my_strncpy</code>——安全复制（限制长度）</h2><h3 id="功能说明-2"><a href="#功能说明-2" class="headerlink" title="功能说明"></a>功能说明</h3><p><code>my_strncpy</code>将源字符串的前<code>n</code>个字符复制到目标字符串，若源字符串长度小于<code>n</code>，则用<code>\0</code>填充剩余空间。</p>
<h3 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h3><ol>
<li>遍历源字符串的前<code>n</code>个字符（或直到遇到<code>\0</code>）；</li>
<li>若源字符串长度不足<code>n</code>，继续用<code>\0</code>填充目标字符串至<code>n</code>长度。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *my_strncpy(char *dest, const char *src, size_t n) &#123;</span><br><span class="line">    size_t i;</span><br><span class="line">    for (i = 0; i &lt; n &amp;&amp; src[i] != &#x27;\0&#x27;; i++) &#123;  // 复制前n个有效字符</span><br><span class="line">        dest[i] = src[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (; i &lt; n; i++) &#123;                        // 填充剩余空间为\0</span><br><span class="line">        dest[i] = &#x27;\0&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    return dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键点-2"><a href="#关键点-2" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li>若<code>n</code>大于源字符串长度，目标字符串末尾会被填充<code>\0</code>（避免未终止）；</li>
<li>若<code>n</code>小于源字符串长度，仅复制前<code>n</code>个字符（目标字符串不会以<code>\0</code>结尾！需额外处理）。</li>
</ul>
<h3 id="测试用例-2"><a href="#测试用例-2" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char p[30] = &quot;122345&quot;; </span><br><span class="line">char a[] = &quot;128757&quot;; </span><br><span class="line">printf(&quot;%s\n&quot;, my_strncpy(p, a, 4));  // 输出&quot;1287&quot;（复制前4个字符）</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="复现4：my-strcat——拼接字符串"><a href="#复现4：my-strcat——拼接字符串" class="headerlink" title="复现4：my_strcat——拼接字符串"></a>复现4：<code>my_strcat</code>——拼接字符串</h2><h3 id="功能说明-3"><a href="#功能说明-3" class="headerlink" title="功能说明"></a>功能说明</h3><p><code>my_strcat</code>将源字符串（<code>src</code>）的内容追加到目标字符串（<code>dest</code>）的末尾，并确保<code>dest</code>以<code>\0</code>结尾。</p>
<h3 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h3><ol>
<li>找到<code>dest</code>的末尾（空终止符位置）；</li>
<li>将<code>src</code>的字符逐个复制到<code>dest</code>末尾，直到<code>src</code>结束；</li>
<li>手动在<code>dest</code>末尾添加<code>\0</code>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *my_strcat(char *dest, const char *src) &#123;</span><br><span class="line">    char *tmp = dest;       // 保存目标起始地址</span><br><span class="line">    while (*dest != &#x27;\0&#x27;) &#123; // 找到dest的末尾</span><br><span class="line">        dest++;</span><br><span class="line">    &#125;</span><br><span class="line">    while ((*dest++ = *src++) != &#x27;\0&#x27;);  // 复制src到dest末尾</span><br><span class="line">    *dest = &#x27;\0&#x27;;           // 手动添加空终止符（防止src未终止导致dest越界）</span><br><span class="line">    return tmp;             // 返回目标起始地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键点-3"><a href="#关键点-3" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li>必须确保<code>dest</code>有足够空间容纳<code>src</code>的内容（否则会导致缓冲区溢出）；</li>
<li>若<code>dest</code>原本为空字符串（<code>&quot;&quot;</code>），则直接复制<code>src</code>。</li>
</ul>
<h3 id="测试用例-3"><a href="#测试用例-3" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char p[30] = &quot;122345&quot;; </span><br><span class="line">char a[] = &quot;128757&quot;; </span><br><span class="line">printf(&quot;%s\n&quot;, my_strcat(p, a));  // 输出&quot;122345128757&quot;（p被扩展为两字符串拼接结果）</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="复现5：my-strncat——安全拼接（限制长度）"><a href="#复现5：my-strncat——安全拼接（限制长度）" class="headerlink" title="复现5：my_strncat——安全拼接（限制长度）"></a>复现5：<code>my_strncat</code>——安全拼接（限制长度）</h2><h3 id="功能说明-4"><a href="#功能说明-4" class="headerlink" title="功能说明"></a>功能说明</h3><p><code>my_strncat</code>将源字符串的前<code>n</code>个字符追加到目标字符串（<code>dest</code>）的末尾，并确保<code>dest</code>以<code>\0</code>结尾。</p>
<h3 id="实现原理-4"><a href="#实现原理-4" class="headerlink" title="实现原理"></a>实现原理</h3><ol>
<li>找到<code>dest</code>的末尾（空终止符位置）；</li>
<li>复制源字符串的前<code>n</code>个字符到<code>dest</code>末尾（若源字符串提前结束则停止）；</li>
<li>手动在<code>dest</code>末尾添加<code>\0</code>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *my_strncat(char *dest, const char *src, size_t n) &#123;</span><br><span class="line">    char *tmp = dest;       // 保存目标起始地址</span><br><span class="line">    while (*dest != &#x27;\0&#x27;) &#123; // 找到dest的末尾</span><br><span class="line">        dest++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (size_t i = 0; i &lt; n &amp;&amp; *src != &#x27;\0&#x27;; i++) &#123;  // 复制前n个字符（或源提前结束）</span><br><span class="line">        *dest++ = *src++;</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = &#x27;\0&#x27;;           // 手动添加空终止符</span><br><span class="line">    return tmp;             // 返回目标起始地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键点-4"><a href="#关键点-4" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li>若<code>n</code>大于源字符串长度，仅复制源的全部内容并在末尾添加<code>\0</code>；</li>
<li>若<code>n</code>小于源字符串长度，复制前<code>n</code>个字符后强制终止<code>dest</code>。</li>
</ul>
<h3 id="测试用例-4"><a href="#测试用例-4" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char p[30] = &quot;122345&quot;; </span><br><span class="line">char a[] = &quot;128757&quot;; </span><br><span class="line">printf(&quot;%s\n&quot;, my_strncat(p, a, 4));  // 输出&quot;1223451287&quot;（p末尾追加前4个字符）</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="复现6：my-strcmp——比较字符串大小"><a href="#复现6：my-strcmp——比较字符串大小" class="headerlink" title="复现6：my_strcmp——比较字符串大小"></a>复现6：<code>my_strcmp</code>——比较字符串大小</h2><h3 id="功能说明-5"><a href="#功能说明-5" class="headerlink" title="功能说明"></a>功能说明</h3><p><code>my_strcmp</code>逐个比较两个字符串的字符，返回它们的字典序关系（负数、0、正数分别表示<code>str1 &lt; str2</code>、<code>相等</code>、<code>str1 &gt; str2</code>）。</p>
<h3 id="实现原理-5"><a href="#实现原理-5" class="headerlink" title="实现原理"></a>实现原理</h3><p>逐个比较<code>str1</code>和<code>str2</code>的字符，直到遇到不同的字符或其中一个字符串结束：</p>
<ul>
<li>若字符值不同，返回它们的ASCII差值（<code>*(unsigned char *)str1 - *(unsigned char *)str2</code>）；</li>
<li>若全部字符相同且同时结束，返回0。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int my_strcmp(const char *str1, const char *str2) &#123;</span><br><span class="line">    while (*str1 &amp;&amp; *str2 &amp;&amp; *str1 == *str2) &#123;  </span><br><span class="line">    // 字符相同且未结束则继续</span><br><span class="line">        str1++;</span><br><span class="line">        str2++;</span><br><span class="line">    &#125;</span><br><span class="line">    return *(unsigned char *)str1 - *(unsigned char *)str2;  </span><br><span class="line">    // 返回差值（处理符号问题）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键点-5"><a href="#关键点-5" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li>使用<code>unsigned char</code>强制转换避免符号扩展问题（如<code>char</code>为有符号类型时，<code>\xff</code>会被视为-1）；</li>
<li>若两个字符串完全相同但长度不同（如<code>&quot;abc&quot;</code>和<code>&quot;abcd&quot;</code>），会在较短字符串的<code>\0</code>处停止比较，返回<code>\0 - &#39;d&#39;</code>（负数）。</li>
</ul>
<h3 id="测试用例-5"><a href="#测试用例-5" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char a[] = &quot;128757&quot;; </span><br><span class="line">char q[] = &quot;12234&quot;; </span><br><span class="line">printf(&quot;%d\n&quot;, my_strcmp(a, q));  // 输出正数（&quot;128757&quot; &gt; &quot;12234&quot;）</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="主函数测试：验证所有函数"><a href="#主函数测试：验证所有函数" class="headerlink" title="主函数测试：验证所有函数"></a>主函数测试：验证所有函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main(void) &#123;</span><br><span class="line">    char p[30] = &quot;122345&quot;;  // 可修改的数组</span><br><span class="line">    char q[] = &quot;12234&quot;;</span><br><span class="line">    char a[] = &quot;128757&quot;;</span><br><span class="line"></span><br><span class="line">    // 测试 strcmp</span><br><span class="line">    printf(&quot;%d\n&quot;, my_strcmp(a, q));  // 输出正数（&quot;128757&quot; &gt; &quot;12234&quot;）</span><br><span class="line"></span><br><span class="line">    // 测试 strlen</span><br><span class="line">    printf(&quot;%zu\n&quot;, my_strlen(p));  // 输出6（字&#x27;1&#x27;,&#x27;2&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;）</span><br><span class="line"></span><br><span class="line">    // 测试 strcpy</span><br><span class="line">    printf(&quot;%s\n&quot;, my_strcpy(p, q));  // 输出&quot;12234&quot;（p被覆盖为q的内容）</span><br><span class="line"></span><br><span class="line">    // 测试 strcmp（比较修改后的p和q）</span><br><span class="line">    printf(&quot;%d\n&quot;, my_strcmp(p, q));  // 输出0（两者内容相同）</span><br><span class="line"></span><br><span class="line">    // 测试 strncpy（复制前4个字符）</span><br><span class="line">    printf(&quot;%s\n&quot;, my_strncpy(p, a, 4));  // 输出&quot;1287&quot;（p前4位被覆盖）</span><br><span class="line"></span><br><span class="line">    // 测试 strcat（拼接a到p末尾）</span><br><span class="line">    printf(&quot;%s\n&quot;, my_strcat(p, a));  // 输出&quot;1287128757&quot;（p末尾追加a的内容）</span><br><span class="line"></span><br><span class="line">    // 测试 strncat（拼接前4个字符）</span><br><span class="line">    printf(&quot;%s\n&quot;, my_strncat(p, a, 4));  // 输出&quot;128712871287&quot;（p末尾追加前4个字符）</span><br><span class="line"></span><br><span class="line">    // 测试 strcpy（再次覆盖p）</span><br><span class="line">    printf(&quot;%s\n&quot;, my_strcpy(p, q));  // 输出&quot;12234&quot;（p被覆盖为q的内容）</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结：复现标准库函数的价值"><a href="#总结：复现标准库函数的价值" class="headerlink" title="总结：复现标准库函数的价值"></a>总结：复现标准库函数的价值</h2><blockquote>
<p>通过手动实现C语言标准库的字符串函数，我们不仅掌握了底层内存操作的细节（如空终止符的作用、缓冲区溢出的风险），更深入理解了这些函数的设计逻辑和潜在陷阱。这对提升代码的安全性（如避免<code>strcpy</code>的缓冲区溢出）、优化性能（如<code>strncpy</code>的按需复制）以及调试复杂问题（如字符串越界）都有重要意义。</p>
</blockquote>
<blockquote>
<p>下次遇到字符串操作需求时，不妨尝试自己实现核心逻辑——这不仅能加深对C语言的理解，更能让你在工程实践中写出更健壮的代码！</p>
</blockquote>
<hr>
<h2 id="完整源代码：复现C语言标准库字符串函数"><a href="#完整源代码：复现C语言标准库字符串函数" class="headerlink" title="完整源代码：复现C语言标准库字符串函数"></a>完整源代码：复现C语言标准库字符串函数</h2><p>以下是所有复现函数的完整实现，包含详细注释与测试用例，可直接复制编译运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdbool.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stddef.h&gt;  // 用于size_t类型</span></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">复现C语言中的库函数</span><br><span class="line">* 1.size_t my_strlen(const char *str);</span><br><span class="line">* 2.char *my_strcpy(char *dest, const char *src);</span><br><span class="line">* 3.char *my_strncpy(char *dest, const char *src, size_t n);</span><br><span class="line">* 4.char *my_strcat(char *dest, const char *src);</span><br><span class="line">* 5.char *my_strncat(char *dest, const char *src, size_t n);</span><br><span class="line">* 6.int my_strcmp(const char *str1, const char *str2);</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 1. 实现 strlen 求字符的长度</span><br><span class="line">size_t my_strlen(const char *p) &#123;</span><br><span class="line">    size_t count = 0;</span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="string">&#x27;\0&#x27;</span>) &#123;  // 遍历直到空终止符</span><br><span class="line">        count++;</span><br><span class="line">        p++;              // 移动到下一个字符</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 实现 strcpy 复制字符串的值</span><br><span class="line">char *my_strcpy(char *dest, const char *src) &#123;</span><br><span class="line">    char *tmp = dest;       // 保存目标起始地址</span><br><span class="line">    <span class="keyword">while</span> (*src != <span class="string">&#x27;\0&#x27;</span>) &#123;  // 复制直到源字符串结束</span><br><span class="line">        *dest++ = *src++;   // 逐个字符复制（后置++避免覆盖）</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = <span class="string">&#x27;\0&#x27;</span>;           // 手动添加空终止符</span><br><span class="line">    <span class="built_in">return</span> tmp;             // 返回目标起始地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3. 更安全的复制（带长度限制）</span><br><span class="line">char *my_strncpy(char *dest, const char *src, size_t n) &#123;</span><br><span class="line">    size_t i;</span><br><span class="line">    <span class="keyword">for</span> (i = 0; i &lt; n &amp;&amp; src[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        // 复制前n个有效字符</span><br><span class="line">        dest[i] = src[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n; i++) &#123;</span><br><span class="line">        // 填充剩余空间为\0</span><br><span class="line">        dest[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4. 实现 strcat 拼接字符串</span><br><span class="line">char *my_strcat(char *dest, const char *src) &#123;</span><br><span class="line">    char *tmp = dest;</span><br><span class="line">    // 保存目标起始地址</span><br><span class="line">    <span class="keyword">while</span> (*dest != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        // 找到dest的末尾（空终止符位置）</span><br><span class="line">        dest++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((*dest++ = *src++) != &#x27;\<span class="number">0</span>&#x27;);</span><br><span class="line">    // 复制src到dest末尾</span><br><span class="line">    *dest = &#x27;\<span class="number">0</span>&#x27;;</span><br><span class="line">    // 手动添加空终止符（防止src未终止导致dest越界）</span><br><span class="line">    return tmp;</span><br><span class="line">    // 返回目标起始地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// <span class="number">5</span>. 实现 strncat 安全拼接（限制长度）</span><br><span class="line">char *my_strncat(char *dest, const char *src, size_t n) &#123;</span><br><span class="line">    char *tmp = dest;       // 保存目标起始地址</span><br><span class="line">    while (*dest != &#x27;\<span class="number">0</span>&#x27;) &#123; // 找到dest的末尾</span><br><span class="line">        dest++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (size_t i = <span class="number">0</span>; i &lt; n &amp;&amp; *src != &#x27;\<span class="number">0</span>&#x27;; i++) &#123;  // 复制前n个字符（或源提前结束）</span><br><span class="line">        *dest++ = *src++;</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = &#x27;\<span class="number">0</span>&#x27;;           // 手动添加空终止符</span><br><span class="line">    return tmp;             // 返回目标起始地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// <span class="number">6</span>. 实现 strcmp 比较字符串大小</span><br><span class="line">int my_strcmp(const char *str1, const char *str2) &#123;</span><br><span class="line">    while (*str1 &amp;&amp; *str2 &amp;&amp; *str1 == *str2) &#123;  // 字符相同且未结束则继续</span><br><span class="line">        str1++;</span><br><span class="line">        str2++;</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回差值（转换为unsigned char避免符号扩展问题）</span><br><span class="line">    return *(unsigned char *)str1 - *(unsigned char *)str2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主函数：测试所有复现函数</span><br><span class="line">int main(void) &#123;</span><br><span class="line">    char p[<span class="number">30</span>] = &quot;<span class="number">122345</span>&quot;;  // 可修改的数组（初始长度<span class="number">6</span>）</span><br><span class="line">    char q[] = &quot;<span class="number">12234</span>&quot;;     // 自动推导长度（<span class="number">5</span>+<span class="number">1</span>=<span class="number">6</span>）</span><br><span class="line">    char a[] = &quot;<span class="number">128757</span>&quot;;    // 自动推导长度（<span class="number">6</span>+<span class="number">1</span>=<span class="number">7</span>）</span><br><span class="line"></span><br><span class="line">    // 测试 my_strcmp（比较a和q）</span><br><span class="line">    printf(&quot;my_strcmp(a, q) = %d\n&quot;, my_strcmp(a, q));  // 输出正数（<span class="string">&quot;128757&quot;</span> &gt; <span class="string">&quot;12234&quot;</span>）</span><br><span class="line"></span><br><span class="line">    // 测试 my_strlen（计算p的长度）</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my_strlen(p) = %zu\n&quot;</span>, my_strlen(p));  // 输出6（字符<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>）</span><br><span class="line"></span><br><span class="line">    // 测试 my_strcpy（将q复制到p）</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my_strcpy(p, q) = %s\n&quot;</span>, my_strcpy(p, q));  // 输出<span class="string">&quot;12234&quot;</span>（p被覆盖为q的内容）</span><br><span class="line"></span><br><span class="line">    // 测试 my_strcmp（比较修改后的p和q）</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my_strcmp(p, q) = %d\n&quot;</span>, my_strcmp(p, q));  // 输出0（两者内容相同）</span><br><span class="line"></span><br><span class="line">    // 测试 my_strncpy（将a的前4个字符复制到p）</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my_strncpy(p, a, 4) = %s\n&quot;</span>, my_strncpy(p, a, 4));  // 输出<span class="string">&quot;1287&quot;</span>（p前4位被覆盖）</span><br><span class="line"></span><br><span class="line">    // 测试 my_strcat（将a拼接至p末尾）</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my_strcat(p, a) = %s\n&quot;</span>, my_strcat(p, a));  // 输出<span class="string">&quot;1287128757&quot;</span>（p末尾追加a的内容）</span><br><span class="line"></span><br><span class="line">    // 测试 my_strncat（将a的前4个字符拼接至p末尾）</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my_strncat(p, a, 4) = %s\n&quot;</span>, my_strncat(p, a, 4));  // 输出<span class="string">&quot;128712871287&quot;</span>（p末尾追加前4个字符）</span><br><span class="line"></span><br><span class="line">    // 测试 my_strcpy（再次将q复制到p）</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my_strcpy(p, q) = %s\n&quot;</span>, my_strcpy(p, q));  // 输出<span class="string">&quot;12234&quot;</span>（p被覆盖为q的内容）</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODE</category>
      </categories>
      <tags>
        <tag>CODE</tag>
        <tag>C语言</tag>
        <tag>安全编码</tag>
      </tags>
  </entry>
  <entry>
    <title>主题修改记录</title>
    <url>/posts/1db0a89f/</url>
    <content><![CDATA[<h1 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h1><h2 id="source-css"><a href="#source-css" class="headerlink" title="source\css"></a>source\css</h2><p>修改 <code>_config.butterfly.yml</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff</span><br><span class="line">beautify:</span><br><span class="line">  enable: true</span><br><span class="line">  field: post # site/post</span><br><span class="line">- title-prefix-icon: # &#x27;\f0c1&#x27;</span><br><span class="line">- title-prefix-icon-color: # &#x27;#F47466&#x27;</span><br><span class="line">+ title-prefix-icon: &#x27;\f863&#x27;</span><br><span class="line">+ title-prefix-icon-color: &quot;#F47466&quot;</span><br></pre></td></tr></table></figure>
<h2 id="修改自定义-CSS-文件"><a href="#修改自定义-CSS-文件" class="headerlink" title="修改自定义 CSS 文件"></a>修改自定义 CSS 文件</h2><p>以下 CSS 样式可添加进任何已引入的.css 文件中<br>例如，在 [Blogroot]\source\css\custom.css（可以自己新建一个放在inject里） 下添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 文章页H1-H6图标样式效果 */</span><br><span class="line">h1::before,</span><br><span class="line">h2::before,</span><br><span class="line">h3::before,</span><br><span class="line">h4::before,</span><br><span class="line">h5::before,</span><br><span class="line">h6::before &#123;</span><br><span class="line">  -webkit-animation: ccc 1.6s linear infinite;</span><br><span class="line">  animation: ccc 1.6s linear infinite;</span><br><span class="line">&#125;</span><br><span class="line">@-webkit-keyframes ccc &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    -webkit-transform: rotate(0deg);</span><br><span class="line">    transform: rotate(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  to &#123;</span><br><span class="line">    -webkit-transform: rotate(-1turn);</span><br><span class="line">    transform: rotate(-1turn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes ccc &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    -webkit-transform: rotate(0deg);</span><br><span class="line">    transform: rotate(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  to &#123;</span><br><span class="line">    -webkit-transform: rotate(-1turn);</span><br><span class="line">    transform: rotate(-1turn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#content-inner.layout h1::before &#123;</span><br><span class="line">    color: #ef50a8;</span><br><span class="line">    margin-left: -1.55rem;</span><br><span class="line">    font-size: 1.3rem;</span><br><span class="line">    margin-top: -0.23rem;</span><br><span class="line">  &#125;</span><br><span class="line">  #content-inner.layout h2::before &#123;</span><br><span class="line">    color: #fb7061;</span><br><span class="line">    margin-left: -1.35rem;</span><br><span class="line">    font-size: 1.1rem;</span><br><span class="line">    margin-top: -0.12rem;</span><br><span class="line">  &#125;</span><br><span class="line">  #content-inner.layout h3::before &#123;</span><br><span class="line">    color: #ffbf00;</span><br><span class="line">    margin-left: -1.22rem;</span><br><span class="line">    font-size: 0.95rem;</span><br><span class="line">    margin-top: -0.09rem;</span><br><span class="line">  &#125;</span><br><span class="line">  #content-inner.layout h4::before &#123;</span><br><span class="line">    color: #a9e000;</span><br><span class="line">    margin-left: -1.05rem;</span><br><span class="line">    font-size: 0.8rem;</span><br><span class="line">    margin-top: -0.09rem;</span><br><span class="line">  &#125;</span><br><span class="line">  #content-inner.layout h5::before &#123;</span><br><span class="line">    color: #57c850;</span><br><span class="line">    margin-left: -0.9rem;</span><br><span class="line">    font-size: 0.7rem;</span><br><span class="line">    margin-top: 0rem;</span><br><span class="line">  &#125;</span><br><span class="line">  #content-inner.layout h6::before &#123;</span><br><span class="line">    color: #5ec1e0;</span><br><span class="line">    margin-left: -0.9rem;</span><br><span class="line">    font-size: 0.66rem;</span><br><span class="line">    margin-top: 0rem;</span><br><span class="line">  &#125;</span><br><span class="line">  #content-inner.layout h1:hover, /*本站已删除此行代码*/</span><br><span class="line">  #content-inner.layout h2:hover,</span><br><span class="line">  #content-inner.layout h3:hover,</span><br><span class="line">  #content-inner.layout h4:hover,</span><br><span class="line">  #content-inner.layout h5:hover,</span><br><span class="line">  #content-inner.layout h6:hover &#123;</span><br><span class="line">    color: rgb(90,135,255);</span><br><span class="line">  &#125;</span><br><span class="line">  #content-inner.layout h1:hover::before,</span><br><span class="line">  #content-inner.layout h2:hover::before,</span><br><span class="line">  #content-inner.layout h3:hover::before,</span><br><span class="line">  #content-inner.layout h4:hover::before,</span><br><span class="line">  #content-inner.layout h5:hover::before,</span><br><span class="line">  #content-inner.layout h6:hover::before &#123;</span><br><span class="line">    color: rgb(90,135,255);</span><br><span class="line">    -webkit-animation: ccc 3.2s linear infinite;</span><br><span class="line">    animation: ccc 3.2s linear infinite;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">/* 页面设置icon转动速度调整 */</span><br><span class="line">#rightside_config i.fas.fa-cog.fa-spin &#123;</span><br><span class="line">    animation: fa-spin 5s linear infinite;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="页码按钮"><a href="#页码按钮" class="headerlink" title="页码按钮"></a>页码按钮</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">css</span><br><span class="line">/*页码按钮美化*/</span><br><span class="line">.layout&gt;.recent-posts .pagination&gt; &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  margin: 0 6px;</span><br><span class="line">  width: 2.5em;</span><br><span class="line">  height: 2.5em;</span><br><span class="line">  line-height: 2.5em;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*页码按钮圆角*/</span><br><span class="line">#pagination .page-number.current &#123;</span><br><span class="line">    border-radius: 7px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文章卡片"><a href="#文章卡片" class="headerlink" title="文章卡片"></a>文章卡片</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">css</span><br><span class="line">/*文章卡片圆角*/</span><br><span class="line">.layout &gt; div:first-child:not(.recent-posts) &#123;</span><br><span class="line">  border-radius: 35px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="目录卡片"><a href="#目录卡片" class="headerlink" title="目录卡片"></a>目录卡片</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">css</span><br><span class="line">/*目录卡片圆角*/</span><br><span class="line">#aside-content .card-widget &#123;</span><br><span class="line">  border-radius: 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="首页文章"><a href="#首页文章" class="headerlink" title="首页文章"></a>首页文章</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">css</span><br><span class="line">/*首页文章圆角*/</span><br><span class="line">.layout &gt; .recent-posts &gt; .recent-post-item &#123;</span><br><span class="line">    border-radius: 20px !important</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">css</span><br><span class="line">/*图片圆角*/</span><br><span class="line">#article-container img &#123;</span><br><span class="line">  border-radius: 15px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码块文字居中"><a href="#代码块文字居中" class="headerlink" title="代码块文字居中"></a>代码块文字居中</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#article-container figure.highlight .highlight-tools .code-lang &#123;</span><br><span class="line">  left: 50%!important;</span><br><span class="line">  transform: translateX(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>主题美化</category>
      </categories>
      <tags>
        <tag>主题美化</tag>
      </tags>
  </entry>
  <entry>
    <title>007.Vector</title>
    <url>/posts/18c2def7/</url>
    <content><![CDATA[<hr>
<h2 id="引言：为什么需要动态数组？"><a href="#引言：为什么需要动态数组？" class="headerlink" title="引言：为什么需要动态数组？"></a>引言：为什么需要动态数组？</h2><p>在C语言中，静态数组的大小在编译时确定，无法根据运行时需求动态调整。当数据量不确定或需要频繁插入&#x2F;删除元素时，静态数组会暴露出明显缺陷：要么浪费内存（声明过大），要么溢出（声明过小）。动态数组（Vector）通过<strong>堆内存分配</strong>和<strong>自动扩容</strong>机制，完美解决了这一问题。它支持灵活的元素插入、删除，且内存使用更高效，是实现栈、队列等高级数据结构的基础。</p>
<hr>
<h2 id="核心结构：Vector的设计哲学"><a href="#核心结构：Vector的设计哲学" class="headerlink" title="核心结构：Vector的设计哲学"></a>核心结构：Vector的设计哲学</h2><h3 id="结构体定义：封装底层细节"><a href="#结构体定义：封装底层细节" class="headerlink" title="结构体定义：封装底层细节"></a>结构体定义：封装底层细节</h3><p>代码中的<code>Vector</code>结构体通过三个字段封装了动态数组的核心状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    ElemType *table;   // 指向堆空间的数组（存储实际元素）</span><br><span class="line">    int  size;         // 当前元素个数（逻辑长度）</span><br><span class="line">    int  capacity;     // 数组的最大容量（物理长度）</span><br><span class="line">&#125; Vector;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>table</code>：指向堆内存的指针，存储实际的元素数据；</li>
<li><code>size</code>：当前已存储的元素数量（动态变化）；</li>
<li><code>capacity</code>：数组的总容量（静态限制，需扩容时调整）。</li>
</ul>
<h3 id="类型别名：提升可维护性"><a href="#类型别名：提升可维护性" class="headerlink" title="类型别名：提升可维护性"></a>类型别名：提升可维护性</h3><p>通过<code>typedef int ElemType</code>定义元素类型别名，未来若需修改元素类型（如改为<code>float</code>或自定义结构体），只需调整<code>ElemType</code>的定义即可，无需修改整个代码库。这种设计模拟了C++的泛型思想，提升了代码的可扩展性。</p>
<hr>
<h2 id="关键函数解析：从初始化到销毁"><a href="#关键函数解析：从初始化到销毁" class="headerlink" title="关键函数解析：从初始化到销毁"></a>关键函数解析：从初始化到销毁</h2><h3 id="1-create-Vector：初始化动态数组"><a href="#1-create-Vector：初始化动态数组" class="headerlink" title="1. create_Vector：初始化动态数组"></a>1. <code>create_Vector</code>：初始化动态数组</h3><p>初始化函数的核心是<strong>分配堆内存</strong>并设置初始状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vector *create_Vector() &#123;</span><br><span class="line">    Vector *vec = (Vector *)malloc(sizeof(Vector));  // 分配结构体内存</span><br><span class="line">    if (vec == NULL) &#123; /* 内存分配失败处理 */ &#125;</span><br><span class="line"></span><br><span class="line">    vec-&gt;table = malloc(DEFAULT_CAPACITY * sizeof(ElemType));  // 分配元素存储空间</span><br><span class="line">    if (vec-&gt;table == NULL) &#123; /* 释放结构体并报错 */ &#125;</span><br><span class="line"></span><br><span class="line">    vec-&gt;size = 0;       // 初始无元素</span><br><span class="line">    vec-&gt;capacity = DEFAULT_CAPACITY;  // 初始容量为默认值（10）</span><br><span class="line">    return vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>：</p>
<ul>
<li>使用<code>malloc</code>分配结构体和元素存储空间，需检查返回值避免空指针；</li>
<li>初始容量<code>DEFAULT_CAPACITY</code>设为10，平衡了内存利用率和扩容频率；</li>
<li>返回指向<code>Vector</code>结构体的指针，后续操作通过该指针访问动态数组。</li>
</ul>
<h3 id="2-vector-destroy：释放内存"><a href="#2-vector-destroy：释放内存" class="headerlink" title="2. vector_destroy：释放内存"></a>2. <code>vector_destroy</code>：释放内存</h3><p>销毁函数负责<strong>释放堆内存</strong>，避免内存泄漏：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void vector_destroy(Vector *v) &#123;</span><br><span class="line">    free(v-&gt;table);  // 先释放元素存储空间</span><br><span class="line">    free(v);         // 再释放结构体本身</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：必须按顺序释放（先<code>table</code>后<code>v</code>），否则会导致结构体指针失效，无法安全释放<code>table</code>。</p>
<h3 id="3-vector-resize：动态扩容"><a href="#3-vector-resize：动态扩容" class="headerlink" title="3. vector_resize：动态扩容"></a>3. <code>vector_resize</code>：动态扩容</h3><p>当元素数量达到容量时（<code>size == capacity</code>），需调用<code>vector_resize</code>扩容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void vector_resize(Vector *v) &#123;</span><br><span class="line">    ElemType *p2 = realloc(v-&gt;table, v-&gt;capacity * 2 * sizeof(ElemType));  // 扩容为2倍</span><br><span class="line">    if (p2 == NULL) &#123; /* 扩容失败处理 */ &#125;</span><br><span class="line">    v-&gt;table = p2;       // 更新指针</span><br><span class="line">    v-&gt;capacity *= 2;    // 容量翻倍</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设计思想</strong>：</p>
<ul>
<li>采用<strong>二倍递增</strong>策略（每次扩容为原容量的2倍），保证插入操作的均摊时间复杂度为O(1)；</li>
<li><code>realloc</code>会尝试在原内存位置扩展，若失败则分配新内存并复制数据，避免频繁内存分配的开销；</li>
<li><code>static</code>修饰符确保该函数仅在当前文件可见，隐藏实现细节（封装性）。</li>
</ul>
<hr>
<h2 id="核心操作：插入与打印"><a href="#核心操作：插入与打印" class="headerlink" title="核心操作：插入与打印"></a>核心操作：插入与打印</h2><h3 id="1-vector-push-back：尾部插入"><a href="#1-vector-push-back：尾部插入" class="headerlink" title="1. vector_push_back：尾部插入"></a>1. <code>vector_push_back</code>：尾部插入</h3><p>尾部插入是最常用的操作，直接在<code>size</code>位置添加元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void vector_push_back(Vector *v, ElemType element) &#123;</span><br><span class="line">    if (v-&gt;size == v-&gt;capacity) vector_resize(v);  // 扩容检查</span><br><span class="line">    v-&gt;table[v-&gt;size] = element;  // 在size位置写入元素</span><br><span class="line">    v-&gt;size++;                    // 元素数量+1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>时间复杂度O(1)（均摊，因扩容概率低）；</li>
<li>无需移动现有元素，效率最高。</li>
</ul>
<h3 id="2-vector-push-front：头部插入"><a href="#2-vector-push-front：头部插入" class="headerlink" title="2. vector_push_front：头部插入"></a>2. <code>vector_push_front</code>：头部插入</h3><p>头部插入需要将所有现有元素后移一位，为新元素腾出空间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void vector_push_front(Vector *v, ElemType val) &#123;</span><br><span class="line">    if (v-&gt;size == v-&gt;capacity) vector_resize(v);  // 扩容检查</span><br><span class="line">    for (int i = v-&gt;size; i &gt; 0; i--) &#123;  // 元素后移</span><br><span class="line">        v-&gt;table[i] = v-&gt;table[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    v-&gt;table[0] = val;  // 在头部写入元素</span><br><span class="line">    v-&gt;size++;           // 元素数量+1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>时间复杂度O(n)（n为当前元素数量），因需移动所有元素；</li>
<li>适用于需要频繁在头部操作的场景（如队列的头部插入）。</li>
</ul>
<h3 id="3-vector-insert：中间插入"><a href="#3-vector-insert：中间插入" class="headerlink" title="3. vector_insert：中间插入"></a>3. <code>vector_insert</code>：中间插入</h3><p>中间插入需将指定位置后的元素后移，为新元素腾出空间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void vector_insert(Vector *v, int idx, ElemType val) &#123;</span><br><span class="line">    if (v-&gt;size == v-&gt;capacity) vector_resize(v);  // 扩容检查</span><br><span class="line">    for (int i = v-&gt;size; i &gt; idx; i--) &#123;  // 元素后移（从idx到末尾）</span><br><span class="line">        v-&gt;table[i] = v-&gt;table[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    v-&gt;table[idx] = val;  // 在idx位置写入元素</span><br><span class="line">    v-&gt;size++;            // 元素数量+1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>时间复杂度O(n)（n为当前元素数量），因需移动<code>size - idx</code>个元素；</li>
<li><code>idx</code>需满足<code>0 ≤ idx ≤ size</code>（若<code>idx &gt; size</code>则越界，需额外检查）。</li>
</ul>
<h3 id="4-vector-print：遍历打印"><a href="#4-vector-print：遍历打印" class="headerlink" title="4. vector_print：遍历打印"></a>4. <code>vector_print</code>：遍历打印</h3><p>打印函数遍历<code>table</code>数组，输出所有有效元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void vector_print(Vector *v) &#123;</span><br><span class="line">    for (int i = 0; i &lt; v-&gt;size; i++) &#123;</span><br><span class="line">        printf(&quot;%d\t&quot;, v-&gt;table[i]);  // 输出元素值（假设ElemType为int）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>扩展</strong>：若<code>ElemType</code>为其他类型（如字符串），需修改打印逻辑（如使用<code>%s</code>格式符）。</p>
<hr>
<h2 id="主函数测试：验证功能正确性"><a href="#主函数测试：验证功能正确性" class="headerlink" title="主函数测试：验证功能正确性"></a>主函数测试：验证功能正确性</h2><p>用户提供的主函数测试了尾部插入、头部插入、中间插入和打印功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main(void) &#123;</span><br><span class="line">    Vector *vec = create_Vector();</span><br><span class="line"></span><br><span class="line">    // 测试尾部插入（1-15）</span><br><span class="line">    printf(&quot;尾部插入 1-15...\n&quot;);</span><br><span class="line">    for (int i = 1; i &lt;= 15; i++) &#123;</span><br><span class="line">        vector_push_back(vec, i);</span><br><span class="line">    &#125;</span><br><span class="line">    vector_print(vec);</span><br><span class="line"></span><br><span class="line">    // 测试头部插入（0）</span><br><span class="line">    printf(&quot;\n头部插入element 0...\n&quot;);</span><br><span class="line">    vector_push_front(vec, 0);</span><br><span class="line">    vector_print(vec);</span><br><span class="line"></span><br><span class="line">    // 测试中间插入（100 at index 3）</span><br><span class="line">    printf(&quot;\n特定位置插入 100 at index 3...\n&quot;);</span><br><span class="line">    vector_insert(vec, 3, 100);</span><br><span class="line">    vector_print(vec);</span><br><span class="line"></span><br><span class="line">    vector_destroy(vec);  // 释放内存</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>预期输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">尾部插入 1-5...</span><br><span class="line">1       2       3       4       5       ...       15</span><br><span class="line"></span><br><span class="line">头部插入element 0...</span><br><span class="line">0       1       2       3       4       ...       15</span><br><span class="line"></span><br><span class="line">特定位置插入 100 at index 3...</span><br><span class="line">0       1       2       100     3       4       ...       15</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="潜在问题与改进建议"><a href="#潜在问题与改进建议" class="headerlink" title="潜在问题与改进建议"></a>潜在问题与改进建议</h2><h3 id="问题1：内存泄漏风险"><a href="#问题1：内存泄漏风险" class="headerlink" title="问题1：内存泄漏风险"></a>问题1：内存泄漏风险</h3><p>当前代码中，若<code>vector_destroy</code>未被调用（如程序异常退出），<code>table</code>和<code>v</code>的内存将无法释放。建议：</p>
<ul>
<li>在主函数中使用<code>atexit</code>注册销毁函数，确保程序退出时自动释放；</li>
<li>或使用智能指针（需结合C++，但C语言可通过自定义管理逻辑模拟）。</li>
</ul>
<h3 id="问题2：错误处理不完善"><a href="#问题2：错误处理不完善" class="headerlink" title="问题2：错误处理不完善"></a>问题2：错误处理不完善</h3><p><code>create_Vector</code>和<code>vector_resize</code>中仅输出错误信息，未向上传递错误状态。建议：</p>
<ul>
<li>修改函数返回值为<code>bool</code>或错误码（如<code>-1</code>表示失败）；</li>
<li>调用者根据返回值决定是否继续执行（如<code>if (!create_Vector()) &#123; /* 处理错误 */ &#125;</code>）。</li>
</ul>
<h3 id="问题3：插入操作的边界检查缺失"><a href="#问题3：插入操作的边界检查缺失" class="headerlink" title="问题3：插入操作的边界检查缺失"></a>问题3：插入操作的边界检查缺失</h3><p><code>vector_insert</code>未检查<code>idx</code>是否越界（如<code>idx &lt; 0</code>或<code>idx &gt; size</code>）。建议添加边界检查：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void vector_insert(Vector *v, int idx, ElemType val) &#123;</span><br><span class="line">    if (idx &lt; 0 || idx &gt; v-&gt;size) &#123;  // 允许idx等于size（插入到末尾）</span><br><span class="line">        printf(&quot;Invalid index: %d\n&quot;, idx);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题4：扩容策略可优化"><a href="#问题4：扩容策略可优化" class="headerlink" title="问题4：扩容策略可优化"></a>问题4：扩容策略可优化</h3><p>当前扩容策略为二倍递增，适用于大多数场景，但在元素数量较少时可能导致内存浪费。建议：</p>
<ul>
<li>对于小容量数组（如<code>size &lt; 100</code>），采用1.5倍扩容；</li>
<li>对于大容量数组，保持二倍扩容以降低内存碎片。</li>
</ul>
<hr>
<h2 id="总结：动态数组的价值与应用场景"><a href="#总结：动态数组的价值与应用场景" class="headerlink" title="总结：动态数组的价值与应用场景"></a>总结：动态数组的价值与应用场景</h2><p>动态数组（Vector）通过堆内存分配和自动扩容机制，提供了比静态数组更灵活的操作能力。它适用于以下场景：</p>
<ul>
<li>数据量不确定（如用户输入的动态数据）；</li>
<li>需要频繁在尾部&#x2F;头部&#x2F;中间插入元素（如日志记录、任务队列）；</li>
<li>对内存利用率要求较高（避免静态数组的空间浪费）。</li>
</ul>
<p>通过本文的解析，我们不仅掌握了Vector的核心实现逻辑，更理解了动态内存管理的关键细节（如<code>malloc</code>&#x2F;<code>realloc</code>&#x2F;<code>free</code>的使用）。在实际开发中，可根据需求扩展Vector的功能（如删除元素、查找元素、排序等），或结合其他数据结构（如链表）优化性能。</p>
<hr>
<h2 id="完整源代码"><a href="#完整源代码" class="headerlink" title="完整源代码"></a>完整源代码</h2><h3 id="头文件-Vector-h"><a href="#头文件-Vector-h" class="headerlink" title="头文件 Vector.h"></a>头文件 Vector.h</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef VECTOR_H</span><br><span class="line">#define VECTOR_H</span><br><span class="line">#define DEFAULT_CAPACITY 10</span><br><span class="line">typedef int ElemType;  // 元素类型别名，可修改为其他类型</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    ElemType *table;   // 存储元素的堆内存指针</span><br><span class="line">    int  size;         // 当前元素个数</span><br><span class="line">    int  capacity;     // 数组总容量</span><br><span class="line">&#125; Vector;</span><br><span class="line"></span><br><span class="line">// 函数声明</span><br><span class="line">Vector *create_Vector(void);</span><br><span class="line">void vector_destroy(Vector *v);</span><br><span class="line">void vector_push_back(Vector *v, ElemType val);</span><br><span class="line">void vector_push_front(Vector *v, ElemType val);</span><br><span class="line">void vector_insert(Vector *v, int idx, ElemType val);</span><br><span class="line">void vector_print(Vector *v);</span><br><span class="line"></span><br><span class="line">#endif // !VECTOR_H</span><br></pre></td></tr></table></figure>

<h3 id="源文件-main-c"><a href="#源文件-main-c" class="headerlink" title="源文件 main.c"></a>源文件 main.c</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;Vector.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">	Vector *vec = create_Vector();</span><br><span class="line">	// 测试尾部插入功能</span><br><span class="line">	printf(&quot;尾部插入 1-5...\n&quot;);</span><br><span class="line">	for (int i = 1; i &lt;= 15; i++) &#123;</span><br><span class="line">		vector_push_back(vec, i);</span><br><span class="line">	&#125;</span><br><span class="line">	vector_print(vec);</span><br><span class="line">	// 测试头部插入功能</span><br><span class="line">	printf(&quot;\n头部插入element 0...\n&quot;);</span><br><span class="line">	vector_push_front(vec, 0);</span><br><span class="line">	vector_print(vec);</span><br><span class="line">	// 测试中间插入功能</span><br><span class="line">	printf(&quot;\n特定位置插入 100 at index 3...\n&quot;);</span><br><span class="line">	vector_insert(vec, 3, 100);</span><br><span class="line">	vector_print(vec);</span><br><span class="line">	// 销毁Vector，释放内存</span><br><span class="line">	vector_destroy(vec);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="源文件-Vector-c"><a href="#源文件-Vector-c" class="headerlink" title="源文件 Vector.c"></a>源文件 Vector.c</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;Vector.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line"></span><br><span class="line">// 在C语言中,static修饰函数表示此函数仅在当前文件内部生效</span><br><span class="line">static void vector_resize(Vector *v) &#123;</span><br><span class="line">	ElemType *p2 = realloc(v-&gt;table, v-&gt;capacity * 2 * sizeof(ElemType));</span><br><span class="line">	//用到这个函数就代表需要扩容了，考虑二倍递增（此处应该有一个阈值，超过后改变递增倍数）</span><br><span class="line">	if (p2 == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;ralloc failed in vector_resize vec-&gt;table &quot;);</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	//判断realloc是否成功</span><br><span class="line">	v-&gt;table = p2;</span><br><span class="line">	v-&gt;capacity *= 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 初始化一个Vector动态数组</span><br><span class="line">Vector *create_Vector() &#123;</span><br><span class="line">	Vector *vec = (Vector *)malloc(sizeof(Vector));</span><br><span class="line">	if (vec == NULL) &#123;</span><br><span class="line">		printf(&quot;malloc failed in create_Vector&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	//申请内存</span><br><span class="line">	vec-&gt;table = malloc(DEFAULT_CAPACITY * sizeof(ElemType));//10*ElemType 大小尺寸的数组 DEFAULT_CAPACITY 宏定义</span><br><span class="line">	if (vec-&gt;table == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;malloc failed in create_Vector vec-&gt;table &quot;);</span><br><span class="line">		free(vec);</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	vec-&gt;size = 0;       // 初始无元素</span><br><span class="line">	vec-&gt;capacity = DEFAULT_CAPACITY;</span><br><span class="line">	return vec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 销毁一个Vector动态数组，释放内存。这实际上模拟了C++的析构函数</span><br><span class="line">void vector_destroy(Vector *v)</span><br><span class="line">&#123;</span><br><span class="line">	free(v-&gt;table);//先释放</span><br><span class="line">	free(v);//后释放</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 向动态数组末尾添加一个元素</span><br><span class="line">void vector_push_back(Vector *v, ElemType element)</span><br><span class="line">&#123;</span><br><span class="line">	if (v-&gt;size == v-&gt;capacity) &#123;</span><br><span class="line">		vector_resize(v);</span><br><span class="line">	&#125;//判断是否需要扩容</span><br><span class="line">	v-&gt;table[v-&gt;size] = element;</span><br><span class="line">	v-&gt;size++;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在动态数组最前面添加元素，所有元素依次后移</span><br><span class="line">void vector_push_front(Vector *v, ElemType val)</span><br><span class="line">&#123;</span><br><span class="line">	if (v-&gt;size == v-&gt;capacity) &#123;</span><br><span class="line">		vector_resize(v);</span><br><span class="line">	&#125;//判断是否需要扩容</span><br><span class="line">	for (int i = v-&gt;size; i &gt; 0; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		v-&gt;table[i] = v-&gt;table[i - 1];</span><br><span class="line">	&#125;</span><br><span class="line">	v-&gt;table[0] = val;</span><br><span class="line">	v-&gt;size++;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将元素val添加到索引为idx的位置，idx后面的元素依次后移</span><br><span class="line">void vector_insert(Vector *v, int idx, ElemType val)</span><br><span class="line">&#123;</span><br><span class="line">	if (v-&gt;size == v-&gt;capacity) &#123;</span><br><span class="line">		vector_resize(v);</span><br><span class="line">	&#125;//判断是否需要扩容</span><br><span class="line"></span><br><span class="line">	for (int i = v-&gt;size; i &gt; idx; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		v-&gt;table[i] = v-&gt;table[i - 1];</span><br><span class="line">	&#125;</span><br><span class="line">	v-&gt;table[idx] = val;</span><br><span class="line">	v-&gt;size++;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历打印整个Vector动态数组</span><br><span class="line">void vector_print(Vector *v)</span><br><span class="line">&#123;</span><br><span class="line">	for (int i = 0; i &lt; v-&gt;size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d\t&quot;, v-&gt;table[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>数据结构</tag>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言实现汉诺塔问题：从递归逻辑到代码解析</title>
    <url>/posts/32b00d45/</url>
    <content><![CDATA[<hr>
<h2 id="引言：为什么需要学习汉诺塔？"><a href="#引言：为什么需要学习汉诺塔？" class="headerlink" title="引言：为什么需要学习汉诺塔？"></a>引言：为什么需要学习汉诺塔？</h2><p>汉诺塔（Hanoi Tower）是计算机科学中最经典的递归问题之一，由法国数学家爱德华·卢卡斯于1883年提出。它不仅是理解递归思想的绝佳案例，更是培养算法思维的基础。本文将通过C语言实现汉诺塔问题的递归解法，详细解析其核心逻辑，并探讨如何通过代码验证和优化提升程序的健壮性。</p>
<hr>
<h2 id="问题背景：汉诺塔的规则与目标"><a href="#问题背景：汉诺塔的规则与目标" class="headerlink" title="问题背景：汉诺塔的规则与目标"></a>问题背景：汉诺塔的规则与目标</h2><p>汉诺塔问题描述如下：<br> 假设有3根柱子（起始塔<code>A</code>、辅助塔<code>B</code>、目标塔<code>C</code>），初始时<code>A</code>塔上有<code>n</code>个盘子，按大小顺序从上到下叠放（大盘子在下，小盘子在上）。目标是将所有盘子从<code>A</code>塔移动到<code>C</code>塔，移动过程中需遵守以下规则：</p>
<ol>
<li>每次只能移动一个盘子；</li>
<li>大盘子不能直接放在小盘子上（即任何时刻，小盘子必须在大盘子之上）。</li>
</ol>
<p><strong>最少移动步数</strong>：对于<code>n</code>个盘子，最少需要<code>2^n - 1</code>步（数学归纳法可证）。</p>
<hr>
<h2 id="代码核心：递归解法的逻辑拆解"><a href="#代码核心：递归解法的逻辑拆解" class="headerlink" title="代码核心：递归解法的逻辑拆解"></a>代码核心：递归解法的逻辑拆解</h2><p>代码通过递归函数<code>move</code>实现了汉诺塔的移动步骤输出，并计算了最少步数。以下是代码的核心部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 递归函数：将n个盘子从start塔移动到target塔，sup为辅助塔</span><br><span class="line">void move(int n, char start, char sup, char target) &#123;</span><br><span class="line">    // 递归出口：仅1个盘子时，直接移动</span><br><span class="line">    if (n == 1) &#123;</span><br><span class="line">        printf(&quot;%c --&gt; %c\n&quot;, start, target);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 第一步：将n-1个盘子从start移动到sup（target作为辅助）</span><br><span class="line">    move(n - 1, start, target, sup);</span><br><span class="line"></span><br><span class="line">    // 第二步：将最大的盘子从start移动到target（直接打印）</span><br><span class="line">    printf(&quot;%c --&gt; %c\n&quot;, start, target);</span><br><span class="line"></span><br><span class="line">    // 第三步：将n-1个盘子从sup移动到target（start作为辅助）</span><br><span class="line">    move(n - 1, sup, start, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = 5;</span><br><span class="line">    long long steps = (1LL &lt;&lt; n) - 1;  // 计算最少步数：2^n - 1</span><br><span class="line">    printf(&quot;完成%d个盘子的汉诺塔问题，最少需要%lld步，全部移动轨迹如下：\n&quot;, n, steps);</span><br><span class="line"></span><br><span class="line">    move(n, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;);  // 调用递归函数输出移动步骤</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="代码逐行解析：递归逻辑的具象化"><a href="#代码逐行解析：递归逻辑的具象化" class="headerlink" title="代码逐行解析：递归逻辑的具象化"></a>代码逐行解析：递归逻辑的具象化</h2><h3 id="1-move函数的参数与递归出口"><a href="#1-move函数的参数与递归出口" class="headerlink" title="1. move函数的参数与递归出口"></a>1. <code>move</code>函数的参数与递归出口</h3><p>函数定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void move(int n, char start, char sup, char target)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>n</code>：当前需要移动的盘子数量；</li>
<li><code>start</code>：起始塔（当前待移动的盘子所在塔）；</li>
<li><code>sup</code>：辅助塔（用于临时存放盘子）；</li>
<li><code>target</code>：目标塔（最终需要将盘子移动到的塔）。</li>
</ul>
<p><strong>递归出口</strong>（终止条件）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (n == 1) &#123;</span><br><span class="line">    printf(&quot;%c --&gt; %c\n&quot;, start, target);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>n=1</code>时，无需分解问题，直接将唯一的盘子从<code>start</code>塔移动到<code>target</code>塔，打印移动路径后返回。</p>
<h3 id="2-递归分解：三步移动策略"><a href="#2-递归分解：三步移动策略" class="headerlink" title="2. 递归分解：三步移动策略"></a>2. 递归分解：三步移动策略</h3><p>对于<code>n&gt;1</code>的情况，递归分解为三个步骤（以<code>n=3</code>为例）：</p>
<h4 id="第一步：将n-1个盘子从start移动到sup"><a href="#第一步：将n-1个盘子从start移动到sup" class="headerlink" title="第一步：将n-1个盘子从start移动到sup"></a>第一步：将<code>n-1</code>个盘子从<code>start</code>移动到<code>sup</code></h4><p>调用<code>move(n-1, start, target, sup)</code>，此时：</p>
<ul>
<li>新的起始塔是原<code>start</code>；</li>
<li>新的目标塔是原<code>sup</code>（因为需要将<code>n-1</code>个盘子暂时存放在这里）；</li>
<li>新的辅助塔是原<code>target</code>（用于辅助移动<code>n-1</code>个盘子）。</li>
</ul>
<p><strong>效果</strong>：<code>n-1</code>个盘子从<code>start</code>塔移动到<code>sup</code>塔，原<code>target</code>塔作为空闲辅助。</p>
<h4 id="第二步：将最大的盘子从start移动到target"><a href="#第二步：将最大的盘子从start移动到target" class="headerlink" title="第二步：将最大的盘子从start移动到target"></a>第二步：将最大的盘子从<code>start</code>移动到<code>target</code></h4><p>此时，<code>start</code>塔上只剩最大的盘子（因为<code>n-1</code>个盘子已被移走），直接将其移动到<code>target</code>塔，并打印路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;%c --&gt; %c\n&quot;, start, target);</span><br></pre></td></tr></table></figure>

<p><strong>效果</strong>：最大的盘子到达目标塔<code>target</code>，<code>start</code>塔清空。</p>
<h4 id="第三步：将n-1个盘子从sup移动到target"><a href="#第三步：将n-1个盘子从sup移动到target" class="headerlink" title="第三步：将n-1个盘子从sup移动到target"></a>第三步：将<code>n-1</code>个盘子从<code>sup</code>移动到<code>target</code></h4><p>调用<code>move(n-1, sup, start, target)</code>，此时：</p>
<ul>
<li>新的起始塔是原<code>sup</code>（存放着<code>n-1</code>个盘子）；</li>
<li>新的目标塔是原<code>target</code>（已放置最大盘子，现在需要放置<code>n-1</code>个盘子）；</li>
<li>新的辅助塔是原<code>start</code>（已清空，用于辅助移动<code>n-1</code>个盘子）。</li>
</ul>
<p><strong>效果</strong>：<code>n-1</code>个盘子从<code>sup</code>塔移动到<code>target</code>塔，最终所有盘子到达目标塔。</p>
<hr>
<h2 id="主函数：参数设置与结果验证"><a href="#主函数：参数设置与结果验证" class="headerlink" title="主函数：参数设置与结果验证"></a>主函数：参数设置与结果验证</h2><h3 id="1-步数计算：2-n-1的数学依据"><a href="#1-步数计算：2-n-1的数学依据" class="headerlink" title="1. 步数计算：2^n - 1的数学依据"></a>1. 步数计算：<code>2^n - 1</code>的数学依据</h3><p>主函数中通过位运算计算总步数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long long steps = (1LL &lt;&lt; n) - 1;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>1LL &lt;&lt; n</code>表示将1左移<code>n</code>位（等价于<code>2^n</code>）；</li>
<li>减1后得到<code>2^n - 1</code>，即汉诺塔问题的最少移动步数（数学归纳法可证：当<code>n=1</code>时，步数为1；假设<code>n=k</code>时步数为<code>2^k - 1</code>，则<code>n=k+1</code>时步数为<code>2*(2^k - 1) + 1 = 2^(k+1) - 1</code>）。</li>
</ul>
<h3 id="2-调用move函数输出移动轨迹"><a href="#2-调用move函数输出移动轨迹" class="headerlink" title="2. 调用move函数输出移动轨迹"></a>2. 调用<code>move</code>函数输出移动轨迹</h3><p>通过<code>move(n, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;)</code>启动递归，输出从<code>A</code>塔到<code>C</code>塔的完整移动路径。</p>
<hr>
<h2 id="测试与验证：不同n值的输出效果"><a href="#测试与验证：不同n值的输出效果" class="headerlink" title="测试与验证：不同n值的输出效果"></a>测试与验证：不同<code>n</code>值的输出效果</h2><h3 id="测试1：n-1（最小情况）"><a href="#测试1：n-1（最小情况）" class="headerlink" title="测试1：n=1（最小情况）"></a>测试1：<code>n=1</code>（最小情况）</h3><p><strong>输入</strong>：<code>n=1</code><br> ​<strong>​预期输出​</strong>​：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">完成1个盘子的汉诺塔问题，最少需要1步，全部移动轨迹如下：</span><br><span class="line">A --&gt; C</span><br></pre></td></tr></table></figure>

<h3 id="测试2：n-2（基础情况）"><a href="#测试2：n-2（基础情况）" class="headerlink" title="测试2：n=2（基础情况）"></a>测试2：<code>n=2</code>（基础情况）</h3><p><strong>递归过程</strong>：</p>
<ol>
<li>将1个盘子从<code>A</code>移动到<code>B</code>（<code>move(1, &#39;A&#39;, &#39;C&#39;, &#39;B&#39;)</code>）；</li>
<li>将最大的盘子从<code>A</code>移动到<code>C</code>（打印<code>A --&gt; C</code>）；</li>
<li>将1个盘子从<code>B</code>移动到<code>C</code>（<code>move(1, &#39;B&#39;, &#39;A&#39;, &#39;C&#39;)</code>）。</li>
</ol>
<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">完成2个盘子的汉诺塔问题，最少需要3步，全部移动轨迹如下：</span><br><span class="line">A --&gt; B</span><br><span class="line">A --&gt; C</span><br><span class="line">B --&gt; C</span><br></pre></td></tr></table></figure>

<h3 id="测试3：n-3（验证递归分解）"><a href="#测试3：n-3（验证递归分解）" class="headerlink" title="测试3：n=3（验证递归分解）"></a>测试3：<code>n=3</code>（验证递归分解）</h3><p><strong>输出</strong>（部分步骤）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">完成3个盘子的汉诺塔问题，最少需要7步，全部移动轨迹如下：</span><br><span class="line">A --&gt; C		A --&gt; B		C --&gt; B		A --&gt; C</span><br><span class="line">B --&gt; A		B --&gt; C		A --&gt; C</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="潜在问题与改进建议"><a href="#潜在问题与改进建议" class="headerlink" title="潜在问题与改进建议"></a>潜在问题与改进建议</h2><h3 id="问题1：未处理非法输入（如n≤0）"><a href="#问题1：未处理非法输入（如n≤0）" class="headerlink" title="问题1：未处理非法输入（如n≤0）"></a>问题1：未处理非法输入（如<code>n≤0</code>）</h3><p>当前代码中<code>n</code>固定为5，若用户输入<code>n=0</code>或负数，<code>steps</code>会计算为<code>0</code>或负数，导致逻辑错误。</p>
<p><strong>改进建议</strong>：添加输入验证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    printf(&quot;请输入盘子数量（n≥1）：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    if (n &lt; 1) &#123;</span><br><span class="line">        printf(&quot;错误：盘子数量必须大于0！\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 后续代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题2：递归深度过大导致栈溢出"><a href="#问题2：递归深度过大导致栈溢出" class="headerlink" title="问题2：递归深度过大导致栈溢出"></a>问题2：递归深度过大导致栈溢出</h3><p>当<code>n</code>很大时（如<code>n=20</code>），递归调用次数为<code>2^20 - 1 ≈ 100万次</code>，可能超出栈空间限制，导致程序崩溃。</p>
<p><strong>改进建议</strong>：对于大<code>n</code>，可改用迭代法（如基于栈的模拟递归），或增加编译器栈空间（如GCC的<code>-Wl,--stack=268435456</code>选项）。</p>
<h3 id="问题3：输出格式可优化"><a href="#问题3：输出格式可优化" class="headerlink" title="问题3：输出格式可优化"></a>问题3：输出格式可优化</h3><p>当前输出仅打印移动路径，未明确标注每一步的盘子编号（如“移动第3个盘子”）。</p>
<p><strong>改进建议</strong>：在<code>printf</code>中添加盘子编号（需跟踪当前移动的盘子大小）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 修改move函数，增加当前移动的盘子大小参数</span><br><span class="line">void move(int n, char start, char sup, char target, int disk) &#123;</span><br><span class="line">    if (n == 1) &#123;</span><br><span class="line">        printf(&quot;移动盘子%d：%c --&gt; %c\n&quot;, disk, start, target);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    move(n - 1, start, target, sup, n);  // 移动n-1个盘子（最大的盘子是n）</span><br><span class="line">    printf(&quot;移动盘子%d：%c --&gt; %c\n&quot;, n, start, target);  // 移动最大的盘子</span><br><span class="line">    move(n - 1, sup, start, target, n);  // 移动n-1个盘子</span><br><span class="line">&#125;</span><br><span class="line">// 调用时传入当前最大的盘子编号（初始为n）</span><br><span class="line">move(n, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, n);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结：汉诺塔问题的核心价值"><a href="#总结：汉诺塔问题的核心价值" class="headerlink" title="总结：汉诺塔问题的核心价值"></a>总结：汉诺塔问题的核心价值</h2><p>汉诺塔问题不仅是递归算法的经典案例，更是理解分治思想（将大问题分解为子问题）的绝佳载体。通过本文的解析，我们掌握了：</p>
<ul>
<li>递归解法的核心逻辑（三步分解策略）；</li>
<li>最少步数的数学推导（<code>2^n - 1</code>）；</li>
<li>代码的测试与验证方法；</li>
<li>常见问题的改进方向（输入验证、栈溢出、输出优化）。</li>
</ul>
<p>这些经验对学习其他递归算法（如快速排序、归并排序）具有重要参考价值。实际开发中，可根据需求扩展功能（如记录移动时间、可视化动画），进一步提升对算法的理解。</p>
]]></content>
      <categories>
        <category>编程技术</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>汉诺塔</tag>
        <tag>递归算法</tag>
        <tag>经典问题</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言命令行参数处理</title>
    <url>/posts/58515f71/</url>
    <content><![CDATA[<h2 id="引言：为什么需要处理命令行参数？"><a href="#引言：为什么需要处理命令行参数？" class="headerlink" title="引言：为什么需要处理命令行参数？"></a>引言：为什么需要处理命令行参数？</h2><p>在开发命令行工具时，我们经常需要通过参数传递输入数据或配置选项。例如，一个计算器工具可能需要接收两个数值作为输入，一个文本处理工具可能需要指定输入文件路径。C语言中，<code>main</code>函数的<code>argc</code>和<code>argv</code>参数是处理命令行输入的核心接口。本文将通过一个具体案例，详细解析如何从命令行参数中读取数据、进行数值计算，并输出结果。</p>
<hr>
<h2 id="核心功能：命令行参数的读取与处理"><a href="#核心功能：命令行参数的读取与处理" class="headerlink" title="核心功能：命令行参数的读取与处理"></a>核心功能：命令行参数的读取与处理</h2><p>用户提供的代码实现了以下核心功能：</p>
<ol>
<li><strong>读取命令行参数数量</strong>（<code>argc</code>）并打印；</li>
<li><strong>遍历所有命令行参数</strong>（<code>argv</code>）并打印每个参数的内容；</li>
<li><strong>从指定参数中解析数值</strong>（整数<code>num1</code>和浮点数<code>num2</code>）；</li>
<li><strong>计算两数之和</strong>并格式化输出结果；</li>
<li><strong>使用第四个参数作为结果的描述字符串</strong>。</li>
</ol>
<hr>
<h2 id="代码逐行解析：从参数获取到结果输出"><a href="#代码逐行解析：从参数获取到结果输出" class="headerlink" title="代码逐行解析：从参数获取到结果输出"></a>代码逐行解析：从参数获取到结果输出</h2><h3 id="1-main函数参数：argc与argv"><a href="#1-main函数参数：argc与argv" class="headerlink" title="1. main函数参数：argc与argv"></a>1. <code>main</code>函数参数：<code>argc</code>与<code>argv</code></h3><p>C语言中，<code>main</code>函数的标准形式为<code>int main(int argc, char *argv[])</code>，其中：</p>
<ul>
<li><code>argc</code>（Argument Count）：命令行参数的数量（包含程序名本身）；</li>
<li><code>argv</code>（Argument Vector）：指向参数数组的指针，<code>argv[0]</code>是程序名，<code>argv[1]</code>是第一个用户参数，依此类推。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main(int argc, char *argv[]) &#123; </span><br><span class="line">// argc=参数数量，argv=参数数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-打印参数数量与内容"><a href="#2-打印参数数量与内容" class="headerlink" title="2. 打印参数数量与内容"></a>2. 打印参数数量与内容</h3><p>代码首先打印参数数量<code>argc</code>，然后通过循环遍历<code>argv</code>数组，打印每个参数的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;argument count = %d\n&quot;, argc);  // 输出参数总数（含程序名）</span><br><span class="line">for (int i = 0; i &lt; argc; i++) &#123;</span><br><span class="line">    printf(&quot;argv[%d]：%s\n&quot;, i, argv[i]);  // 输出每个参数的索引和内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例输出</strong>（假设程序名为<code>calc</code>，输入参数为<code>5 3.14 结果</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">argument count = 4</span><br><span class="line">argv[0]：calc</span><br><span class="line">argv[1]：5</span><br><span class="line">argv[2]：3.14</span><br><span class="line">argv[3]：结果</span><br></pre></td></tr></table></figure>

<h3 id="3-解析数值参数：sscanf的使用"><a href="#3-解析数值参数：sscanf的使用" class="headerlink" title="3. 解析数值参数：sscanf的使用"></a>3. 解析数值参数：<code>sscanf</code>的使用</h3><p>代码使用<code>sscanf</code>从<code>argv[1]</code>和<code>argv[2]</code>中解析整数和浮点数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sscanf(argv[1], &quot;%d&quot;, &amp;num1);       // 从argv[1]读取整数到num1</span><br><span class="line">sscanf(argv[2], &quot;%lf&quot;, &amp;num2);      // 从argv[2]读取浮点数到num2</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>：</p>
<ul>
<li><code>sscanf</code>的第一个参数是输入字符串（此处为命令行参数），第二个是格式控制符（<code>%d</code>匹配整数，<code>%lf</code>匹配双精度浮点数），第三个是存储结果的变量地址；</li>
<li>若参数格式不匹配（如<code>argv[1]</code>是字符串<code>&quot;abc&quot;</code>），<code>sscanf</code>会返回0（未成功读取），但代码未处理此错误，可能导致后续计算错误。</li>
</ul>
<h3 id="4-数值计算与结果输出"><a href="#4-数值计算与结果输出" class="headerlink" title="4. 数值计算与结果输出"></a>4. 数值计算与结果输出</h3><p>计算两数之和<code>num3</code>，并使用<code>printf</code>格式化输出结果，其中<code>argv[3]</code>作为结果的描述字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double num3 = num1 + num2;  // 计算和</span><br><span class="line">printf(&quot;结果字符串：%d + %.2f = %.2f %s</span><br><span class="line">&quot;, num1, num2, num3, argv[3]);  // 格式化输出</span><br></pre></td></tr></table></figure>

<p><strong>格式化说明</strong>：</p>
<ul>
<li><code>%d</code>：输出整数<code>num1</code>；</li>
<li><code>%.2f</code>：输出浮点数<code>num2</code>并保留2位小数；</li>
<li><code>%.2f</code>：输出和<code>num3</code>并保留2位小数；</li>
<li><code>%s</code>：输出描述字符串<code>argv[3]</code>。</li>
</ul>
<p><strong>示例输出</strong>（输入参数为<code>5 3.14 结果</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">结果字符串：5 + 3.14 = 8.14 结果</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="测试与验证：不同输入场景的效果"><a href="#测试与验证：不同输入场景的效果" class="headerlink" title="测试与验证：不同输入场景的效果"></a>测试与验证：不同输入场景的效果</h2><h3 id="场景1：正确输入（4个参数）"><a href="#场景1：正确输入（4个参数）" class="headerlink" title="场景1：正确输入（4个参数）"></a>场景1：正确输入（4个参数）</h3><p><strong>输入命令</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./calc 10 2.5 示例结果</span><br></pre></td></tr></table></figure>

<p><strong>输出结果</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">argument count = 4</span><br><span class="line">argv[0]：./calc</span><br><span class="line">argv[1]：10</span><br><span class="line">argv[2]：2.5</span><br><span class="line">argv[3]：示例结果</span><br><span class="line">结果字符串：10 + 2.50 = 12.50 示例结果</span><br></pre></td></tr></table></figure>

<h3 id="场景2：参数不足（仅3个参数）"><a href="#场景2：参数不足（仅3个参数）" class="headerlink" title="场景2：参数不足（仅3个参数）"></a>场景2：参数不足（仅3个参数）</h3><p><strong>输入命令</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./calc 10 2.5</span><br></pre></td></tr></table></figure>

<p><strong>输出结果</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">argument count = 3</span><br><span class="line">argv[0]：./calc</span><br><span class="line">argv[1]：10</span><br><span class="line">argv[2]：2.5</span><br><span class="line">结果字符串：10 + 2.50 = 12.50 (null)  // argv[3]为NULL，输出空</span><br></pre></td></tr></table></figure>

<h3 id="场景3：参数格式错误（非数字参数）"><a href="#场景3：参数格式错误（非数字参数）" class="headerlink" title="场景3：参数格式错误（非数字参数）"></a>场景3：参数格式错误（非数字参数）</h3><p><strong>输入命令</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./calc abc 2.5 结果</span><br></pre></td></tr></table></figure>

<p><strong>输出结果</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">argument count = 4</span><br><span class="line">argv[0]：./calc</span><br><span class="line">argv[1]：abc</span><br><span class="line">argv[2]：2.5</span><br><span class="line">argv[3]：结果</span><br><span class="line">结果字符串：0 + 2.50 = 2.50 结果  // num1未被正确解析为0（sscanf失败）</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="潜在问题"><a href="#潜在问题" class="headerlink" title="潜在问题"></a>潜在问题</h2><h3 id="问题1：未检查参数数量"><a href="#问题1：未检查参数数量" class="headerlink" title="问题1：未检查参数数量"></a>问题1：未检查参数数量</h3><p>代码假设用户至少输入4个参数（<code>argv[0]</code>到<code>argv[3]</code>），但未验证<code>argc</code>是否≥4。若用户输入参数不足（如仅3个），<code>argv[3]</code>会是<code>NULL</code>，导致<code>printf</code>输出空字符串或崩溃。</p>
<p><strong>改进建议</strong>：添加参数数量检查：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (argc &lt; 4) &#123;</span><br><span class="line">    printf(&quot;错误：需要至少4个参数（程序名、整数、浮点数、结果描述）</span><br><span class="line">&quot;);</span><br><span class="line">    return 1;  // 异常退出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题2：未处理sscanf解析失败"><a href="#问题2：未处理sscanf解析失败" class="headerlink" title="问题2：未处理sscanf解析失败"></a>问题2：未处理<code>sscanf</code>解析失败</h3><p>若<code>argv[1]</code>或<code>argv[2]</code>的格式不符合要求（如<code>argv[1]</code>是字符串<code>&quot;abc&quot;</code>），<code>sscanf</code>会返回0，导致<code>num1</code>或<code>num2</code>未被正确赋值（保持初始值0），最终结果错误。</p>
<p><strong>改进建议</strong>：检查<code>sscanf</code>的返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ret1 = sscanf(argv[1], &quot;%d&quot;, &amp;num1);</span><br><span class="line">int ret2 = sscanf(argv[2], &quot;%lf&quot;, &amp;num2);</span><br><span class="line">if (ret1 != 1 || ret2 != 1) &#123;</span><br><span class="line">    printf(&quot;错误：参数格式不正确（整数或浮点数）\n&quot;);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题3：浮点数精度丢失"><a href="#问题3：浮点数精度丢失" class="headerlink" title="问题3：浮点数精度丢失"></a>问题3：浮点数精度丢失</h3><p><code>num2</code>是<code>double</code>类型（双精度浮点数），但<code>sscanf</code>使用<code>%lf</code>读取，而<code>printf</code>使用<code>%.2f</code>输出（单精度格式）。虽然结果可能正确，但严格来说，双精度浮点数应使用<code>%lf</code>格式符（尽管在大多数编译器中<code>%f</code>和<code>%lf</code>对<code>printf</code>是等价的）。</p>
<p><strong>改进建议</strong>：统一使用<code>%lf</code>格式符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;结果字符串：%d + %.2lf = %.2lf %s\n&quot;, num1, num2, num3, argv[3]);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结：命令行参数处理的核心价值"><a href="#总结：命令行参数处理的核心价值" class="headerlink" title="总结：命令行参数处理的核心价值"></a>总结：命令行参数处理的核心价值</h2><p>命令行参数处理是C语言开发中连接用户输入与程序逻辑的关键环节。通过本文的解析，我们掌握了：</p>
<ul>
<li><code>argc</code>和<code>argv</code>的基本用法（参数数量与内容获取）；</li>
<li><code>sscanf</code>的格式化输入解析（从字符串读取数值）；</li>
<li>数值计算的格式化输出（控制精度与格式）；</li>
<li>常见错误处理（参数不足、格式错误）。</li>
</ul>
<p>这些技能是开发命令行工具（如计算器、文件处理器）的基础。实际开发中，建议结合错误处理逻辑，提升程序的健壮性；对于复杂参数（如选项参数<code>-h</code>、<code>-v</code>），可使用<code>getopt</code>库简化解析过程。</p>
<hr>
<h2 id="完整源代码"><a href="#完整源代码" class="headerlink" title="完整源代码"></a>完整源代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">命令行操作，main函数传参，调试，看输出情况</span><br><span class="line">*/</span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    // 检查参数数量是否足够（至少4个参数：程序名、整数、浮点数、结果描述）</span><br><span class="line">    if (argc &lt; 4) &#123;</span><br><span class="line">        printf(&quot;错误：需要至少4个参数（格式：程序名 整数 浮点数 结果描述）\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int num1;</span><br><span class="line">    double num2;</span><br><span class="line"></span><br><span class="line">    // 解析整数参数（argv[1]）</span><br><span class="line">    int ret1 = sscanf(argv[1], &quot;%d&quot;, &amp;num1);</span><br><span class="line">    if (ret1 != 1) &#123;</span><br><span class="line">        printf(&quot;错误：第一个参数必须是整数（当前值：%s）\n&quot;, argv[1]);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 解析浮点数参数（argv[2]）</span><br><span class="line">    int ret2 = sscanf(argv[2], &quot;%lf&quot;, &amp;num2);</span><br><span class="line">    if (ret2 != 1) &#123;</span><br><span class="line">        printf(&quot;错误：第二个参数必须是浮点数（当前值：%s）\n&quot;, argv[2]);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 计算和</span><br><span class="line">    double num3 = num1 + num2;</span><br><span class="line"></span><br><span class="line">    // 格式化输出结果（使用argv[3]作为描述）</span><br><span class="line">    printf(&quot;结果字符串：%d + %.2lf = %.2lf %s\n&quot;, num1, num2, num3, argv[3]);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程技术</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>命令行参数</tag>
        <tag>输入处理</tag>
        <tag>数值计算</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言位运算</title>
    <url>/posts/8f9a0b1c/</url>
    <content><![CDATA[<h2 id="引言：为什么需要掌握位运算？"><a href="#引言：为什么需要掌握位运算？" class="headerlink" title="引言：为什么需要掌握位运算？"></a>引言：为什么需要掌握位运算？</h2><p>在计算机底层，所有的数据都以二进制形式存储和处理。位运算（Bitwise Operations）作为直接操作二进制位的工具，是高性能计算、嵌入式开发、算法优化的核心技能。今天我们将通过一个实际案例，深入理解**与（&amp;）、或（|）、异或（^）、取反（~）、移位（&lt;&lt;、&gt;&gt;）**等位运算的应用场景，并实现一组实用的位操作函数。</p>
<hr>
<h2 id="位运算基础：二进制视角下的数字"><a href="#位运算基础：二进制视角下的数字" class="headerlink" title="位运算基础：二进制视角下的数字"></a>位运算基础：二进制视角下的数字</h2><p>要掌握位运算，首先需要理解二进制数的表示规则：</p>
<ul>
<li><strong>最低有效位（LSB）</strong>：二进制数的最右边一位（2⁰位），决定数的奇偶性；</li>
<li><strong>高位</strong>：从右往左依次为2¹、2²...2ⁿ位，每一位代表2的幂次；</li>
<li><strong>补码表示</strong>：负数在内存中以补码形式存储（原码取反+1），这是位运算处理负数的关键。</li>
</ul>
<hr>
<h2 id="实战函数解析：逐个击破位运算问题"><a href="#实战函数解析：逐个击破位运算问题" class="headerlink" title="实战函数解析：逐个击破位运算问题"></a>实战函数解析：逐个击破位运算问题</h2><h3 id="1-判断奇数：最低位的「1」密码"><a href="#1-判断奇数：最低位的「1」密码" class="headerlink" title="1. 判断奇数：最低位的「1」密码"></a>1. 判断奇数：最低位的「1」密码</h3><p><strong>问题描述</strong>：判断一个整数是否为奇数。<br> ​<strong>​位运算思路​</strong>​：奇数的二进制最低位一定是1，偶数的最低位是0。因此，只需将数字与1（二进制000...0001）进行按位与（&amp;）操作，若结果为1则是奇数，否则是偶数。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void is_odd(int num) &#123;</span><br><span class="line">    // 奇数的二进制最低位一定是1，用 num &amp; 1 保留最低位</span><br><span class="line">    int result = num &amp; 1;</span><br><span class="line">    printf(&quot;数字 %d 是否为奇数？%s\n&quot;, num, result ? &quot;是&quot; : &quot;否&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例验证</strong>：</p>
<ul>
<li>输入5（二进制101）：5 &amp; 1 &#x3D; 1 → 奇数；</li>
<li>输入6（二进制110）：6 &amp; 1 &#x3D; 0 → 偶数。</li>
</ul>
<hr>
<h3 id="2-判断2的幂：二进制中的「孤独1」"><a href="#2-判断2的幂：二进制中的「孤独1」" class="headerlink" title="2. 判断2的幂：二进制中的「孤独1」"></a>2. 判断2的幂：二进制中的「孤独1」</h3><p><strong>问题描述</strong>：判断一个正整数是否是2的幂（如1&#x3D;2⁰，2&#x3D;2¹，4&#x3D;2²...）。<br> ​<strong>​位运算思路​</strong>​：2的幂的二进制表示中只有一个1（如8&#x3D;1000₂），若将其减1（如8-1&#x3D;7&#x3D;0111₂），则原数与减1后的数按位与结果必为0（1000 &amp; 0111 &#x3D; 0000）。注意：0和负数不可能是2的幂。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void is_Power_of_two(int num) &#123;</span><br><span class="line">    // 2的幂必须是正整数</span><br><span class="line">    if (num &lt;= 0) &#123;</span><br><span class="line">        printf(&quot;数字 %d 不是2的幂（需为正整数）\n&quot;, num);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 若 num 是2的幂，则 num &amp; (num - 1) 必为0（如8=1000，8-1=0111，与运算结果为0）</span><br><span class="line">    int result = (num &amp; (num - 1)) == 0;</span><br><span class="line">    printf(&quot;数字 %d 是否为2的幂？%s\n&quot;, num, result ? &quot;是&quot; : &quot;否&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例验证</strong>：</p>
<ul>
<li>输入8（1000₂）：8 &amp; 7 &#x3D; 0 → 是2的幂；</li>
<li>输入6（0110₂）：6 &amp; 5 &#x3D; 4 ≠ 0 → 不是。</li>
</ul>
<hr>
<h3 id="3-找最低有效位（LSB）：定位第一个「1」"><a href="#3-找最低有效位（LSB）：定位第一个「1」" class="headerlink" title="3. 找最低有效位（LSB）：定位第一个「1」"></a>3. 找最低有效位（LSB）：定位第一个「1」</h3><p><strong>问题描述</strong>：给定非零整数，找出其值为1的最低有效位的位置（如6&#x3D;110₂，最低有效位是第2位，对应值为2¹&#x3D;2）。<br> ​<strong>​位运算思路​</strong>​：利用补码特性，负数的补码是原码取反+1。因此，<code>num &amp; (-num)</code>会将原数中最低位的1保留，其余位清零（如6&#x3D;000...0110，-6&#x3D;111...1010，6 &amp; -6&#x3D;000...0010&#x3D;2）。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void find_lsb(int num) &#123;</span><br><span class="line">    if (num == 0) &#123;  // 0没有有效位</span><br><span class="line">        printf(&quot;数字0没有最低有效位\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 利用补码特性：num &amp; (-num) 会保留最低位的1，其余位清零</span><br><span class="line">    int lsb_value = num &amp; (-num);</span><br><span class="line">    printf(&quot;数字 %d 的最低有效位值是：%d\n&quot;, num, lsb_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例验证</strong>：</p>
<ul>
<li>输入6（0110₂）：6 &amp; -6 &#x3D; 2（0010₂）→ 最低有效位是2；</li>
<li>输入12（1100₂）：12 &amp; -12 &#x3D; 4（0100₂）→ 最低有效位是4。</li>
</ul>
<hr>
<h3 id="4-交换数值：异或的自反魔法"><a href="#4-交换数值：异或的自反魔法" class="headerlink" title="4. 交换数值：异或的自反魔法"></a>4. 交换数值：异或的自反魔法</h3><p><strong>问题描述</strong>：不使用临时变量，交换两个整数的值。<br> ​<strong>​位运算思路​</strong>​：异或（^）满足以下性质：</p>
<ul>
<li><code>a ^ a = 0</code>（相同数异或为0）；</li>
<li><code>a ^ 0 = a</code>（任何数异或0不变）；</li>
<li>异或满足交换律和结合律。</li>
</ul>
<p>利用这些性质，可通过三次异或操作完成交换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void change(int *a, int *b) &#123;</span><br><span class="line">    if (a == b) return;  // 避免相同地址异或导致结果为0</span><br><span class="line">    *a ^= *b;  // a = a ^ b</span><br><span class="line">    *b ^= *a;  // b = (a ^ b) ^ b = a</span><br><span class="line">    *a ^= *b;  // a = (a ^ b) ^ a = b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修正说明</strong>：原代码中<code>change</code>函数参数为值传递（<code>int a, int b</code>），无法修改主函数中的变量。正确实现需使用指针（<code>int *a, int *b</code>）。</p>
<hr>
<h3 id="5-寻找唯一元素：异或的「分组」艺术"><a href="#5-寻找唯一元素：异或的「分组」艺术" class="headerlink" title="5. 寻找唯一元素：异或的「分组」艺术"></a>5. 寻找唯一元素：异或的「分组」艺术</h3><p><strong>问题描述</strong>：给定一个非空整数数组，除某个元素只出现一次外，其余元素均出现两次。找出这个唯一元素（扩展：若有两个元素各出现一次，其余出现两次，如何找出这两个元素？）。</p>
<h4 id="场景1：仅一个唯一元素"><a href="#场景1：仅一个唯一元素" class="headerlink" title="场景1：仅一个唯一元素"></a>场景1：仅一个唯一元素</h4><p><strong>位运算思路</strong>：利用异或性质，相同数异或结果为0，0异或任何数为自身。因此，遍历数组异或所有元素，最终结果即为唯一元素。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int find_only(int nums[], int length) &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result ^= nums[i];  // 异或性质：相同数异或为0，0异或任何数为自身</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="场景2：两个唯一元素（扩展）"><a href="#场景2：两个唯一元素（扩展）" class="headerlink" title="场景2：两个唯一元素（扩展）"></a>场景2：两个唯一元素（扩展）</h4><p><strong>位运算思路</strong>：</p>
<ol>
<li>先异或所有元素，得到两个唯一元素的异或结果（记为<code>lsb</code>）；</li>
<li><code>lsb</code>的二进制中至少有一位是1（因为两数不同），找到最低位的1（即<code>lsb &amp; (-lsb)</code>）；</li>
<li>根据该位将数组分为两组（该位为1和该位为0），每组内的元素异或结果即为两个唯一元素。</li>
</ol>
<p><strong>代码实现</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void find_two(int nums[], int length) &#123;</span><br><span class="line">    if (length &lt; 2) &#123;</span><br><span class="line">        printf(&quot;数组长度至少为2\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 第一轮异或：得到两个唯一元素的异或结果（记为 xor_sum）</span><br><span class="line">    int xor_sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        xor_sum ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 找到 xor_sum 中最低位的1（该位是两个唯一元素不同的位）</span><br><span class="line">    int lsb = xor_sum &amp; (-xor_sum);</span><br><span class="line"></span><br><span class="line">    // 第二轮异或：按 lsb 分组异或，每组结果即为一个唯一元素</span><br><span class="line">    int a = 0, b = 0;</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        if (nums[i] &amp; lsb) &#123;  // 该位为1的元素分到组a</span><br><span class="line">            a ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;  // 该位为0的元素分到组b</span><br><span class="line">            b ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;数组中两个唯一出现的元素是：%d 和 %d\n&quot;, a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例验证</strong>：</p>
<ul>
<li>数组<code>[2, 3, 2, 4]</code>：唯一元素是3和4；<br> 第一轮异或：2^3^2^4 &#x3D; 3^4 &#x3D; 7（二进制111）；<br> lsb &#x3D; 7 &amp; (-7) &#x3D; 1（二进制001）；<br> 分组异或：3（011）在组1（lsb&#x3D;1），4（100）在组2（lsb&#x3D;0），结果a&#x3D;3，b&#x3D;4。</li>
</ul>
<hr>
<h2 id="注意事项与常见陷阱"><a href="#注意事项与常见陷阱" class="headerlink" title="注意事项与常见陷阱"></a>注意事项与常见陷阱</h2><ol>
<li><strong>指针传递的重要性</strong>：<code>change</code>函数若使用值传递无法修改原变量，必须用指针（<code>int *</code>）；</li>
<li><strong>负数处理</strong>：位运算中负数以补码形式存在，需注意符号位的影响（如<code>-1</code>的二进制是全1）；</li>
<li><strong>移位溢出</strong>：左移操作（<code>&lt;&lt;</code>）可能导致高位丢失（如<code>int</code>类型左移32位结果未定义）；</li>
<li><strong>边界条件</strong>：判断2的幂时需排除0和负数（如<code>num=0</code>时<code>num&amp;(num-1)</code>会引发错误）。</li>
</ol>
<hr>
<h2 id="总结：位运算的核心价值"><a href="#总结：位运算的核心价值" class="headerlink" title="总结：位运算的核心价值"></a>总结：位运算的核心价值</h2><p>位运算不仅是C语言的基础技能，更是理解计算机底层原理的关键。通过本文的实战案例，我们掌握了：</p>
<ul>
<li>如何用位运算快速判断奇偶、2的幂；</li>
<li>如何定位最低有效位；</li>
<li>如何用异或实现无临时变量交换；</li>
<li>如何用异或分组解决复杂唯一元素问题。</li>
</ul>
<p>下次遇到类似问题时，不妨尝试用二进制视角重新审视数据——位运算的简洁与高效，会让你惊叹于计算机世界的「位」妙！</p>
<blockquote>
<p>提示：实际开发中需注意位运算的可读性，避免过度优化导致代码难以维护。对于复杂场景（如大端小端处理），建议结合具体硬件架构文档进行适配。</p>
</blockquote>
<hr>
<h2 id="附录：完整源代码与文件说明"><a href="#附录：完整源代码与文件说明" class="headerlink" title="附录：完整源代码与文件说明"></a>附录：完整源代码与文件说明</h2><p>为了方便读者复现与调试，以下是项目的完整源代码，并附各文件功能说明。</p>
<hr>
<h3 id="1-function-h-——-头文件（函数声明与宏定义）"><a href="#1-function-h-——-头文件（函数声明与宏定义）" class="headerlink" title="1. function.h —— 头文件（函数声明与宏定义）"></a>1. <code>function.h</code> —— 头文件（函数声明与宏定义）</h3><p><strong>文件作用</strong>：<br> 声明需要实现的位运算函数，以及必要的宏定义（如防止头文件重复包含）。头文件是C语言中实现模块化编程的关键，通过<code>#include</code>指令被其他源文件引用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef FUNCTION_H  // 防止头文件重复包含</span><br><span class="line">#define FUNCTION_H</span><br><span class="line"></span><br><span class="line">// 函数声明：判断整数是否为奇数</span><br><span class="line">void is_odd(int num);</span><br><span class="line"></span><br><span class="line">// 函数声明：判断是否为2的幂</span><br><span class="line">void is_Power_of_two(int num);</span><br><span class="line"></span><br><span class="line">// 函数声明：查找最低有效位（Last Set Bit）</span><br><span class="line">void find_lsb(int num);</span><br><span class="line"></span><br><span class="line">// 函数声明：交换两个整数的值（异或实现）</span><br><span class="line">void change(int *a, int *b);  // 注意：必须用指针传递才能修改原变量</span><br><span class="line"></span><br><span class="line">// 函数声明：查找数组中唯一出现一次的元素（其余出现两次）</span><br><span class="line">int find_only(int nums[], int length);</span><br><span class="line"></span><br><span class="line">// 函数声明：查找数组中两个唯一出现一次的元素（其余出现两次）</span><br><span class="line">void find_two(int nums[], int length);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-function-c-——-源文件（函数实现）"><a href="#2-function-c-——-源文件（函数实现）" class="headerlink" title="2. function.c —— 源文件（函数实现）"></a>2. <code>function.c</code> —— 源文件（函数实现）</h3><p><strong>文件作用</strong>：<br> 实现<code>function.h</code>中声明的所有位运算函数。将函数实现与声明分离，符合C语言的模块化编程规范，便于维护与代码复用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;function.h&quot;</span><br><span class="line"></span><br><span class="line">// 函数实现：判断整数是否为奇数（最低位是否为1）</span><br><span class="line">void is_odd(int num) &#123;</span><br><span class="line">    // 奇数的二进制最低位一定是1，用 num &amp; 1 保留最低位</span><br><span class="line">    int result = num &amp; 1;</span><br><span class="line">    printf(&quot;数字 %d 是否为奇数？%s&quot;, num, result ? &quot;是&quot; : &quot;否&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数实现：判断是否为2的幂（二进制仅有一个1）</span><br><span class="line">void is_Power_of_two(int num) &#123;</span><br><span class="line">// 2的幂必须是正整数</span><br><span class="line">    if (num &lt;= 0) &#123;  </span><br><span class="line">        printf(&quot;数字 %d 不是2的幂（需为正整数）&quot;, num);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 若 num 是2的幂，则 num &amp; (num - 1) 必为0（如8=1000，8-1=0111，与运算结果为0）</span><br><span class="line">    int result = (num &amp; (num - 1)) == 0;</span><br><span class="line">    printf(&quot;数字 %d 是否为2的幂？%s&quot;, num, result ? &quot;是&quot; : &quot;否&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数实现：查找最低有效位（Last Set Bit）</span><br><span class="line">void find_lsb(int num) &#123;</span><br><span class="line">    if (num == 0) &#123;  // 0没有有效位</span><br><span class="line">        printf(&quot;数字0没有最低有效位&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 利用补码特性：num &amp; (-num) 会保留最低位的1，其余位清零</span><br><span class="line">    int lsb_value = num &amp; (-num);</span><br><span class="line">    printf(&quot;数字 %d 的最低有效位值是：%d（对应2^%d位）&quot;, num, lsb_value, __builtin_ctz(lsb_value));  </span><br><span class="line">// __builtin_ctz计算末尾0的个数（GCC内置函数）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数实现：交换两个整数的值（异或无临时变量版）</span><br><span class="line">void change(int *a, int *b) &#123;</span><br><span class="line">    if (a == b) return;  // 避免相同地址异或导致结果为0</span><br><span class="line">    *a ^= *b;  // a = a ^ b</span><br><span class="line">    *b ^= *a;  // b = (a ^ b) ^ b = a</span><br><span class="line">    *a ^= *b;  // a = (a ^ b) ^ a = b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数实现：查找数组中唯一出现一次的元素（其余出现两次）</span><br><span class="line">int find_only(int nums[], int length) &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result ^= nums[i];  // 异或性质：相同数异或为0，0异或任何数为自身</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数实现：查找数组中两个唯一出现一次的元素（其余出现两次）</span><br><span class="line">void find_two(int nums[], int length) &#123;</span><br><span class="line">    if (length &lt; 2) &#123;</span><br><span class="line">    printf(&quot;数组长度至少为2&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 第一轮异或：得到两个唯一元素的异或结果（记为 xor_sum）</span><br><span class="line">    int xor_sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        xor_sum ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 找到 xor_sum 中最低位的1（该位是两个唯一元素不同的位）</span><br><span class="line">    int lsb = xor_sum &amp; (-xor_sum);</span><br><span class="line"></span><br><span class="line">    // 第二轮异或：按 lsb 分组异或，每组结果即为一个唯一元素</span><br><span class="line">    int a = 0, b = 0;</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        if (nums[i] &amp; lsb) &#123;  // 该位为1的元素分到组a</span><br><span class="line">            a ^= nums[i];</span><br><span class="line">        &#125; else &#123;  // 该位为0的元素分到组b</span><br><span class="line">            b ^= nums[i];#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;function.h&quot;</span><br><span class="line"></span><br><span class="line">// 函数实现：判断整数是否为奇数（最低位是否为1）</span><br><span class="line">void is_odd(int num) &#123;</span><br><span class="line">    // 奇数的二进制最低位一定是1，用 num &amp; 1 保留最低位</span><br><span class="line">    int result = num &amp; 1;</span><br><span class="line">    printf(&quot;数字 %d 是否为奇数？%s\n&quot;, num, result ? &quot;是&quot; : &quot;否&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数实现：判断是否为2的幂（二进制仅有一个1）</span><br><span class="line">void is_Power_of_two(int num) &#123;</span><br><span class="line">    // 2的幂必须是正整数</span><br><span class="line">    if (num &lt;= 0) &#123;</span><br><span class="line">        printf(&quot;数字 %d 不是2的幂（需为正整数）\n&quot;, num);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 若 num 是2的幂，则 num &amp; (num - 1) 必为0（如8=1000，8-1=0111，与运算结果为0）</span><br><span class="line">    int result = (num &amp; (num - 1)) == 0;</span><br><span class="line">    printf(&quot;数字 %d 是否为2的幂？%s\n&quot;, num, result ? &quot;是&quot; : &quot;否&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数实现：查找最低有效位（Last Set Bit）</span><br><span class="line">void find_lsb(int num) &#123;</span><br><span class="line">    if (num == 0) &#123;  // 0没有有效位</span><br><span class="line">        printf(&quot;数字0没有最低有效位\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 利用补码特性：num &amp; (-num) 会保留最低位的1，其余位清零</span><br><span class="line">    int lsb_value = num &amp; (-num);</span><br><span class="line">    printf(&quot;数字 %d 的最低有效位值是：%d\n&quot;, num, lsb_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数实现：交换两个整数的值（异或无临时变量版）</span><br><span class="line">void change(int *a, int *b) &#123;</span><br><span class="line">    if (a == b) return;  // 避免相同地址异或导致结果为0</span><br><span class="line">    *a ^= *b;  // a = a ^ b</span><br><span class="line">    *b ^= *a;  // b = (a ^ b) ^ b = a</span><br><span class="line">    *a ^= *b;  // a = (a ^ b) ^ a = b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数实现：查找数组中唯一出现一次的元素（其余出现两次）</span><br><span class="line">int find_only(int nums[], int length) &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result ^= nums[i];  // 异或性质：相同数异或为0，0异或任何数为自身</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数实现：查找数组中两个唯一出现一次的元素（其余出现两次）</span><br><span class="line">void find_two(int nums[], int length) &#123;</span><br><span class="line">    if (length &lt; 2) &#123;</span><br><span class="line">        printf(&quot;数组长度至少为2\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 第一轮异或：得到两个唯一元素的异或结果（记为 xor_sum）</span><br><span class="line">    int xor_sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        xor_sum ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 找到 xor_sum 中最低位的1（该位是两个唯一元素不同的位）</span><br><span class="line">    int lsb = xor_sum &amp; (-xor_sum);</span><br><span class="line"></span><br><span class="line">    // 第二轮异或：按 lsb 分组异或，每组结果即为一个唯一元素</span><br><span class="line">    int a = 0, b = 0;</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        if (nums[i] &amp; lsb) &#123;  // 该位为1的元素分到组a</span><br><span class="line">            a ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;  // 该位为0的元素分到组b</span><br><span class="line">            b ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;数组中两个唯一出现的元素是：%d 和 %d\n&quot;, a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-main-c-——-主程序入口"><a href="#3-main-c-——-主程序入口" class="headerlink" title="3. main.c —— 主程序入口"></a>3. <code>main.c</code> —— 主程序入口</h3><p><strong>文件作用</strong>：<br> 程序的入口函数（<code>main</code>函数），负责调用<code>function.c</code>中实现的位运算函数，完成测试逻辑。用户通过<code>main</code>函数输入数据，触发各个位运算功能的演示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS  // 关闭VS编译器的安全警告（如scanf）</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;function.h&quot;  // 包含函数声明</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    int num = 0;</span><br><span class="line">    printf(&quot;请输入你要查询的整数：\n&quot;);</span><br><span class="line">        scanf(&quot; %d&quot;, &amp;num);</span><br><span class="line">    // 输入整数（注意空格跳过换行符）</span><br><span class="line"></span><br><span class="line">    // 测试单个数字的位运算功能</span><br><span class="line">    is_odd(num);          // 判断奇偶</span><br><span class="line">    is_Power_of_two(num); // 判断是否为2的幂</span><br><span class="line">    find_lsb(num);        // 查找最低有效位</span><br><span class="line"></span><br><span class="line">    // 测试数组的唯一元素查找功能（示例数组）</span><br><span class="line">    int test_array[] = &#123; 2, 3, 2, 4, 5, 5, 3, 6 &#125;;</span><br><span class="line">    // 示例数组：2、4、6各出现一次，其余出现两次</span><br><span class="line">    int array_length = sizeof(test_array) / sizeof(test_array[0]);</span><br><span class="line">    // 计算数组长度</span><br><span class="line"></span><br><span class="line">    printf(&quot;--- 数组唯一元素测试 ---\n&quot;);</span><br><span class="line">    find_two(test_array, array_length);</span><br><span class="line">    // 查找两个唯一元素（本例中是4和6）</span><br><span class="line"></span><br><span class="line">    // 测试交换函数（可选）</span><br><span class="line">    int a = 10, b = 20;</span><br><span class="line">    printf(&quot;交换前：a=%d, b=%d\n&quot;, a, b);</span><br><span class="line">    change(&amp;a, &amp;b);  // 传递指针以修改原变量</span><br><span class="line">    printf(&quot;交换后：a=%d, b=%d\n&quot;, a, b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上代码，读者可直接运行并验证位运算的实战效果，加深对二进制操作的理解。</p>
]]></content>
      <categories>
        <category>CODE</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法优化</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言数组与指针深度解析</title>
    <url>/posts/87231a26/</url>
    <content><![CDATA[<hr>
<h2 id="引言：为什么需要理解数组与指针的差异？"><a href="#引言：为什么需要理解数组与指针的差异？" class="headerlink" title="引言：为什么需要理解数组与指针的差异？"></a>引言：为什么需要理解数组与指针的差异？</h2><p>在C语言中，数组和指针是最基础且容易混淆的概念。尤其是<code>*p[]</code>（指针数组）和<code>(*p)[]</code>（数组的数组）的语法差异，涉及类型优先级、内存布局和操作方式的本质区别。本文通过具体代码示例，结合<code>fruits1</code>（二维数组）和<code>fruits2</code>（指针数组）的对比，深入解析两者的核心差异，并探讨实际开发中的应用场景。</p>
<hr>
<h2 id="核心概念：-p-与-p-的类型优先级"><a href="#核心概念：-p-与-p-的类型优先级" class="headerlink" title="核心概念：*p[]与(*p)[]的类型优先级"></a>核心概念：<code>*p[]</code>与<code>(*p)[]</code>的类型优先级</h2><p>C语言中，运算符优先级决定了表达式的解析顺序。其中，<code>[]</code>（下标运算符）的优先级高于<code>*</code>（解引用运算符）。因此：</p>
<ul>
<li><code>*p[]</code>会被解析为<code>*(p[])</code>，即<strong>数组的指针</strong>（指针数组）：数组的每个元素是指针；</li>
<li><code>(*p)[]</code>会被解析为<code>(*p)[]</code>，即<strong>数组的数组</strong>（二维数组）：数组的每个元素是另一个数组。</li>
</ul>
<p>用户代码中的<code>fruits1</code>和<code>fruits2</code>正是这两种类型的典型代表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char fruits1[][10] = &#123; &quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot; &#125;;  // 二维数组（数组的数组）</span><br><span class="line">char *fruits2[] = &#123; &quot;apple&quot;,&quot;banana&quot;,&quot;cherry&quot; &#125;;       // 指针数组（数组的指针）</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="代码逐行解析：从定义到操作的完整流程"><a href="#代码逐行解析：从定义到操作的完整流程" class="headerlink" title="代码逐行解析：从定义到操作的完整流程"></a>代码逐行解析：从定义到操作的完整流程</h2><h3 id="1-数据定义：二维数组-vs-指针数组"><a href="#1-数据定义：二维数组-vs-指针数组" class="headerlink" title="1. 数据定义：二维数组 vs 指针数组"></a>1. 数据定义：二维数组 vs 指针数组</h3><h4 id="fruits1：二维数组（数组的数组）"><a href="#fruits1：二维数组（数组的数组）" class="headerlink" title="fruits1：二维数组（数组的数组）"></a><code>fruits1</code>：二维数组（数组的数组）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char fruits1[][10] = &#123; &quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot; &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>类型</strong>：<code>char [3][10]</code>（3个元素，每个元素是<code>char [10]</code>的数组）；</li>
<li><strong>内存布局</strong>：所有字符串连续存储在内存中，形成一个3×10的二维数组（实际存储为<code>&#39;a&#39;,&#39;p&#39;,&#39;p&#39;,&#39;l&#39;,&#39;e&#39;,&#39;\0&#39;,...</code>）；</li>
<li><strong>特点</strong>：数组名<code>fruits1</code>是常量指针，指向第一个子数组的起始地址（<code>&amp;fruits1[0]</code>）；<code>fruits1[i]</code>是第<code>i</code>个子数组的起始地址（<code>&amp;fruits1[i][0]</code>）。</li>
</ul>
<h4 id="fruits2：指针数组（数组的指针）"><a href="#fruits2：指针数组（数组的指针）" class="headerlink" title="fruits2：指针数组（数组的指针）"></a><code>fruits2</code>：指针数组（数组的指针）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *fruits2[] = &#123; &quot;apple&quot;,&quot;banana&quot;,&quot;cherry&quot; &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>类型</strong>：<code>char *[3]</code>（3个元素，每个元素是<code>char *</code>指针）；</li>
<li><strong>内存布局</strong>：数组本身存储3个指针（每个指针指向一个字符串字面量的地址）；</li>
<li><strong>特点</strong>：数组名<code>fruits2</code>是常量指针，指向第一个指针的起始地址（<code>&amp;fruits2[0]</code>）；<code>fruits2[i]</code>是第<code>i</code>个指针的地址（存储字符串字面量的首地址）。</li>
</ul>
<hr>
<h3 id="2-Num-arr函数：打印数组内容与长度"><a href="#2-Num-arr函数：打印数组内容与长度" class="headerlink" title="2. Num_arr函数：打印数组内容与长度"></a>2. <code>Num_arr</code>函数：打印数组内容与长度</h3><p>函数通过<code>sizeof</code>计算数组长度，并遍历打印每个字符串及其长度：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Num_arr() &#123;</span><br><span class="line">    // 打印fruits1（二维数组）</span><br><span class="line">    printf(&quot;Fruits1:</span><br><span class="line">&quot;);</span><br><span class="line">    for (int i = 0; i &lt; (sizeof(fruits1) / sizeof(fruits1[0])); i++) &#123;</span><br><span class="line">        printf(&quot;第%d个字符串是:%s, 字符串长度是:%zu\n&quot;, (i + 1), fruits1[i], strlen(fruits1[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 打印fruits2（指针数组）</span><br><span class="line">    printf(&quot;\nFruits2:\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; sizeof(fruits2) / sizeof(fruits2[0]); ++i) &#123;</span><br><span class="line">        printf(&quot;第%d个字符串是:%s, 字符串长度是:%zu\n&quot;, (i + 1), fruits2[i], strlen(fruits2[i]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键细节</strong>：</p>
<ul>
<li><code>sizeof(fruits1) / sizeof(fruits1[0])</code>：计算二维数组的行数（<code>3</code>），因为<code>sizeof(fruits1)</code>是整个二维数组的大小（<code>3×10=30</code>字节），<code>sizeof(fruits1[0])</code>是单个子数组的大小（<code>10</code>字节）；</li>
<li><code>sizeof(fruits2) / sizeof(fruits2[0])</code>：计算指针数组的元素个数（<code>3</code>），因为<code>sizeof(fruits2)</code>是指针数组的大小（<code>3×8=24</code>字节，假设64位系统），<code>sizeof(fruits2[0])</code>是单个指针的大小（<code>8</code>字节）。</li>
</ul>
<hr>
<h3 id="3-Change函数：修改数组元素的差异"><a href="#3-Change函数：修改数组元素的差异" class="headerlink" title="3. Change函数：修改数组元素的差异"></a>3. <code>Change</code>函数：修改数组元素的差异</h3><p>函数演示了对两种数组的修改操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Change() &#123;</span><br><span class="line">    // fruits1[0] = &quot;orange&quot;;  错误：数组名是常量指针，不可重新赋值</span><br><span class="line">    fruits2[0] = &quot;orange&quot;;    // 正确：指针数组的元素是指针，可重新指向新字符串</span><br><span class="line">    strcpy(fruits1[0], &quot;orange&quot;);  // 正确：修改二维数组的内容（非数组名）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心区别</strong>：</p>
<ul>
<li><strong><code>fruits1[0]</code></strong>：是二维数组的子数组名（<code>char [10]</code>类型），本质是常量指针（指向子数组的起始地址），无法通过<code>=</code>重新赋值；</li>
<li><strong><code>fruits2[0]</code></strong>：是指针数组的元素（<code>char *</code>类型），是普通指针变量，可以通过<code>=</code>重新指向其他字符串；</li>
<li><strong><code>strcpy(fruits1[0], &quot;orange&quot;)</code></strong>：通过<code>strcpy</code>修改二维数组的内容（覆盖原字符串），这是允许的，因为数组名指向的内存区域是可写的。</li>
</ul>
<hr>
<h3 id="4-Chang-banana函数：修改字符的细节"><a href="#4-Chang-banana函数：修改字符的细节" class="headerlink" title="4. Chang_banana函数：修改字符的细节"></a>4. <code>Chang_banana</code>函数：修改字符的细节</h3><p>函数演示了对字符串中单个字符的修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Chang_banana() &#123;</span><br><span class="line">    fruits1[1][0] = &#x27;B&#x27;;  // 正确：修改二维数组的字符（非字符串字面量）</span><br><span class="line">    fruits2[1] = &quot;Banana&quot;; // 正确：修改指针数组的指向（原字符串未被修改）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong>：</p>
<ul>
<li><strong><code>fruits1[1][0] = &#39;B&#39;</code></strong>：<code>fruits1</code>的子数组存储的是字符串<code>&quot;banana&quot;</code>（可写内存），因此可以直接修改第一个字符为<code>&#39;B&#39;</code>（结果为<code>&quot;Banana&quot;</code>）；</li>
<li><strong><code>fruits2[1] = &quot;Banana&quot;</code></strong>：<code>fruits2[1]</code>原指向字符串字面量<code>&quot;banana&quot;</code>（只读内存），但通过指针重新指向<code>&quot;Banana&quot;</code>（新的可写内存），原<code>&quot;banana&quot;</code>未被修改（若尝试修改<code>&quot;banana&quot;</code>的内容会导致未定义行为）。</li>
</ul>
<hr>
<h3 id="5-主函数：指针数组的灵活操作"><a href="#5-主函数：指针数组的灵活操作" class="headerlink" title="5. 主函数：指针数组的灵活操作"></a>5. 主函数：指针数组的灵活操作</h3><p>主函数定义了另一个指针数组<code>fruits3</code>，并演示了对其的修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main(void) &#123;</span><br><span class="line">    char apple[] = &quot;apple&quot;;   // 栈上的字符数组（可写）</span><br><span class="line">    char banana[] = &quot;banana&quot;; // 栈上的字符数组（可写）</span><br><span class="line">    char cherry[] = &quot;cherry&quot;; // 栈上的字符数组（可写）</span><br><span class="line">    char *fruits3[] = &#123; apple, banana, cherry &#125;; // 指针数组指向栈上的数组</span><br><span class="line"></span><br><span class="line">    fruits3[0] = &quot;orange&quot;;    // 正确：指针重新指向新的字符串（堆或只读区）</span><br><span class="line">    fruits3[1][0] = &#x27;B&#x27;;      // 正确：修改栈上数组的字符（`banana`变为&quot;Banana&quot;）</span><br><span class="line"></span><br><span class="line">    Chang_banana();           // 调用函数修改`fruits1`和`fruits2`</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键场景</strong>：</p>
<ul>
<li><code>fruits3</code>是指针数组，元素指向栈上的字符数组（<code>apple</code>、<code>banana</code>、<code>cherry</code>）；</li>
<li><code>fruits3[0] = &quot;orange&quot;</code>：指针重新指向字符串字面量<code>&quot;orange&quot;</code>（通常存储在只读区）；</li>
<li><code>fruits3[1][0] = &#39;B&#39;</code>：修改栈上<code>banana</code>数组的第一个字符（<code>&quot;banana&quot;</code>变为<code>&quot;Banana&quot;</code>）。</li>
</ul>
<hr>
<h2 id="内存布局对比：二维数组-vs-指针数组"><a href="#内存布局对比：二维数组-vs-指针数组" class="headerlink" title="内存布局对比：二维数组 vs 指针数组"></a>内存布局对比：二维数组 vs 指针数组</h2><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>二维数组（<code>fruits1</code>）</strong></th>
<th><strong>指针数组（<code>fruits2</code>）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>类型</strong></td>
<td><code>char [3][10]</code>（数组的数组）</td>
<td><code>char *[3]</code>（数组的指针）</td>
</tr>
<tr>
<td><strong>内存存储</strong></td>
<td>连续存储（所有字符在一个连续内存块中）</td>
<td>非连续存储（数组存储指针，指针指向分散的内存）</td>
</tr>
<tr>
<td><strong>修改数组名</strong></td>
<td>不允许（数组名是常量指针）</td>
<td>允许（数组名是常量指针，但元素是指针变量）</td>
</tr>
<tr>
<td><strong>修改元素内容</strong></td>
<td>允许（通过下标修改字符）</td>
<td>允许（通过指针修改指向的内容或重新指向）</td>
</tr>
<tr>
<td><strong>字符串字面量存储</strong></td>
<td>存储在数组内存中（可写）</td>
<td>存储在只读区（不可直接修改内容）</td>
</tr>
</tbody></table>
<hr>
<h2 id="潜在问题与最佳实践"><a href="#潜在问题与最佳实践" class="headerlink" title="潜在问题与最佳实践"></a>潜在问题与最佳实践</h2><h3 id="问题1：错误修改字符串字面量"><a href="#问题1：错误修改字符串字面量" class="headerlink" title="问题1：错误修改字符串字面量"></a>问题1：错误修改字符串字面量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruits2[1][0] = &#x27;b&#x27;;  // 未定义行为！`fruits2[1]`指向字符串字面量`&quot;banana&quot;`（只读区）</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong>：字符串字面量存储在只读内存中，直接修改其内容会导致程序崩溃或未定义行为。<br> ​<strong>​解决方案​</strong>​：若需修改字符串内容，应使用可写的字符数组（如<code>fruits1</code>或栈上的数组）。</p>
<h3 id="问题2：指针数组指向无效内存"><a href="#问题2：指针数组指向无效内存" class="headerlink" title="问题2：指针数组指向无效内存"></a>问题2：指针数组指向无效内存</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *fruits2[] = &#123; &quot;apple&quot;, &quot;banana&quot;, NULL &#125;;  // 最后一个元素为NULL</span><br><span class="line">fruits2[2][0] = &#x27;C&#x27;;  // 崩溃！NULL指针无指向的内存</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong>：指针数组的元素可能指向<code>NULL</code>或其他无效地址，直接解引用会导致崩溃。<br> ​<strong>​解决方案​</strong>​：操作指针数组前，需检查指针是否为<code>NULL</code>。</p>
<h3 id="问题3：二维数组越界访问"><a href="#问题3：二维数组越界访问" class="headerlink" title="问题3：二维数组越界访问"></a>问题3：二维数组越界访问</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;%s&quot;, fruits1[3]);  // 越界访问！`fruits1`只有3个元素（索引0-2）</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong>：二维数组的索引范围是<code>0</code>到<code>行数-1</code>，越界访问会导致未定义行为。<br> ​<strong>​解决方案​</strong>​：访问前检查索引是否在有效范围内（<code>0 ≤ i &lt; 行数</code>）。</p>
<hr>
<h2 id="总结：数组与指针的核心差异"><a href="#总结：数组与指针的核心差异" class="headerlink" title="总结：数组与指针的核心差异"></a>总结：数组与指针的核心差异</h2><p>通过本文的解析，我们掌握了：</p>
<ul>
<li><strong><code>\*p[]</code>（指针数组）</strong>：数组的元素是指针，存储的是内存地址，可灵活指向不同的内存区域；</li>
<li><strong><code>(\*p)[]</code>（二维数组）</strong>：数组的元素是另一个数组，内存连续存储，适合处理固定大小的字符串集合；</li>
<li><strong>操作差异</strong>：指针数组可重新指向新内存，二维数组可直接修改内容（需确保内存可写）；</li>
<li><strong>内存布局</strong>：指针数组非连续存储，二维数组连续存储，各有适用场景（如动态扩展用指针数组，固定数据用二维数组）。</li>
</ul>
<p>这些知识是C语言进阶的核心，熟练掌握后可更高效地处理字符串操作、内存管理和复杂数据结构（如链表、哈希表）。</p>
<hr>
<h2 id="完整源代码：C语言数组与指针深度解析（-p-vs-p-）"><a href="#完整源代码：C语言数组与指针深度解析（-p-vs-p-）" class="headerlink" title="完整源代码：C语言数组与指针深度解析（*p[] vs (*p)[]）"></a>完整源代码：C语言数组与指针深度解析（<code>*p[]</code> vs <code>(*p)[]</code>）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* 核心目标：对比二维数组（(*p)[]）与指针数组（*p[]）的类型差异与操作限制</span><br><span class="line">* 关键结论：</span><br><span class="line">*   - []优先级高于*，因此*p[]是数组的指针（指针数组），(*p)[]是数组的数组（二维数组）</span><br><span class="line">*   - 二维数组名是常量指针（不可重新赋值），但可通过下标修改元素内容（需内存可写）</span><br><span class="line">*   - 指针数组的元素是指针变量（可重新赋值指向新内存），但指向的内容是否可写取决于目标内存</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 二维数组（数组的数组）：连续内存存储，每个子数组固定大小</span><br><span class="line">char fruits1[][10] = &#123; &quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot; &#125;;  // 3个元素，每个元素是char[10]</span><br><span class="line"></span><br><span class="line">// 指针数组（数组的指针）：存储指针的数组，指针指向独立内存</span><br><span class="line">char *fruits2[] = &#123; &quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot; &#125;;      // 3个元素，每个元素是char*</span><br><span class="line"></span><br><span class="line">// 指针数组指向栈上的字符数组（可写内存）</span><br><span class="line">char apple_stack[] = &quot;apple&quot;;   // 栈上的字符数组（可写）</span><br><span class="line">char banana_stack[] = &quot;banana&quot;; // 栈上的字符数组（可写）</span><br><span class="line">char cherry_stack[] = &quot;cherry&quot;; // 栈上的字符数组（可写）</span><br><span class="line">char *fruits3[] = &#123; apple_stack, banana_stack, cherry_stack &#125;; // 指针数组指向栈数组</span><br><span class="line"></span><br><span class="line">// 函数1：打印数组内容与长度（验证内存布局与可访问性）</span><br><span class="line">void print_arrays() &#123;</span><br><span class="line">    printf(&quot;===== 打印二维数组 fruits1 =====\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; sizeof(fruits1) / sizeof(fruits1[0]); i++) &#123;</span><br><span class="line">        printf(&quot;fruits1[%d]: %s（长度：%zu，内存地址：%p）\n&quot;,</span><br><span class="line">               i, fruits1[i], strlen(fruits1[i]), (void*)fruits1[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n===== 打印指针数组 fruits2 =====\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; sizeof(fruits2) / sizeof(fruits2[0]); i++) &#123;</span><br><span class="line">        printf(&quot;fruits2[%d]: %s（长度：%zu，指针地址：%p，指向内存：%p）\n&quot;,</span><br><span class="line">               i, fruits2[i], strlen(fruits2[i]), (void*)&amp;fruits2[i], (void*)fruits2[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n===== 打印指针数组 fruits3（指向栈数组） =====\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; sizeof(fruits3) / sizeof(fruits3[0]); i++) &#123;</span><br><span class="line">        printf(&quot;fruits3[%d]: %s（长度：%zu，指针地址：%p，指向内存：%p）\n&quot;,</span><br><span class="line">               i, fruits3[i], strlen(fruits3[i]), (void*)&amp;fruits3[i], (void*)fruits3[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数2：修改数组元素（验证操作限制）</span><br><span class="line">void modify_arrays() &#123;</span><br><span class="line">    // 1. 尝试修改二维数组的&quot;数组名&quot;（非法操作）</span><br><span class="line">    // fruits1 = fruits2;  // 编译错误：数组名是常量指针，不可重新赋值</span><br><span class="line"></span><br><span class="line">    // 2. 修改二维数组的内容（通过下标，合法）</span><br><span class="line">    strcpy(fruits1[0], &quot;orange&quot;);  // 正确：覆盖二维数组的内存内容</span><br><span class="line">    fruits1[1][0] = &#x27;B&#x27;;           // 正确：修改二维数组的字符（原&quot;banana&quot;→&quot;Banana&quot;）</span><br><span class="line"></span><br><span class="line">    // 3. 修改指针数组的&quot;数组名&quot;（非法操作）</span><br><span class="line">    // fruits2 = fruits3;  // 错误：数组名是常量指针，不可重新赋值</span><br><span class="line">    // 修正：指针数组的元素是指针，应逐个修改元素指向</span><br><span class="line">    fruits2[0] = &quot;orange&quot;;  // 正确：修改指针数组的第0个元素指向新字符串</span><br><span class="line">    fruits2[1] = &quot;Banana&quot;;  // 正确：修改指针数组的第1个元素指向新字符串（原&quot;banana&quot;未被修改）</span><br><span class="line"></span><br><span class="line">    // 4. 修改指针数组指向的内容（取决于目标内存是否可写）</span><br><span class="line">    fruits3[1][0] = &#x27;b&#x27;;  // 正确：修改栈上的banana_stack数组（可写内存）</span><br><span class="line">    // fruits2[1][0] = &#x27;b&#x27;;  // 未定义行为！fruits2[1]指向字符串字面量（只读内存）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数3：验证指针数组与二维数组的本质区别</span><br><span class="line">void validate_differences() &#123;</span><br><span class="line">    // 二维数组的内存是连续的（所有字符在一个块中）</span><br><span class="line">    printf(&quot;\n===== 验证二维数组内存连续性 =====\n&quot;);</span><br><span class="line">    printf(&quot;fruits1[0]地址：%p，fruits1[0][0]地址：%p（偏移0）\n&quot;,</span><br><span class="line">           (void*)fruits1, (void*)&amp;fruits1[0][0]);</span><br><span class="line">    printf(&quot;fruits1[0]地址：%p，fruits1[0][9]地址：%p（偏移9）\n&quot;,</span><br><span class="line">           (void*)fruits1, (void*)&amp;fruits1[0][9]);</span><br><span class="line">    printf(&quot;fruits1[1]地址：%p（偏移10，与fruits1[0][9]+1一致）\n&quot;,</span><br><span class="line">           (void*)fruits1[1]);</span><br><span class="line"></span><br><span class="line">    // 指针数组的内存是非连续的（存储指针，指针指向分散内存）</span><br><span class="line">    printf(&quot;\n===== 验证指针数组内存非连续性 =====\n&quot;);</span><br><span class="line">    printf(&quot;fruits2[0]指针值：%p（指向字符串字面量）\n&quot;, (void*)fruits2[0]);</span><br><span class="line">    printf(&quot;fruits2[1]指针值：%p（指向字符串字面量）\n&quot;, (void*)fruits2[1]);</span><br><span class="line">    printf(&quot;fruits2[2]指针值：%p（指向字符串字面量）\n&quot;, (void*)fruits2[2]);</span><br><span class="line">    printf(&quot;fruits2数组本身的地址：%p，与指针值无关\n&quot;, (void*)fruits2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    // 初始化后直接打印</span><br><span class="line">    print_arrays();</span><br><span class="line"></span><br><span class="line">    // 修改数组元素并再次打印</span><br><span class="line">    modify_arrays();</span><br><span class="line">    printf(&quot;\n===== 修改后的数组状态 =====\n&quot;);</span><br><span class="line">    print_arrays();</span><br><span class="line"></span><br><span class="line">    // 验证内存布局差异</span><br><span class="line">    validate_differences();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;s</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="代码说明与关键注释"><a href="#代码说明与关键注释" class="headerlink" title="代码说明与关键注释"></a>代码说明与关键注释</h2><h3 id="1-数据定义部分"><a href="#1-数据定义部分" class="headerlink" title="1. 数据定义部分"></a>1. 数据定义部分</h3><ul>
<li><strong><code>fruits1</code>（二维数组）</strong>：<code>char [3][10]</code>类型，3个元素，每个元素是固定大小（10字节）的字符数组。内存连续存储所有字符串，可直接通过下标修改内容（需确保内存可写）。</li>
<li><strong><code>fruits2</code>（指针数组）</strong>：<code>char *[3]</code>类型，3个元素是指针变量，初始指向字符串字面量（通常存储在只读区）。指针变量本身可重新赋值，但指向的内容是否可写取决于目标内存。</li>
<li><strong><code>fruits3</code>（指针数组指向栈数组）</strong>：指针数组的元素指向栈上的字符数组（<code>apple_stack</code>等），这些栈数组是可写的，因此可通过指针修改其内容。</li>
</ul>
<h3 id="2-print-arrays函数"><a href="#2-print-arrays函数" class="headerlink" title="2. print_arrays函数"></a>2. <code>print_arrays</code>函数</h3><ul>
<li>打印二维数组的每个子数组内容、长度和内存地址；</li>
<li>打印指针数组的每个元素（指针值）、指向内容的长度、指针自身地址和指向的内存地址；</li>
<li>打印指针数组指向栈数组的特殊情况（验证栈内存的可写性）。</li>
</ul>
<h3 id="3-modify-arrays函数"><a href="#3-modify-arrays函数" class="headerlink" title="3. modify_arrays函数"></a>3. <code>modify_arrays</code>函数</h3><ul>
<li><strong>二维数组修改</strong>：通过<code>strcpy</code>覆盖<code>fruits1[0]</code>的内容（合法，因二维数组内存可写）；通过下标修改<code>fruits1[1][0]</code>的字符（合法，因内存可写）。</li>
<li><strong>指针数组修改</strong>：直接修改指针数组元素的指向（如<code>fruits2[0] = &quot;orange&quot;</code>），但不可直接修改数组名（<code>fruits2 = ...</code>是错误的，因数组名是常量指针）。</li>
<li><strong>字符串字面量保护</strong>：尝试修改<code>fruits2[1][0]</code>会触发未定义行为（字符串字面量存储在只读区）。</li>
</ul>
<h3 id="4-validate-differences函数"><a href="#4-validate-differences函数" class="headerlink" title="4. validate_differences函数"></a>4. <code>validate_differences</code>函数</h3><ul>
<li><strong>二维数组内存连续性</strong>：验证二维数组的所有字符存储在连续内存中（<code>fruits1[1]</code>的地址等于<code>fruits1[0]</code>的地址+10字节）。</li>
<li><strong>指针数组内存非连续性</strong>：验证指针数组存储的是指针变量（地址连续），但指针指向的内存是分散的（字符串字面量存储在不同位置）。</li>
</ul>
<hr>
<h2 id="编译与运行结果示例"><a href="#编译与运行结果示例" class="headerlink" title="编译与运行结果示例"></a>编译与运行结果示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">===== 打印二维数组 fruits1 =====</span><br><span class="line">fruits1[0]: apple（长度：5，内存地址：0x7ffd...）</span><br><span class="line">fruits1[1]: banana（长度：6，内存地址：0x7ffd...）</span><br><span class="line">fruits1[2]: cherry（长度：6，内存地址：0x7ffd...）</span><br><span class="line"></span><br><span class="line">===== 打印指针数组 fruits2 =====</span><br><span class="line">fruits2[0]: apple（长度：5，指针地址：0x7ffd..., 指向内存：0x55f5...）</span><br><span class="line">fruits2[1]: banana（长度：6，指针地址：0x7ffd..., 指向内存：0x55f5...）</span><br><span class="line">fruits2[2]: cherry（长度：6，指针地址：0x7ffd..., 指向内存：0x55f5...）</span><br><span class="line"></span><br><span class="line">===== 打印指针数组 fruits3（指向栈数组） =====</span><br><span class="line">fruits3[0]: apple（长度：5，指针地址：0x7ffd..., 指向内存：0x7ffd...）</span><br><span class="line">fruits3[1]: banana（长度：6，指针地址：0x7ffd..., 指向内存：0x7ffd...）</span><br><span class="line">fruits3[2]: cherry（长度：6，指针地址：0x7ffd..., 指向内存：0x7ffd...）</span><br><span class="line"></span><br><span class="line">===== 修改后的数组状态 =====</span><br><span class="line">===== 打印二维数组 fruits1 =====</span><br><span class="line">fruits1[0]: orange（长度：6，内存地址：0x7ffd...）</span><br><span class="line">fruits1[1]: Banana（长度：6，内存地址：0x7ffd...）</span><br><span class="line">fruits1[2]: cherry（长度：6，内存地址：0x7ffd...）</span><br><span class="line"></span><br><span class="line">===== 打印指针数组 fruits2 =====</span><br><span class="line">fruits2[0]: orange（长度：6，指针地址：0x7ffd..., 指向内存：0x55f5...）</span><br><span class="line">fruits2[1]: Banana（长度：6，指针地址：0x7ffd..., 指向内存：0x7ffd...）</span><br><span class="line">fruits2[2]: cherry（长度：6，指针地址：0x7ffd..., 指向内存：0x55f5...）</span><br><span class="line"></span><br><span class="line">===== 打印指针数组 fruits3（指向栈数组） =====</span><br><span class="line">fruits3[0]: apple（长度：5，指针地址：0x7ffd..., 指向内存：0x7ffd...）</span><br><span class="line">fruits3[1]: banana（长度：6，指针地址：0x7ffd..., 指向内存：0x7ffd...）</span><br><span class="line">fruits3[2]: cherry（长度：6，指针地址：0x7ffd..., 指向内存：0x7ffd...）</span><br><span class="line"></span><br><span class="line">===== 验证二维数组内存连续性 =====</span><br><span class="line">fruits1[0]地址：0x7ffd..., fruits1[0][0]地址：0x7ffd...（偏移0）</span><br><span class="line">fruits1[0]地址：0x7ffd..., fruits1[0][9]地址：0x7ffd...（偏移9）</span><br><span class="line">fruits1[1]地址：0x7ffd...（偏移10，与fruits1[0][9]+1一致）</span><br><span class="line"></span><br><span class="line">===== 验证指针数组内存非连续性 =====</span><br><span class="line">fruits2[0]指针值：0x55f5...（指向字符串字面量）</span><br><span class="line">fruits2[1]指针值：0x55f5...（指向字符串字面量）</span><br><span class="line">fruits2[2]指针值：0x55f5...（指向字符串字面量）</span><br><span class="line">fruits2数组本身的地址：0x7ffd..., 与指针值无关</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="核心结论总结"><a href="#核心结论总结" class="headerlink" title="核心结论总结"></a>核心结论总结</h2><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>二维数组（<code>fruits1</code>）</strong></th>
<th><strong>指针数组（<code>fruits2</code>）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>类型</strong></td>
<td><code>char [3][10]</code>（数组的数组）</td>
<td><code>char *[3]</code>（数组的指针）</td>
</tr>
<tr>
<td><strong>内存布局</strong></td>
<td>连续存储（所有字符在一个连续内存块中）</td>
<td>非连续存储（数组存储指针，指针指向分散的内存）</td>
</tr>
<tr>
<td><strong>修改数组名</strong></td>
<td>不允许（数组名是常量指针）</td>
<td>允许修改元素指向（数组名是常量指针，但元素是指针变量）</td>
</tr>
<tr>
<td><strong>修改元素内容</strong></td>
<td>允许（通过下标修改字符，需内存可写）</td>
<td>允许（通过指针修改指向的内容或重新指向）</td>
</tr>
<tr>
<td><strong>字符串字面量存储</strong></td>
<td>存储在数组内存中（可写）</td>
<td>存储在只读区（不可直接修改内容）</td>
</tr>
</tbody></table>
<p>通过运行和分析此代码，可直观理解<code>*p[]</code>（指针数组）与<code>(*p)[]</code>（二维数组）的本质差异，以及它们在实际开发中的应用场景（如动态扩展用指针数组，固定数据用二维数组）。</p>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>数组</tag>
        <tag>指针</tag>
        <tag>内存布局</tag>
      </tags>
  </entry>
</search>
