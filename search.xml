<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux 0.11（一）：进入内核前的底层机制剖析</title>
      <link href="/posts/c0ee3b8d/"/>
      <url>/posts/c0ee3b8d/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/28.png" alt="进入内核前的苦力活" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>在操作系统的演进历程中，Linux 0.11作为经典版本，其启动过程蕴含着深刻的底层设计哲学。从计算机通电到内核正式接管系统，这一阶段涉及硬件初始化、实模式与保护模式切换、内存重定位等核心环节，每一步都堪称现代操作系统启动流程的缩影。通过对《你管这破玩意叫操作系统源码》经典GitHub仓库学习与自我补充，了解Linux 0.11内核前的关键步骤。</p><hr><h2 id="一、BIOS引导：硬件检测与控制权移交"><a href="#一、BIOS引导：硬件检测与控制权移交" class="headerlink" title="一、BIOS引导：硬件检测与控制权移交"></a>一、BIOS引导：硬件检测与控制权移交</h2><p>当x86架构计算机通电后，CPU自动进入<strong>实模式</strong>（Real Mode），并从物理地址<code>0xFFFF0</code>开始执行指令。该地址对应主板上的<strong>ROM BIOS</strong>（Basic Input&#x2F;Output System）区域，BIOS随即执行以下核心任务：</p><ol><li><strong>硬件自检（POST）</strong>：对CPU、内存、硬盘、主板芯片组等硬件进行完整性检测，若发现故障则通过蜂鸣器或错误代码提示；</li><li><strong>中断向量初始化</strong>：在内存物理地址<code>0</code>处构建<strong>中断向量表</strong>（Interrupt Vector Table，IVT），为系统响应外部事件（如键盘输入、磁盘读写）提供基础；</li><li><strong>引导设备识别</strong>：按预设顺序（如软驱→硬盘→U盘）扫描可引导设备，将设备首个扇区（512字节，即<strong>主引导记录MBR</strong>）加载至内存<code>0x7c00</code>地址。</li></ol><p>完成上述步骤后，BIOS通过<code>jmp 0x7c00</code>指令将控制权转移至MBR中的引导程序，标志着Linux 0.11启动流程正式开始。</p><hr><h2 id="二、bootsect-s：早期加载与内核搬运"><a href="#二、bootsect-s：早期加载与内核搬运" class="headerlink" title="二、bootsect.s：早期加载与内核搬运"></a>二、bootsect.s：早期加载与内核搬运</h2><p>Linux 0.11的<strong>引导扇区程序bootsect.s</strong>被加载到<code>0x7c00</code>后，执行以下关键操作：</p><ol><li><strong>自我重定位</strong>：通过汇编指令将自身代码从<code>0x7c00</code>移动至<code>0x90000</code>（576KB），为后续加载腾出低地址空间。该操作利用了实模式下的直接内存访问特性；</li><li><strong>加载setup.s</strong>：从磁盘读取后续2KB代码（即<code>setup.s</code>）至内存<code>0x90200</code>，并在屏幕显示<code>Loading...</code>提示信息；</li><li><strong>加载内核主体</strong>：将内核的<code>system</code>模块（包含内核代码与数据）从磁盘读入内存<code>0x10000</code>处。由于早期Linux 0.11内核大小不超过512KB，因此不会覆盖<code>bootsect.s</code>与<code>setup.s</code>所在区域。</li></ol><p>这一阶段采用<strong>直接磁盘读取</strong>方式，依赖BIOS提供的中断服务（如<code>int 13h</code>磁盘读写中断），体现了早期操作系统对硬件资源的直接操控特性。</p><hr><h2 id="三、setup-s：系统环境初始化"><a href="#三、setup-s：系统环境初始化" class="headerlink" title="三、setup.s：系统环境初始化"></a>三、setup.s：系统环境初始化</h2><p><code>setup.s</code>程序被加载后，承担起<strong>系统环境配置</strong>的核心任务：</p><ol><li><strong>内核重定位</strong>：将位于<code>0x10000</code>的<code>system</code>模块整体移动至物理地址<code>0x00000</code>，使内核代码地址与物理地址对齐，简化后续内存管理操作；</li><li><strong>硬件信息采集</strong>：<ul><li>通过读取CMOS寄存器获取<strong>内存容量</strong>；</li><li>解析显卡BIOS获取<strong>显示模式</strong>信息；</li><li>检测键盘、硬盘等设备参数。</li></ul></li><li><strong>启动参数传递</strong>：将采集到的硬件信息存储至特定内存区域，供后续内核初始化使用。</li></ol><p>此阶段的内存移动操作采用逐字节复制方式，硬件检测则依赖x86架构的特定端口读写指令（如读取CMOS寄存器需访问<code>0x70</code>、<code>0x71</code>端口），展现了对底层硬件的精准控制能力。</p><hr><h2 id="四、head-s：保护模式切换与内核准备"><a href="#四、head-s：保护模式切换与内核准备" class="headerlink" title="四、head.s：保护模式切换与内核准备"></a>四、head.s：保护模式切换与内核准备</h2><p><code>head.s</code>作为从实模式向<strong>保护模式</strong>（Protected Mode）过渡的关键程序，执行以下核心步骤：</p><h3 id="（一）内存重定位与分页初始化"><a href="#（一）内存重定位与分页初始化" class="headerlink" title="（一）内存重定位与分页初始化"></a>（一）内存重定位与分页初始化</h3><ol><li><strong>逻辑地址映射</strong>：通过构建<strong>页表</strong>实现逻辑地址到物理地址的间接映射，无需物理移动代码即可实现地址空间重布局；</li><li><strong>分页机制激活</strong>：初始化<strong>页目录</strong>与二级页表，设置页目录基址寄存器<code>CR3</code>，并将控制寄存器<code>CR0</code>的<strong>PG位</strong>（分页标志）置1，开启32位分页寻址。</li></ol><h3 id="（二）保护模式切换流程"><a href="#（二）保护模式切换流程" class="headerlink" title="（二）保护模式切换流程"></a>（二）保护模式切换流程</h3><ol><li><strong>加载全局描述符表（GDT）</strong>：定义代码段、数据段等描述符，设置段基址、界限值与访问权限；</li><li><strong>启用A20地址线</strong>：通过键盘控制器或专用芯片解除1MB内存限制，使CPU可访问更高地址空间；</li><li><strong>设置CR0寄存器</strong>：将<code>CR0</code>的<strong>PE位</strong>（保护模式标志）置1，触发CPU模式切换。</li></ol><h3 id="（三）中断与异常处理准备"><a href="#（三）中断与异常处理准备" class="headerlink" title="（三）中断与异常处理准备"></a>（三）中断与异常处理准备</h3><ol><li><strong>初始化中断描述符表（IDT）</strong>：为后续系统调用与硬件中断处理预留接口，尽管具体处理函数将由C代码填充；</li><li><strong>刷新段寄存器</strong>：重新加载代码段、数据段选择子，确保保护模式下的内存访问合法性；</li><li><strong>栈初始化</strong>：清空栈基址并设置合适的栈指针，为后续C代码执行提供运行环境。</li></ol><p>完成上述操作后，<code>head.s</code>通过<code>jmp</code>指令将控制权转移至内核C语言入口函数<code>start_kernel()</code>，标志着内核初始化进入高级阶段。</p><hr><h2 id="五、技术深度解析"><a href="#五、技术深度解析" class="headerlink" title="五、技术深度解析"></a>五、技术深度解析</h2><p>Linux 0.11的启动流程深刻体现了早期操作系统设计的三大核心原则：</p><ol><li><strong>硬件兼容性</strong>：通过BIOS中断与端口操作实现对x86架构的直接控制，确保在不同硬件环境下的可启动性；</li><li><strong>模式切换艺术</strong>：实模式到保护模式的切换流程，展现了对CPU体系结构特性的精准利用；</li><li><strong>分层初始化思想</strong>：从引导扇区到内核主体，采用逐步递进的加载策略，降低系统启动的复杂性。</li></ol><hr><h3 id="代码结构概览"><a href="#代码结构概览" class="headerlink" title="代码结构概览"></a>代码结构概览</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">启动区核心代码段 (0x7C00)</span><br><span class="line">org 0x7C00</span><br><span class="line"></span><br><span class="line">第1-2回：代码迁移与跳转</span><br><span class="line">mov ax, 0x7C00</span><br><span class="line">mov ds, ax</span><br><span class="line">mov es, ax</span><br><span class="line">mov si, 0x0000</span><br><span class="line">mov di, 0x9000</span><br><span class="line">mov cx, 256</span><br><span class="line">rep movsw           ; 跳转至新位置</span><br><span class="line">jmp 0x9000:0x0000</span><br><span class="line"></span><br><span class="line">第3回：段寄存器初始化</span><br><span class="line">mov ax, 0x9000</span><br><span class="line">mov ds, ax</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 0xFF00      ; 栈顶初始化为0x9000:0xFF00</span><br><span class="line"></span><br><span class="line">第4回：硬盘数据加载</span><br><span class="line">mov ah, 0x02        ; BIOS读扇区功能</span><br><span class="line">mov al, 0x04        ; 加载4个扇区</span><br><span class="line">mov ch, 0x01        ; 起始扇区2</span><br><span class="line">mov cl, 0x02</span><br><span class="line">mov dl, 0x80        ; 硬盘0号设备</span><br><span class="line">mov bx, 0x9020      ; 目标地址0x90200</span><br><span class="line">int 0x13            ; </span><br><span class="line"></span><br><span class="line">第5-7回：保护模式切换</span><br><span class="line">lgdt [gdt_desc]     ; 加载GDT描述符</span><br><span class="line">mov eax, cr0</span><br><span class="line">or eax, 0x1         ; 设置PE位</span><br><span class="line">mov cr0, eax</span><br><span class="line">jmp 0x08:0x7E00     ; 远跳转刷新流水线 </span><br><span class="line"></span><br><span class="line">第8-10回：保护模式初始化</span><br><span class="line">[extern _main]</span><br><span class="line">startup_32:</span><br><span class="line">    mov ax, 0x10</span><br><span class="line">    mov ds, ax</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov fs, ax</span><br><span class="line">    mov gs, ax</span><br><span class="line">    lss esp, _stack_start</span><br><span class="line">    push 0x7E00       ; 为main函数准备参数</span><br><span class="line">    ret               ; 跳转到main函数 </span><br></pre></td></tr></table></figure><h2 id="六、关键技术解析"><a href="#六、关键技术解析" class="headerlink" title="六、关键技术解析"></a>六、关键技术解析</h2><h3 id="1-代码迁移机制"><a href="#1-代码迁移机制" class="headerlink" title="1. 代码迁移机制"></a>1. 代码迁移机制</h3><ul><li><strong>内存复制算法</strong>：使用<code>rep movsw</code>指令完成512字节数据迁移（256次×2字节）</li><li><strong>地址计算</strong>：<code>0x7C00</code>为BIOS加载MBR的标准地址，迁移至<code>0x90000</code>避免后续覆盖</li><li><strong>跳转逻辑</strong>：<code>jmp 0x9000:0x0000</code>通过段地址重置CS寄存器</li></ul><h3 id="2-保护模式切换流程"><a href="#2-保护模式切换流程" class="headerlink" title="2. 保护模式切换流程"></a>2. 保护模式切换流程</h3><table><thead><tr><th>步骤</th><th>操作</th><th>寄存器变化</th><th>作用域</th></tr></thead><tbody><tr><td>1</td><td>加载GDT</td><td>GDTR &#x3D; gdt_desc</td><td>全局描述符表</td></tr><tr><td>2</td><td>设置PE位</td><td>CR0[0] &#x3D; 1</td><td>控制寄存器</td></tr><tr><td>3</td><td>远跳转</td><td>CS:EIP刷新</td><td>指令流水线</td></tr><tr><td>4</td><td>段寄存器重构</td><td>DS&#x3D;ES&#x3D;FS&#x3D;GS&#x3D;0x10</td><td>数据段选择子</td></tr></tbody></table><h3 id="3-内存管理架构"><a href="#3-内存管理架构" class="headerlink" title="3. 内存管理架构"></a>3. 内存管理架构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// GDT表结构示例</span><br><span class="line">struct gdt_desc &#123;</span><br><span class="line">    uint16_t limit;</span><br><span class="line">    uint32_t base;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line">// 代码段描述符</span><br><span class="line">#define GDT_CODE_ENTRY \</span><br><span class="line">    &#123;0xFFFF, 0x00000000, 0x00CF9A00, 0x00000000&#125;</span><br><span class="line"></span><br><span class="line">// 分页机制初始化</span><br><span class="line">mov eax, cr0</span><br><span class="line">or eax, 0x80000000  ; 设置PG位</span><br><span class="line">mov cr0, eax</span><br></pre></td></tr></table></figure><h2 id="七、代码实现细节"><a href="#七、代码实现细节" class="headerlink" title="七、代码实现细节"></a>七、代码实现细节</h2><h3 id="1-中断服务调用"><a href="#1-中断服务调用" class="headerlink" title="1. 中断服务调用"></a>1. 中断服务调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">; 读取磁盘参数</span><br><span class="line">mov ah, 0x08        ; 获取驱动器参数</span><br><span class="line">int 0x13</span><br><span class="line">jc disk_error       ; 错误处理</span><br><span class="line"></span><br><span class="line">; 写入保护模式代码</span><br><span class="line">mov ax, 0x7E00</span><br><span class="line">mov es, ax</span><br><span class="line">mov bx, 0x0000</span><br><span class="line">mov cx, 0x0200      ; 512字节</span><br><span class="line">mov dx, 0x0000</span><br><span class="line">int 0x13</span><br></pre></td></tr></table></figure><h3 id="2-分页机制配置"><a href="#2-分页机制配置" class="headerlink" title="2. 分页机制配置"></a>2. 分页机制配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; 页目录表初始化</span><br><span class="line">mov eax, page_dir</span><br><span class="line">mov cr3, eax</span><br><span class="line">mov eax, 0x80000003 ; P=1, R/W=1, PS=1 (4MB页)</span><br><span class="line">mov cr4, eax</span><br></pre></td></tr></table></figure><hr><h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><ol><li><strong>内存操作</strong>：所有内存地址均采用<strong>物理地址</strong>计算（段地址×16 + 偏移地址）</li><li><strong>中断处理</strong>：<code>int 0x13</code>为BIOS标准磁盘中断，需确保AH寄存器正确设置</li><li><strong>保护模式</strong>：GDT表需包含至少3个描述符（代码段、数据段、空描述符）</li><li><strong>分页机制</strong>：启用PG位前需确保所有页表项已正确映射</li></ol><blockquote><p>注：实际启动过程中需处理A20地址线开启、软中断重定向等底层细节，此处为简化教学版本。</p></blockquote><img src="/img/PageCode/28-1.png" alt="学习Linux 0.11 思维导图" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);">]]></content>
      
      
      <categories>
          
          <category> Operating-Systems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 基础操作与核心概念详解</title>
      <link href="/posts/e476ab70/"/>
      <url>/posts/e476ab70/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/26.png" alt="Linux 基础操作与核心概念详解" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><h2 id="一、Linux-系统架构：用户空间与内核的交互桥梁"><a href="#一、Linux-系统架构：用户空间与内核的交互桥梁" class="headerlink" title="一、Linux 系统架构：用户空间与内核的交互桥梁"></a>一、Linux 系统架构：用户空间与内核的交互桥梁</h2><p>Linux 系统采用<strong>分层架构</strong>，核心逻辑围绕“用户空间”与“内核空间”的协作展开。用户程序无法直接操作硬件，必须通过内核提供的接口——这一接口正是我们今天要深入理解的<strong>系统调用</strong>、<strong>库函数</strong>与<strong>Shell 命令</strong>。</p><hr><h3 id="1-1-层次结构概览"><a href="#1-1-层次结构概览" class="headerlink" title="1.1 层次结构概览"></a>1.1 层次结构概览</h3><p>Linux 系统的运行逻辑可简化为三层模型（从用户到内核）：</p><table><thead><tr><th>层级</th><th>角色描述</th><th>典型代表&#x2F;技术</th></tr></thead><tbody><tr><td><strong>应用层</strong></td><td>用户直接使用的软件（如浏览器、文本编辑器）</td><td>Vim、GCC、Python</td></tr><tr><td><strong>库函数层</strong></td><td>对系统调用的封装，提供更易用的编程接口</td><td>C 标准库（如 <code>fopen</code>）、GNU C 库</td></tr><tr><td><strong>系统调用层</strong></td><td>内核暴露给用户空间的“唯一入口”，直接控制硬件资源</td><td><code>open</code>、<code>read</code>、<code>write</code></td></tr><tr><td><strong>内核层</strong></td><td>管理硬件资源（CPU、内存、磁盘），实现进程调度、文件系统等核心功能</td><td>Linux 内核（进程管理、内存管理）</td></tr></tbody></table><p><strong>关键结论</strong>：所有用户程序的操作（如读写文件、启动进程），最终都必须通过系统调用请求内核完成。</p><hr><h3 id="1-2-系统调用：用户与内核的“翻译官”"><a href="#1-2-系统调用：用户与内核的“翻译官”" class="headerlink" title="1.2 系统调用：用户与内核的“翻译官”"></a>1.2 系统调用：用户与内核的“翻译官”</h3><p>系统调用（System Call）是内核向用户空间提供的<strong>有限接口</strong>，相当于用户程序与内核之间的“翻译官”。它规定了用户程序“能做什么”和“不能做什么”，确保了系统的安全性和稳定性。</p><h4 id="核心特点："><a href="#核心特点：" class="headerlink" title="核心特点："></a>核心特点：</h4><ul><li><strong>唯一性</strong>：用户程序无法直接访问硬件，必须通过系统调用；</li><li><strong>原子性</strong>：系统调用一旦启动，内核会全程接管直至完成；</li><li><strong>特权隔离</strong>：用户空间运行在“用户态”，内核运行在“内核态”，系统调用是状态切换的触发点。</li></ul><h4 id="常见系统调用示例："><a href="#常见系统调用示例：" class="headerlink" title="常见系统调用示例："></a>常见系统调用示例：</h4><table><thead><tr><th>功能</th><th>系统调用</th><th>说明</th></tr></thead><tbody><tr><td>文件操作</td><td><code>open</code>、<code>read</code>、<code>write</code>、<code>close</code></td><td>打开&#x2F;读取&#x2F;写入&#x2F;关闭文件</td></tr><tr><td>进程控制</td><td><code>fork</code>、<code>exec</code>、<code>wait</code></td><td>创建进程、执行程序、等待子进程结束</td></tr><tr><td>网络通信</td><td><code>socket</code>、<code>connect</code>、<code>send</code>、<code>recv</code></td><td>创建套接字、连接网络、发送&#x2F;接收数据</td></tr></tbody></table><hr><h3 id="1-3-库函数层：系统调用的“包装纸”"><a href="#1-3-库函数层：系统调用的“包装纸”" class="headerlink" title="1.3 库函数层：系统调用的“包装纸”"></a>1.3 库函数层：系统调用的“包装纸”</h3><p>库函数（如 C 标准库 <code>libc</code>）是对系统调用的<strong>高级封装</strong>，目的是简化开发。开发者无需直接编写系统调用（需处理参数、错误码等细节），只需调用库函数即可。</p><h4 id="典型示例：fopen-与-open-的关系"><a href="#典型示例：fopen-与-open-的关系" class="headerlink" title="典型示例：fopen 与 open 的关系"></a>典型示例：<code>fopen</code> 与 <code>open</code> 的关系</h4><ul><li><code>fopen(&quot;file.txt&quot;, &quot;r&quot;)</code>（C 库函数）最终会调用 <code>open(&quot;/path/to/file.txt&quot;, O_RDONLY)</code>（系统调用）；</li><li>库函数可能添加缓冲机制（如 <code>fread</code> 会一次性读取更多数据减少系统调用次数），提升效率。</li></ul><p><strong>注意</strong>：并非所有库函数都依赖系统调用（如数学库 <code>math.h</code> 中的 <code>sqrt</code> 仅在用户空间计算），但涉及资源操作（文件、网络、进程）的库函数必然依赖系统调用。</p><hr><h3 id="1-4-应用层与-Shell：用户操作的“指挥中心”"><a href="#1-4-应用层与-Shell：用户操作的“指挥中心”" class="headerlink" title="1.4 应用层与 Shell：用户操作的“指挥中心”"></a>1.4 应用层与 Shell：用户操作的“指挥中心”</h3><p>Shell 是用户与 Linux 交互的<strong>命令行解释器</strong>，既是“命令输入窗口”，也是“脚本编程环境”。它的核心功能是：</p><ul><li>解析用户输入的命令（如 <code>ls -l</code>、<code>cd ~</code>）；</li><li>调用库函数或直接发起系统调用完成任务；</li><li>支持命令组合（如管道 <code>|</code>、重定向 <code>&gt;</code>）和脚本自动化。</li></ul><p><strong>类比</strong>：Shell 就像“翻译+调度员”——将用户的自然语言命令翻译成系统能理解的指令，并协调各程序协作执行。</p><hr><h2 id="二、Shell-命令行：Linux-的“瑞士军刀”"><a href="#二、Shell-命令行：Linux-的“瑞士军刀”" class="headerlink" title="二、Shell 命令行：Linux 的“瑞士军刀”"></a>二、Shell 命令行：Linux 的“瑞士军刀”</h2><p>掌握 Shell 命令是 Linux 运维、开发的基础。以下是最常用的几类命令，覆盖目录、文件、权限等核心操作。</p><hr><h3 id="2-1-基础操作：目录与文件管理"><a href="#2-1-基础操作：目录与文件管理" class="headerlink" title="2.1 基础操作：目录与文件管理"></a>2.1 基础操作：目录与文件管理</h3><h4 id="2-1-1-查看与切换目录（pwd、cd）"><a href="#2-1-1-查看与切换目录（pwd、cd）" class="headerlink" title="2.1.1 查看与切换目录（pwd、cd）"></a>2.1.1 查看与切换目录（<code>pwd</code>、<code>cd</code>）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwd：查看当前工作目录的绝对路径。</span><br><span class="line">$ pwd</span><br><span class="line">/home/user/documents</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd [目录]：切换目录。</span><br><span class="line">常用参数：</span><br><span class="line">- `cd ..`：切换到父目录；</span><br><span class="line">- `cd ~` 或 `cd`：切换到用户主目录（如 `/home/user`）；</span><br><span class="line">- `cd -`：切换到上一个工作目录。</span><br></pre></td></tr></table></figure><h4 id="2-1-2-创建与删除目录（mkdir、rmdir）"><a href="#2-1-2-创建与删除目录（mkdir、rmdir）" class="headerlink" title="2.1.2 创建与删除目录（mkdir、rmdir）"></a>2.1.2 创建与删除目录（<code>mkdir</code>、<code>rmdir</code>）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir [-p] 目录名：创建目录（ -p 参数允许递归创建多级目录）。</span><br><span class="line"></span><br><span class="line">$ mkdir dir1          # 创建一级目录 dir1</span><br><span class="line">$ mkdir -p a/b/c      # 创建多级目录 a/b/c（即使 a/b 不存在）</span><br><span class="line">`rmdir 目录名`：删除空目录（若目录非空，需用 `rm -r`）。</span><br></pre></td></tr></table></figure><h4 id="2-1-3-文件操作（touch、cp、mv、rm）"><a href="#2-1-3-文件操作（touch、cp、mv、rm）" class="headerlink" title="2.1.3 文件操作（touch、cp、mv、rm）"></a>2.1.3 文件操作（<code>touch</code>、<code>cp</code>、<code>mv</code>、<code>rm</code>）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch 文件名：创建新文件或更新文件时间戳。</span><br><span class="line">$ touch new_file.txt  # 创建空文件 new_file.txt</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp [选项] 源文件 目标路径  ：复制文件/目录（ -r 递归复制目录）。</span><br><span class="line">$ cp 1.txt 2.txt       # 复制 1.txt 为 2.txt（同目录）</span><br><span class="line">$ cp 1.txt dir/        # 复制 1.txt 到 dir 目录下</span><br><span class="line">$ cp -r dir1 dir2      # 递归复制整个目录 dir1 到 dir2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv [源文件/目录] [目标路径]：移动文件/目录，或重命名。</span><br><span class="line">$ mv 1.txt dir/        # 将 1.txt 移动到 dir 目录</span><br><span class="line">$ mv old_name.txt new_name.txt  # 重命名文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rm [选项] 文件/目录：删除文件/目录（ -r 递归删除目录， -f 强制删除）。</span><br><span class="line">$ rm 1.txt             # 删除文件 1.txt</span><br><span class="line">$ rm -r dir/           # 递归删除目录 dir/</span><br><span class="line">$ rm -f important.txt  # 强制删除（不提示确认）</span><br></pre></td></tr></table></figure><hr><h3 id="2-2-高级操作：搜索、查看与管道"><a href="#2-2-高级操作：搜索、查看与管道" class="headerlink" title="2.2 高级操作：搜索、查看与管道"></a>2.2 高级操作：搜索、查看与管道</h3><h4 id="2-2-1-文件内容查看（cat、less、head、tail）"><a href="#2-2-1-文件内容查看（cat、less、head、tail）" class="headerlink" title="2.2.1 文件内容查看（cat、less、head、tail）"></a>2.2.1 文件内容查看（<code>cat</code>、<code>less</code>、<code>head</code>、<code>tail</code>）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat 文件名：一次性显示文件全部内容（适合小文件）。</span><br><span class="line">$ cat hello.txt  # 输出文件 hello.txt 的内容</span><br><span class="line">`less 文件名`：分屏查看大文件，支持上下翻页（`j` 下翻，`k` 上翻）、搜索（`/关键词`）。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">head -n 行数 文件名：显示文件前 N 行（默认 10 行）。</span><br><span class="line">$ head -n 5 log.txt  # 显示 log.txt 前 5 行</span><br><span class="line">tail -n 行数 文件名：显示文件后 N 行；</span><br><span class="line">tail -f 文件名 实时跟踪文件新增内容（监控日志神器）。</span><br><span class="line">$ tail -f /var/log/syslog  # 实时查看系统日志</span><br></pre></td></tr></table></figure><h4 id="2-2-2-搜索工具（grep、find）"><a href="#2-2-2-搜索工具（grep、find）" class="headerlink" title="2.2.2 搜索工具（grep、find）"></a>2.2.2 搜索工具（<code>grep</code>、<code>find</code>）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep [选项] 关键词 文件名：在文件中搜索关键词（支持正则表达式）。</span><br><span class="line">$ grep -n &quot;error&quot; app.log  # 显示 app.log 中包含 &quot;error&quot; 的行及行号</span><br><span class="line">$ grep -E &quot;http|https&quot; urls.txt  # 用正则匹配 &quot;http&quot; 或 &quot;https&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find 路径 [条件] [操作]：递归搜索目录下的文件/目录（支持按名称、类型、时间等过滤）。</span><br><span class="line">$ find /usr/include -name &quot;stdio.h&quot;  # 在 /usr/include 目录下查找 stdio.h</span><br><span class="line">$ find . -type d -name &quot;test&quot;        # 在当前目录下查找名为 test 的目录</span><br><span class="line">$ find . -mtime -7                   # 查找最近 7 天内修改过的文件</span><br></pre></td></tr></table></figure><h4 id="2-2-3-命令组合：让效率翻倍"><a href="#2-2-3-命令组合：让效率翻倍" class="headerlink" title="2.2.3 命令组合：让效率翻倍"></a>2.2.3 命令组合：让效率翻倍</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;：顺序执行多个命令（前一个失败不影响后一个）。</span><br><span class="line">$ mkdir backup; cp data.txt backup/  # 先创建 backup 目录，再复制文件</span><br><span class="line"></span><br><span class="line">|：管道（将前一个命令的输出作为后一个命令的输入）。</span><br><span class="line">$ ps aux | grep &quot;nginx&quot;  # 查看所有进程，筛选出包含 &quot;nginx&quot; 的进程</span><br><span class="line">$ cat large.log | grep &quot;ERROR&quot; | wc -l  # 统计日志中 &quot;ERROR&quot; 出现的次数</span><br><span class="line"></span><br><span class="line">&amp;&amp;：前一个命令成功则执行后一个（ || 前一个失败则执行后一个）。</span><br><span class="line">$ make &amp;&amp; make install  # 编译成功后才执行安装</span><br></pre></td></tr></table></figure><hr><h3 id="2-3-权限管理：控制资源的“钥匙”"><a href="#2-3-权限管理：控制资源的“钥匙”" class="headerlink" title="2.3 权限管理：控制资源的“钥匙”"></a>2.3 权限管理：控制资源的“钥匙”</h3><p>Linux 是多用户系统，权限管理是核心安全机制。每个文件&#x2F;目录有<strong>三类权限</strong>（用户、组、其他用户），通过 <code>rwx</code>（读、写、执行）控制。</p><h4 id="2-3-1-权限基础：rwx-的含义"><a href="#2-3-1-权限基础：rwx-的含义" class="headerlink" title="2.3.1 权限基础：rwx 的含义"></a>2.3.1 权限基础：rwx 的含义</h4><table><thead><tr><th>权限类型</th><th>对文件的含义</th><th>对目录的含义</th></tr></thead><tbody><tr><td><code>r</code>（Read）</td><td>允许读取文件内容</td><td>允许列出目录下的文件&#x2F;子目录</td></tr><tr><td><code>w</code>（Write）</td><td>允许修改文件内容（删除需配合目录写权限）</td><td>允许在目录中新建&#x2F;删除&#x2F;重命名文件</td></tr><tr><td><code>x</code>（Execute）</td><td>允许执行文件（脚本或可执行程序）</td><td>允许进入目录（<code>cd</code>）或访问目录元数据</td></tr></tbody></table><p><strong>示例</strong>：<code>-rwxr-xr--</code> 表示：</p><ul><li>所有者（User）：读、写、执行（<code>rwx</code>）；</li><li>所属组（Group）：读、执行（<code>r-x</code>）；</li><li>其他用户（Others）：只读（<code>r--</code>）。</li></ul><h4 id="2-3-2-修改权限：chmod-命令"><a href="#2-3-2-修改权限：chmod-命令" class="headerlink" title="2.3.2 修改权限：chmod 命令"></a>2.3.2 修改权限：<code>chmod</code> 命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">`chmod` 用于修改文件/目录的权限，支持两种模式：</span><br><span class="line"></span><br><span class="line">  数字模式：将 rwx 转换为八进制数（ r=4，w=2 ,x=1，无权限=0），三类权限值相加。</span><br><span class="line">  $ chmod 755 script.sh  # 所有者 7（4+2+1=rwx），组和其他 5（4+1=r-x）</span><br><span class="line">  </span><br><span class="line">  符号模式：通过 用户类别[+=-]权限灵活调整。</span><br><span class="line">  $ chmod u+w,g-r,o=x file.txt  # 所有者加写权限，组去读权限，其他设为执行</span><br><span class="line">  $ chmod a+x script.sh         # 所有用户加执行权限（a=所有）</span><br></pre></td></tr></table></figure><h4 id="2-3-3-默认权限：umask-命令"><a href="#2-3-3-默认权限：umask-命令" class="headerlink" title="2.3.3 默认权限：umask 命令"></a>2.3.3 默认权限：<code>umask</code> 命令</h4><p><code>umask</code> 控制新建文件&#x2F;目录的默认权限（默认值为 <code>022</code>）：</p><ul><li>目录默认权限 &#x3D; <code>777 - umask</code>（如 <code>umask 022</code>，则目录权限 <code>755</code>）；</li><li>文件默认权限 &#x3D; <code>666 - umask</code>（如 <code>umask 022</code>，则文件权限 <code>644</code>）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ umask 007  # 设置新建文件权限 660（666-007），目录权限 770（777-007）</span><br></pre></td></tr></table></figure><hr><h2 id="三、文件系统：数据的“组织蓝图”"><a href="#三、文件系统：数据的“组织蓝图”" class="headerlink" title="三、文件系统：数据的“组织蓝图”"></a>三、文件系统：数据的“组织蓝图”</h2><p>Linux 文件系统采用<strong>树形结构</strong>（根目录 <code>/</code> 为起点），所有文件&#x2F;目录均挂载在这棵“树”下。要深入理解文件系统，需掌握以下核心概念：</p><hr><h3 id="3-1-Inode：文件的“身份证”"><a href="#3-1-Inode：文件的“身份证”" class="headerlink" title="3.1 Inode：文件的“身份证”"></a>3.1 Inode：文件的“身份证”</h3><p>Inode（索引节点）是 Linux 文件系统的核心数据结构，存储文件的<strong>元数据</strong>（非文件内容），包括：</p><ul><li>文件类型（普通文件、目录、符号链接等）；</li><li>权限（<code>rwx</code>）、硬链接数；</li><li>所有者（User）、所属组（Group）；</li><li>文件大小、最后修改时间；</li><li>数据块指针（指向文件内容存储的磁盘位置）。</li></ul><h4 id="查看-Inode-信息："><a href="#查看-Inode-信息：" class="headerlink" title="查看 Inode 信息："></a>查看 Inode 信息：</h4><ul><li><code>ls -i 文件名</code>：显示文件的 Inode 编号。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -i hello.txt  # 输出：12345 hello.txt（12345 是 Inode 号）</span><br></pre></td></tr></table></figure><ul><li><code>stat 文件名</code>：显示 Inode 的详细信息（包括数据块位置、时间戳等）。<br><strong>关键结论</strong>：文件内容存储在数据块中，Inode 存储“如何找到数据块”的信息。删除文件时，实际是删除 Inode 与数据块的关联（数据块不会立即被覆盖）。</li></ul><hr><h3 id="3-2-软硬链接：文件的“别名”与“克隆”"><a href="#3-2-软硬链接：文件的“别名”与“克隆”" class="headerlink" title="3.2 软硬链接：文件的“别名”与“克隆”"></a>3.2 软硬链接：文件的“别名”与“克隆”</h3><p>链接（Link）是 Inode 的“快捷方式”，分为两种：</p><table><thead><tr><th>类型</th><th>特点</th><th>示例命令</th></tr></thead><tbody><tr><td><strong>硬链接</strong></td><td>与原文件共享同一个 Inode，删除原文件不影响硬链接（需至少一个硬链接存在）</td><td><code>ln 原文件 硬链接名</code></td></tr><tr><td><strong>软链接</strong></td><td>独立文件，存储原文件的路径（类似 Windows 快捷方式），原文件删除后失效</td><td><code>ln -s 原文件路径 软链接名</code></td></tr></tbody></table><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ln data.txt hard_link.txt  # 创建 data.txt 的硬链接 hard_link.txt</span><br><span class="line">$ ln -s /home/user/data.txt soft_link.txt  # 创建软链接 soft_link.txt</span><br></pre></td></tr></table></figure><hr><h3 id="3-3-虚拟文件系统（VFS）：统一存储的“魔法桥梁”"><a href="#3-3-虚拟文件系统（VFS）：统一存储的“魔法桥梁”" class="headerlink" title="3.3 虚拟文件系统（VFS）：统一存储的“魔法桥梁”"></a>3.3 虚拟文件系统（VFS）：统一存储的“魔法桥梁”</h3><p>Linux 支持多种文件系统（如 ext4、XFS、NTFS），虚拟文件系统（VFS）是它们的“统一接口”。VFS 定义了一套通用操作（如 <code>open</code>、<code>read</code>），不同文件系统实现这些操作的具体逻辑。</p><p><strong>作用</strong>：用户无需关心底层是 ext4 还是 NTFS，只需通过统一的系统调用操作文件。例如，挂载 U 盘（NTFS 格式）后，可直接用 <code>cd</code>、<code>ls</code> 访问，VFS 会自动调用 NTFS 驱动处理请求。</p><hr><h2 id="四、Vim-编辑器：文本处理的“效率神器”"><a href="#四、Vim-编辑器：文本处理的“效率神器”" class="headerlink" title="四、Vim 编辑器：文本处理的“效率神器”"></a>四、Vim 编辑器：文本处理的“效率神器”</h2><p>Vim 是 Linux 下经典的文本编辑器，以“模式化操作”和“高效编辑”著称。掌握 Vim 能大幅提升文本处理效率。</p><hr><h3 id="4-1-模式与基本操作"><a href="#4-1-模式与基本操作" class="headerlink" title="4.1 模式与基本操作"></a>4.1 模式与基本操作</h3><p>Vim 有三种核心模式：</p><table><thead><tr><th>模式</th><th>功能</th><th>切换方式</th></tr></thead><tbody><tr><td><strong>普通模式</strong></td><td>输入命令（移动光标、删除文本、复制粘贴等）</td><td>启动 Vim 默认进入此模式</td></tr><tr><td><strong>插入模式</strong></td><td>输入文本内容</td><td>按 <code>i</code>（当前位置）、<code>a</code>（光标后）、<code>o</code>（下一行）等进入</td></tr><tr><td><strong>命令模式</strong></td><td>执行保存、退出、查找替换等全局命令</td><td>按 <code>:</code> 进入（如 <code>:wq</code> 保存退出）</td></tr></tbody></table><h4 id="常用操作示例："><a href="#常用操作示例：" class="headerlink" title="常用操作示例："></a>常用操作示例：</h4><ul><li>打开&#x2F;创建文件：<code>vim 文件名</code>（如 <code>vim test.txt</code>）；</li><li>移动光标：<code>h</code>（左）、<code>j</code>（下）、<code>k</code>（上）、<code>l</code>（右）；</li><li>复制粘贴：<code>yy</code>（复制当前行）、<code>p</code>（粘贴到光标下一行）；</li><li>删除文本：<code>dd</code>（删除当前行）、<code>dw</code>（删除当前单词）；</li><li>保存退出：<code>:w</code>（保存）、<code>:q</code>（退出）、<code>:wq</code>（保存并退出）、&#96;:q!</li></ul><blockquote><p>未完待续……</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 系统调用 </tag>
            
            <tag> shell命令 </tag>
            
            <tag> 库函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux：从极客玩具到全球技术基石的传奇之路</title>
      <link href="/posts/195fb17c/"/>
      <url>/posts/195fb17c/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/16.png" alt="Linux：从极客玩具到全球技术基石的传奇之路" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>如果说现代计算机的世界是一片浩瀚的海洋，那么Linux无疑是其中最汹涌的浪潮之一。它不仅打破了Windows与Unix长期垄断操作系统的格局，更以“开源”为旗帜，重塑了全球软件开发的协作模式。今天，我们将沿着时间线，从Unix的诞生说起，一步步揭开Linux如何从一个芬兰学生的“个人实验”，成长为支撑云计算、AI、移动设备的核心技术。</p><hr><h2 id="一、土壤：Unix与自由软件运动的萌芽（1960s-1990年代初）"><a href="#一、土壤：Unix与自由软件运动的萌芽（1960s-1990年代初）" class="headerlink" title="一、土壤：Unix与自由软件运动的萌芽（1960s-1990年代初）"></a>一、土壤：Unix与自由软件运动的萌芽（1960s-1990年代初）</h2><h3 id="1-1-Unix的诞生：从“太空旅行”游戏开始的革命"><a href="#1-1-Unix的诞生：从“太空旅行”游戏开始的革命" class="headerlink" title="1.1 Unix的诞生：从“太空旅行”游戏开始的革命"></a>1.1 Unix的诞生：从“太空旅行”游戏开始的革命</h3><p>故事要从1969年的贝尔实验室说起。那时的计算机还是“庞然大物”，程序员需要通过打孔卡输入指令，等待数小时才能得到结果。为了改变这种低效，贝尔实验室、MIT和通用电气联合启动了<strong>Multics计划</strong>（多路信息计算系统），目标是让大型主机同时支持300多个终端——这在当时堪称“科幻级”设想。</p><p>但Multics项目因资金和技术复杂度过高，1969年贝尔实验室选择退出。不过，参与项目的工程师肯·汤普森（Ken Thompson）却从中获得灵感。为了在闲置的PDP-7小型机上玩自己开发的“太空旅行”游戏，他用汇编语言写了一个简化版操作系统内核，同事戏称为<strong>Unics</strong>（“更简单的Multics”）。</p><p>Unics的核心思想影响至今：</p><ul><li><strong>一切皆文件</strong>：将硬件设备、程序数据统一视为文件，极大简化了系统设计；</li><li><strong>KISS原则</strong>（Keep It Simple, Stupid）：功能专注、代码简洁，避免过度设计。</li></ul><p>1973年，汤普森与丹尼斯·里奇（Dennis Ritchie）用新发明的C语言重写Unics内核，正式命名为<strong>Unix</strong>。C语言的可移植性让Unix能轻松适配不同硬件，AT&amp;T（贝尔实验室母公司）随后将其商业化，但早期采取“免费分发源码”的开放策略，这为后续开源文化埋下了种子。</p><h3 id="1-2-分裂与限制：Unix的“闭源危机”"><a href="#1-2-分裂与限制：Unix的“闭源危机”" class="headerlink" title="1.2 分裂与限制：Unix的“闭源危机”"></a>1.2 分裂与限制：Unix的“闭源危机”</h3><p>1979年，AT&amp;T推出支持x86架构的<strong>System V第七版</strong>，个人电脑终于能运行Unix。但随着AT&amp;T被反垄断拆分，公司开始收紧版权——1983年后，Unix源码不再公开，企业需付费购买授权。这一操作导致两个后果：</p><ul><li><strong>学术界不满</strong>：教授无法向学生展示真实操作系统内核；</li><li><strong>商业分裂</strong>：IBM、HP等公司各自开发专属Unix（如AIX、HP&#x2F;UX），碎片化严重。</li></ul><h3 id="1-3-Minix与GNU：Linux诞生的“前站”"><a href="#1-3-Minix与GNU：Linux诞生的“前站”" class="headerlink" title="1.3 Minix与GNU：Linux诞生的“前站”"></a>1.3 Minix与GNU：Linux诞生的“前站”</h3><p>为解决教学需求，荷兰计算机科学家安德鲁·塔能鲍姆（Andrew Tanenbaum）于1987年开发了<strong>Minix</strong>——一个完全兼容Unix的简化系统。但Minix定位为“教学工具”，塔能鲍姆拒绝持续更新，引发用户不满。</p><p>同一时期，MIT的理查德·斯托曼（Richard Stallman）发起了<strong>GNU计划</strong>（“GNU不是Unix”的递归缩写），目标是开发一套完全自由的开源操作系统。他创造了GCC编译器、Bash shell等经典工具，并于1985年成立自由软件基金会（FSF）。但GNU始终缺少一个关键组件——<strong>内核</strong>（操作系统的核心大脑）。</p><p>直到1991年，一个芬兰学生的出现，填补了这个空白。</p><hr><h2 id="二、诞生：Linus的“懒人实验”如何改变世界（1991-1994）"><a href="#二、诞生：Linus的“懒人实验”如何改变世界（1991-1994）" class="headerlink" title="二、诞生：Linus的“懒人实验”如何改变世界（1991-1994）"></a>二、诞生：Linus的“懒人实验”如何改变世界（1991-1994）</h2><h3 id="2-1-从“不满Minix”到“为兴趣编码”"><a href="#2-1-从“不满Minix”到“为兴趣编码”" class="headerlink" title="2.1 从“不满Minix”到“为兴趣编码”"></a>2.1 从“不满Minix”到“为兴趣编码”</h3><p>1991年，芬兰赫尔辛基大学的学生**林纳斯·托瓦兹（Linus Torvalds）**贷款买了一台Intel 386电脑。他想运行Unix，但昂贵的商业版本买不起；想用Minix，却因塔能鲍姆拒绝升级功能而失望。于是，他决定自己写一个“能在386上跑的类Unix内核”。</p><p>Linus在早期的邮件中坦言：“我开发Linux的动机很简单——因为我很懒。我不想为了适配新硬件而重写整个系统，所以想做一个能自动适应的工具。”</p><h3 id="2-2-0-01版本：从“个人玩具”到“社区起点”"><a href="#2-2-0-01版本：从“个人玩具”到“社区起点”" class="headerlink" title="2.2 0.01版本：从“个人玩具”到“社区起点”"></a>2.2 0.01版本：从“个人玩具”到“社区起点”</h3><p>1991年9月，Linus将首个Linux内核（0.01版）上传到FTP服务器（ftp.funet.fi），并附上说明：“这是一个给386 AT兼容机的自由操作系统内核，目前只能运行GCC编译的程序，别指望它能做太多。”</p><p>最初的Linux非常简陋：仅支持386处理器、依赖Minix的工具链（如GCC）、没有网络功能。但它吸引了comp.os.minix论坛上的开发者——他们通过邮件列表讨论代码、提交补丁，甚至帮Linus解决“如何读取软盘”的问题。</p><h3 id="2-3-0-95版本：脱离Minix，拥抱GNU"><a href="#2-3-0-95版本：脱离Minix，拥抱GNU" class="headerlink" title="2.3 0.95版本：脱离Minix，拥抱GNU"></a>2.3 0.95版本：脱离Minix，拥抱GNU</h3><p>1992年，Linux内核迎来关键升级——<strong>0.95版</strong>。它首次支持内核模块（可动态加载的功能组件），并完全兼容GNU工具链（如Bash、GCC）。这意味着：用户终于能用一套完整的自由软件（GNU工具+Linux内核）搭建操作系统！</p><p>也是在这一年，Linus选择了<strong>GPLv2协议</strong>（通用公共许可证）。GPL的核心是“copyleft”（反版权）：任何基于GPL代码的修改或衍生作品，必须继续开源。这一选择彻底改变了开源生态——它避免了商业公司“拿走代码闭源盈利”的可能，确保了技术的共享与迭代。</p><hr><h2 id="三、成长：从“可用”到“统治”的技术演进（1995-2010）"><a href="#三、成长：从“可用”到“统治”的技术演进（1995-2010）" class="headerlink" title="三、成长：从“可用”到“统治”的技术演进（1995-2010）"></a>三、成长：从“可用”到“统治”的技术演进（1995-2010）</h2><h3 id="3-1-1-0版本：对标商业Unix的里程碑"><a href="#3-1-1-0版本：对标商业Unix的里程碑" class="headerlink" title="3.1 1.0版本：对标商业Unix的里程碑"></a>3.1 1.0版本：对标商业Unix的里程碑</h3><p>1995年，Linux 1.0正式发布。它支持多处理器（SMP）、完善了网络协议栈（TCP&#x2F;IP），并首次引入“进程调度改进”。此时的Linux已不再是“学生实验品”，而是能与AIX、Solaris等商业Unix正面竞争的操作系统。</p><h3 id="3-2-2-4与2-6内核：服务器领域的“霸主之路”"><a href="#3-2-2-4与2-6内核：服务器领域的“霸主之路”" class="headerlink" title="3.2 2.4与2.6内核：服务器领域的“霸主之路”"></a>3.2 2.4与2.6内核：服务器领域的“霸主之路”</h3><ul><li><p><strong>2001年，2.4内核</strong>：支持最大4TB内存、千兆网络和海量设备驱动，成为企业服务器的“标配”；</p></li><li></li></ul><p>  2003年，2.6内核</p><p>  ：引入革命性更新——</p><ul><li><strong>抢占式调度</strong>：让系统响应速度提升数倍（类似手机“多任务不卡顿”的原理）；</li><li><strong>EXT3文件系统</strong>：替代老旧的EXT2，支持日志功能，大幅降低数据丢失风险；</li><li><strong>内核模块热插拔</strong>：无需重启即可加载新硬件驱动。</li></ul><p>这些改进让Linux在服务器市场一路高歌。2008年，全球超50%的Web服务器运行Linux；2010年，这一比例突破70%。</p><h3 id="3-3-关键技术：从“能用”到“好用”的秘密"><a href="#3-3-关键技术：从“能用”到“好用”的秘密" class="headerlink" title="3.3 关键技术：从“能用”到“好用”的秘密"></a>3.3 关键技术：从“能用”到“好用”的秘密</h3><p>除了内核本身，Linux生态的技术创新同样惊人：</p><ul><li><strong>CFS调度器（2007）</strong>：完全公平调度算法，让CPU资源分配更智能；</li><li><strong>KVM虚拟化（2007）</strong>：将Linux内核变为虚拟机管理程序，开启了云计算时代；</li><li><strong>LXC容器（2013）</strong>：轻量级虚拟化技术，为Docker等容器工具奠定基础。</li></ul><hr><h2 id="四、生态与商业化：从“极客社区”到“全球引擎”（2010至今）"><a href="#四、生态与商业化：从“极客社区”到“全球引擎”（2010至今）" class="headerlink" title="四、生态与商业化：从“极客社区”到“全球引擎”（2010至今）"></a>四、生态与商业化：从“极客社区”到“全球引擎”（2010至今）</h2><h3 id="4-1-发行版繁荣：满足所有场景的“Linux全家桶”"><a href="#4-1-发行版繁荣：满足所有场景的“Linux全家桶”" class="headerlink" title="4.1 发行版繁荣：满足所有场景的“Linux全家桶”"></a>4.1 发行版繁荣：满足所有场景的“Linux全家桶”</h3><p>Linux的成功离不开“发行版”（将内核与工具、软件打包的完整系统）。不同发行版针对不同需求：</p><ul><li><strong>Red Hat Enterprise Linux（RHEL）</strong>：企业级稳定版，提供付费技术支持（全球金融、电信行业的“基础设施”）；</li><li><strong>Debian&#x2F;Ubuntu</strong>：面向个人用户，界面友好、软件丰富（全球桌面Linux市场份额第一）；</li><li><strong>CentOS Stream</strong>：RHEL的“上游测试版”，免费且兼容RHEL（中小企业的首选）；</li><li><strong>SUSE Linux Enterprise</strong>：欧洲企业市场的“隐形王者”（汽车、工业领域广泛应用）。</li></ul><h3 id="4-2-企业级爆发：云计算、AI的“隐形支柱”"><a href="#4-2-企业级爆发：云计算、AI的“隐形支柱”" class="headerlink" title="4.2 企业级爆发：云计算、AI的“隐形支柱”"></a>4.2 企业级爆发：云计算、AI的“隐形支柱”</h3><ul><li><strong>云计算</strong>：2023年数据显示，AWS、Azure、GCP三大公有云中，<strong>92%的虚拟机运行Linux</strong>。Linux的低成本、高稳定性完美契合云计算“弹性扩展”的需求；</li><li><strong>大数据</strong>：Hadoop、Spark等大数据框架默认基于Linux开发，全球超80%的数据中心依赖它；</li><li><strong>AI与边缘计算</strong>：TensorFlow、PyTorch等AI框架对Linux支持最佳，特斯拉自动驾驶、华为边缘计算设备均以Linux为核心。</li></ul><h3 id="4-3-移动与嵌入式：从手机到智能家居的“隐形玩家”"><a href="#4-3-移动与嵌入式：从手机到智能家居的“隐形玩家”" class="headerlink" title="4.3 移动与嵌入式：从手机到智能家居的“隐形玩家”"></a>4.3 移动与嵌入式：从手机到智能家居的“隐形玩家”</h3><ul><li><strong>Android</strong>：全球70%的智能手机运行Android，而它的底层正是Linux内核（经过谷歌深度定制）；</li><li><strong>物联网</strong>：路由器、智能音箱、工业传感器等设备中，Linux因开源、可裁剪的特性成为主流选择（如树莓派、华为鸿蒙的部分模块）。</li></ul><h3 id="4-4-社区治理：从“独裁者”到“协调者”的蜕变"><a href="#4-4-社区治理：从“独裁者”到“协调者”的蜕变" class="headerlink" title="4.4 社区治理：从“独裁者”到“协调者”的蜕变"></a>4.4 社区治理：从“独裁者”到“协调者”的蜕变</h3><p>早期Linux由Linus“一人决策”（他曾开玩笑说“我的权威来自代码写得好”）。但随着项目规模扩大，Linux基金会（2007年成立）接管了治理权：</p><ul><li>Linus专注于内核开发（仍担任“首席维护者”）；</li><li>社区通过邮件列表、代码审查、技术委员会协作；</li><li>企业贡献者（如谷歌、微软、英特尔）与个人开发者平起平坐。</li></ul><p>这种模式被称为“精英治理”——谁的代码贡献多、质量高，谁就有更大话语权。</p><hr><h2 id="五、影响与争议：改变世界的同时，挑战从未停止"><a href="#五、影响与争议：改变世界的同时，挑战从未停止" class="headerlink" title="五、影响与争议：改变世界的同时，挑战从未停止"></a>五、影响与争议：改变世界的同时，挑战从未停止</h2><h3 id="5-1-改变：打破垄断，定义“开源成功”"><a href="#5-1-改变：打破垄断，定义“开源成功”" class="headerlink" title="5.1 改变：打破垄断，定义“开源成功”"></a>5.1 改变：打破垄断，定义“开源成功”</h3><p>Linux的崛起彻底打破了Windows与Unix的垄断：</p><ul><li><strong>服务器领域</strong>：2023年全球超80%的服务器运行Linux；</li><li><strong>云计算领域</strong>：Linux是绝对主流（AWS EC2实例中Linux占比92%）；</li><li><strong>移动领域</strong>：Android让Linux进入数十亿用户的手机。</li></ul><p>更重要的是，Linux证明了“开放协作”能产出比商业公司更高效的技术——全球超2000万开发者曾为Linux内核提交代码，这种规模的合作在闭源世界中难以想象。</p><h3 id="5-2-争议：专利、控制权与安全的挑战"><a href="#5-2-争议：专利、控制权与安全的挑战" class="headerlink" title="5.2 争议：专利、控制权与安全的挑战"></a>5.2 争议：专利、控制权与安全的挑战</h3><ul><li><strong>专利纠纷</strong>：2003年SCO公司起诉IBM“Linux侵犯Unix版权”，虽最终败诉，但暴露了开源项目的法律风险；</li><li><strong>企业控制权</strong>：部分企业（如红帽被IBM收购）可能影响社区决策，引发“开源项目商业化过度”的担忧；</li><li><strong>安全漏洞</strong>：2014年“心脏出血”漏洞（Heartbleed）暴露了OpenSSL（Linux常用加密库）的安全隐患，凸显开源软件“众人维护”的双刃剑效应。</li></ul><hr><h2 id="结语：Linux的未来，仍是“开源”的未来"><a href="#结语：Linux的未来，仍是“开源”的未来" class="headerlink" title="结语：Linux的未来，仍是“开源”的未来"></a>结语：Linux的未来，仍是“开源”的未来</h2><p>从1991年一个学生的“懒人实验”，到2023年支撑全球数字基础设施的核心技术，Linux的故事不仅是一个操作系统的成长史，更是开源精神的胜利。它证明了：当技术足够优秀，当协作足够开放，普通人也能改变世界。</p><p>未来，随着AI、量子计算、边缘计算的发展，Linux或许会面临新的挑战，但其“开放、共享、协作”的基因，早已融入全球技术创新的血液。正如Linus所说：“Linux的成功不是因为我是天才，而是因为有无数比我更聪明的人愿意贡献代码。”</p><p>这，或许就是开源最动人的魅力。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
            <tag> 历史 </tag>
            
            <tag> 开源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的 Linux 学习计划书</title>
      <link href="/posts/de790f21/"/>
      <url>/posts/de790f21/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/27.png" alt="我的 Linux 学习计划书" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><h4 id="一、为什么是-Linux？"><a href="#一、为什么是-Linux？" class="headerlink" title="一、为什么是 Linux？"></a><strong>一、为什么是 Linux？</strong></h4><p>最近在工作中频繁接触服务器部署、自动化运维的需求，同事用一行 <code>ssh user@ip</code> 轻松连接远程机器时，我还在对着图形界面找「连接远程服务器」的按钮；看到运维同学用 <code>grep -i error /var/log/nginx/access.log</code> 秒定位日志错误，我还在手动翻页找关键词……</p><p>这些瞬间让我意识到：<strong>Linux 不再是「技术加分项」，而是「解决问题的刚需」</strong>。无论是想往运维、后端开发，还是云计算方向深耕，Linux 都是我绕不开的技术底座。</p><p>今天，我为自己写下这份学习计划——不为「速成」，只为「系统生长」，以及远离土木，珍爱生命。</p><p>学习仓库可见：<a href="https://linux.vbird.org/linux_basic/">鸟叔讲Linux</a>、<a href="https://github.com/dibingfa/flash-linux0.11-talk/blob/main/README.md">品读 Linux 0.11 核心代码</a></p><hr><h4 id="二、我的学习目标：「能用」-「掌控」"><a href="#二、我的学习目标：「能用」-「掌控」" class="headerlink" title="二、我的学习目标：「能用」--&gt;「掌控」"></a><strong>二、我的学习目标：「能用」--&gt;「掌控」</strong></h4><p>我不想成为「背命令的工具人」，而是希望：</p><ul><li><strong>短期（1-3个月）</strong>：能独立完成 Linux 服务器的日常操作（安装、配置、排障），写出可复用的 Shell 脚本。</li><li><strong>中期（3-6个月）</strong>：掌握系统级调优（进程&#x2F;内存&#x2F;磁盘管理）、服务部署（Nginx&#x2F;MySQL&#x2F;Docker），能解决 80% 常见故障。</li><li><strong>长期（6个月+）</strong>：形成「Linux 思维」——遇到问题时，能从内核机制、文件系统、网络协议等底层逻辑快速定位根源。</li></ul><hr><h4 id="三、分阶段执行计划：拆解「大目标」为「每日动作」"><a href="#三、分阶段执行计划：拆解「大目标」为「每日动作」" class="headerlink" title="三、分阶段执行计划：拆解「大目标」为「每日动作」"></a><strong>三、分阶段执行计划：拆解「大目标」为「每日动作」</strong></h4><h5 id="阶段一：打基础（第1-4周）——建立操作直觉"><a href="#阶段一：打基础（第1-4周）——建立操作直觉" class="headerlink" title="阶段一：打基础（第1-4周）——建立操作直觉"></a><strong>阶段一：打基础（第1-4周）——建立操作直觉</strong></h5><p><strong>核心任务</strong>：告别「复制粘贴命令」，理解每个操作的底层逻辑。</p><p>完成重点模块学习与突破：<strong>文件系统与命令行、权限与用户管理、进程与服务管理、文本处理</strong> 等。</p><p><strong>每日投入</strong>：1.5 小时（工作日晚上 + 周末上午）</p><p><strong>避坑提醒</strong>：不贪多！比如学 <code>grep</code> 时，先搞定 <code>-i</code>（忽略大小写）、<code>-n</code>（显示行号）、<code>-r</code>（递归搜索）三个参数，再学高级用法。</p><hr><h5 id="阶段二：练实战（第5-8周）——从「操作」到「解决问题」"><a href="#阶段二：练实战（第5-8周）——从「操作」到「解决问题」" class="headerlink" title="阶段二：练实战（第5-8周）——从「操作」到「解决问题」"></a><strong>阶段二：练实战（第5-8周）——从「操作」到「解决问题」</strong></h5><p><strong>核心任务</strong>：用 Linux 解决真实问题，培养「技术手感」。</p><p><strong>每日投入</strong>：2 小时（工作日晚上 + 周末全天）</p><p>根据阶段，按照鸟叔的课程安排，用个人博客记录学习笔记和重点模块操作心得，例如<strong>Shell 自动化命令、日志分析、远程协作</strong> 等。</p><p><strong>关键动作</strong>：根据课程内容，及时整理笔记（写成 Markdown 笔记），对于项目，用学过的工具链完整走一遍流程，记录遇到的问题和解决方法。</p><hr><h5 id="阶段三：深扎根（6个月后）——形成「技术自洽」"><a href="#阶段三：深扎根（6个月后）——形成「技术自洽」" class="headerlink" title="阶段三：深扎根（6个月后）——形成「技术自洽」"></a><strong>阶段三：深扎根（6个月后）——形成「技术自洽」</strong></h5><p><strong>核心任务</strong>：跳出「工具人」角色，理解 Linux 背后的设计哲学。</p><p><strong>长期动作</strong>：</p><ul><li><strong>读源码</strong>：选一个小工具（比如 <code>grep</code>），看它的源码（GitHub 搜 <code>coreutils</code>），理解它是如何实现文本搜索的。</li><li><strong>输出知识</strong>：把学习过程中的踩坑经验写成博客（就像现在这篇），用「费曼学习法」检验自己是否真正掌握。</li></ul><hr><h4 id="四、我的「防摆烂」机制"><a href="#四、我的「防摆烂」机制" class="headerlink" title="四、我的「防摆烂」机制"></a><strong>四、我的「防摆烂」机制</strong></h4><p>计划再完美，执行才是关键。我为这份计划配套了「防摆烂」措施：</p><ol><li><strong>固定学习时间</strong>：每周一&#x2F;三&#x2F;五 20:00-21:30 关掉手机，专注学习（用番茄钟 app 记录）。</li><li><strong>进度可视化</strong>：用 Excel 表格记录每周完成的任务，月底复盘「完成率」（低于 80% 就调整下周计划）。</li><li><strong>加入学习社群</strong>：报名参加线下 Linux 技术沙龙（比如 Meetup），和同好互相监督（小破烂地方最后也没去）。</li></ol><hr><h4 id="五、写在最后：和自己的一次对话"><a href="#五、写在最后：和自己的一次对话" class="headerlink" title="五、写在最后：和自己的一次对话"></a><strong>五、写在最后：和自己的一次对话</strong></h4><p>现在的我，可能连 <code>vim</code> 的基本操作都不熟，可能在 <code>systemctl</code> 启动服务时报错手忙脚乱，可能在写 Shell 脚本时卡壳半小时……但这些都没关系。</p><p>Linux 学习的本质，是<strong>用技术解决真实问题的能力</strong>。只要保持「每日进步一点点」的心态，3 个月后的我，一定能比今天更从容；6 个月后的我，或许能独当一面；1 年后的我，说不定能在技术社区输出自己的见解。</p><p><strong>今天，是改变的开始。</strong> 我会带着这份计划，一步一个脚印，走向更强大的自己。</p><img src="/img/PageCode/27-1.png" alt="架构图" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);">]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 自我规划 </tag>
            
            <tag> 学习计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 语言序列化和反序列化</title>
      <link href="/posts/6db2fe52/"/>
      <url>/posts/6db2fe52/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/25.png" alt="C 语言序列化和反序列化" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><h2 id="一、核心概念：什么是序列化与反序列化？"><a href="#一、核心概念：什么是序列化与反序列化？" class="headerlink" title="一、核心概念：什么是序列化与反序列化？"></a>一、核心概念：什么是序列化与反序列化？</h2><p>在计算机科学中，<strong>序列化（Serialization）</strong> 和 <strong>反序列化（Deserialization）</strong> 是数据持久化与传输的核心技术。</p><ul><li><strong>序列化</strong>：将内存中的数据结构（如结构体、数组等）转换为二进制字节流的过程。这个字节流可以存储到文件、数据库，或通过网络传输到其他设备。</li><li><strong>反序列化</strong>：将二进制字节流还原为内存中可用数据结构的过程，是序列化的逆操作。</li></ul><h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><ul><li><strong>数据持久化</strong>：将程序运行时的临时数据（如用户信息、配置参数）保存到文件，下次启动时恢复。</li><li><strong>网络通信</strong>：不同进程&#x2F;设备间通过网络传输数据时，需将数据转换为无格式的二进制流（避免文本协议的解析开销）。</li><li><strong>跨平台协作</strong>：确保不同系统（如Windows&#x2F;Linux）间数据格式兼容（需注意字节序问题）。</li></ul><hr><h2 id="二、C-语言实现序列化与反序列化"><a href="#二、C-语言实现序列化与反序列化" class="headerlink" title="二、C 语言实现序列化与反序列化"></a>二、C 语言实现序列化与反序列化</h2><p>C 语言作为面向过程的语言，没有内置的序列化库，但可以通过<strong>文件操作函数</strong>（如 <code>fwrite</code>&#x2F;<code>fread</code>）直接操作二进制数据，实现轻量级序列化。以下是完整实现与详细解析。</p><h3 id="1-数据结构定义"><a href="#1-数据结构定义" class="headerlink" title="1. 数据结构定义"></a>1. 数据结构定义</h3><p>首先定义需要序列化的目标结构体。本例以学生信息为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    char name[50];   // 姓名（固定长度字符串）</span><br><span class="line">    int age;         // 年龄（整型）</span><br><span class="line">    float score;     // 分数（浮点型）</span><br><span class="line">&#125; Student;</span><br></pre></td></tr></table></figure><p>选择固定长度的字符数组存储字符串，避免动态内存（如 <code>char* name</code>）带来的序列化复杂度（需额外记录指针地址和内存长度）。</p><h3 id="2-序列化函数实现"><a href="#2-序列化函数实现" class="headerlink" title="2. 序列化函数实现"></a>2. 序列化函数实现</h3><p>序列化函数的核心是将结构体内存块整体写入二进制文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void serialize(Student *student, const char *filename) &#123;</span><br><span class="line">    FILE *file = fopen(filename, &quot;wb&quot;);  // &quot;wb&quot;：二进制写模式（覆盖模式）</span><br><span class="line">    if (file == NULL) &#123;                  // 检查文件是否成功打开</span><br><span class="line">        perror(&quot;无法打开文件&quot;);           // 打印错误信息（如权限不足、路径错误）</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 写入操作：参数依次为 数据指针、单元素大小、元素数量、文件指针</span><br><span class="line">    fwrite(student, sizeof(Student), 1, file); </span><br><span class="line">    fclose(file);  // 关闭文件释放资源</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>关键函数</strong>：fwrite的作用是将内存中的一段连续字节写入文件。<ul><li>第一个参数 <code>student</code>：指向待写入数据的指针（结构体内存块的起始地址）。</li><li>第二个参数 <code>sizeof(Student)</code>：单次写入的元素大小（整个结构体的字节长度）。</li><li>第三个参数 <code>1</code>：仅写入1个这样的元素（即整个结构体）。</li><li>第四个参数 <code>file</code>：目标文件指针。</li></ul></li></ul><h3 id="3-反序列化函数实现"><a href="#3-反序列化函数实现" class="headerlink" title="3. 反序列化函数实现"></a>3. 反序列化函数实现</h3><p>反序列化函数从二进制文件中读取字节流，并还原为结构体实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void deserialize(Student *student, const char *filename) &#123;</span><br><span class="line">    FILE *file = fopen(filename, &quot;rb&quot;);  // &quot;rb&quot;：二进制读模式</span><br><span class="line">    if (file == NULL) &#123;</span><br><span class="line">        perror(&quot;无法打开文件&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 读取操作：参数含义与 fwrite 一致</span><br><span class="line">    fread(student, sizeof(Student), 1, file); </span><br><span class="line">    fclose(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>关键函数</strong>：<code>fread</code> 与 <code>fwrite</code> 是一对“镜像”函数，负责从文件读取字节流到内存。</li></ul><h3 id="4-主函数验证"><a href="#4-主函数验证" class="headerlink" title="4. 主函数验证"></a>4. 主函数验证</h3><p>主函数演示完整的序列化-反序列化流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    // 初始化原始数据</span><br><span class="line">    Student original_student;</span><br><span class="line">    strncpy(original_student.name, &quot;Alice&quot;, sizeof(original_student.name)-1);  // 避免字符串溢出</span><br><span class="line">    original_student.name[sizeof(original_student.name)-1] = &#x27;\0&#x27;;             // 手动添加终止符</span><br><span class="line">    original_student.age = 20;</span><br><span class="line">    original_student.score = 95.5;</span><br><span class="line"></span><br><span class="line">    // 序列化：写入文件</span><br><span class="line">    const char *filename = &quot;student_data.bin&quot;;</span><br><span class="line">    serialize(&amp;original_student, filename);</span><br><span class="line">    printf(&quot;序列化完成，数据已写入 %s</span><br><span class="line">&quot;, filename);  // 输出提示（无空行）</span><br><span class="line"></span><br><span class="line">    // 反序列化：读取文件</span><br><span class="line">    Student deserialized_student;</span><br><span class="line">    deserialize(&amp;deserialized_student, filename);</span><br><span class="line">    printf(&quot;反序列化完成，读取的数据如下：</span><br><span class="line">&quot;);</span><br><span class="line">    printf(&quot;姓名: %s</span><br><span class="line">&quot;, deserialized_student.name);   // 输出：Alice</span><br><span class="line">    printf(&quot;年龄: %d</span><br><span class="line">&quot;, deserialized_student.age);       // 输出：20</span><br><span class="line">    printf(&quot;分数: %.1f</span><br><span class="line">&quot;, deserialized_student.score);   // 输出：95.5</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意事项  ：</li><li>字符串赋值使用 <code>strncpy</code> 而非 <code>strcpy</code>，避免目标数组溢出（<code>name</code> 数组长度为50，需预留终止符空间）。</li><li>手动设置字符串终止符 <code>\0</code>，确保 <code>printf</code> 正确输出（<code>strncpy</code> 不会自动添加）。</li></ul><hr><h2 id="三、方案局限性与优化方向"><a href="#三、方案局限性与优化方向" class="headerlink" title="三、方案局限性与优化方向"></a>三、方案局限性与优化方向</h2><p>本例的实现适用于<strong>固定内存布局的结构体</strong>，但存在以下限制：</p><ol><li><strong>动态内存不友好</strong>：若结构体包含指针（如 <code>char* name</code>），<code>fwrite</code> 会仅保存指针地址而非实际字符串内容，反序列化后指针失效。</li><li><strong>跨平台兼容性</strong>：不同系统的字节序（大端&#x2F;小端）可能导致浮点数或整型数据解析错误（需手动处理字节序）。</li><li><strong>可读性差</strong>：二进制文件无法直接查看内容（需借助工具如 <code>hexdump</code>）。</li></ol><hr><h2 id="四、完整代码"><a href="#四、完整代码" class="headerlink" title="四、完整代码"></a>四、完整代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">// 定义学生结构体</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    char name[50];   // 姓名（固定长度）</span><br><span class="line">    int age;         // 年龄</span><br><span class="line">    float score;     // 分数</span><br><span class="line">&#125; Student;</span><br><span class="line"></span><br><span class="line">// 序列化：将结构体写入二进制文件</span><br><span class="line">void serialize(Student *student, const char *filename) &#123;</span><br><span class="line">    FILE *file = fopen(filename, &quot;wb&quot;);</span><br><span class="line">    if (!file) &#123;</span><br><span class="line">        perror(&quot;无法打开文件&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    fwrite(student, sizeof(Student), 1, file);  // 写入整个结构体内存块</span><br><span class="line">    fclose(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 反序列化：从二进制文件读取结构体</span><br><span class="line">void deserialize(Student *student, const char *filename) &#123;</span><br><span class="line">    FILE *file = fopen(filename, &quot;rb&quot;);</span><br><span class="line">    if (!file) &#123;</span><br><span class="line">        perror(&quot;无法打开文件&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    fread(student, sizeof(Student), 1, file);   // 读取整个结构体内存块</span><br><span class="line">    fclose(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 初始化原始数据</span><br><span class="line">    Student original = &#123;.name = &quot;Alice&quot;, .age = 20, .score = 95.5&#125;;  // C99指定初始化</span><br><span class="line"></span><br><span class="line">    // 序列化</span><br><span class="line">    const char *filename = &quot;student_data.bin&quot;;</span><br><span class="line">    serialize(&amp;original, filename);</span><br><span class="line">    printf(&quot;序列化完成，数据已写入 %s</span><br><span class="line">&quot;, filename);</span><br><span class="line"></span><br><span class="line">    // 反序列化</span><br><span class="line">    Student restored;</span><br><span class="line">    deserialize(&amp;restored, filename);</span><br><span class="line">    printf(&quot;反序列化结果：</span><br><span class="line">&quot;);</span><br><span class="line">    printf(&quot;姓名: %s</span><br><span class="line">年龄: %d</span><br><span class="line">分数: %.1f</span><br><span class="line">&quot;, restored.name, restored.age, restored.score);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C-Code </category>
          
          <category> Data Structures and Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 序列化和反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从进程调度到分布式系统的并发控制（Operating-Systems）</title>
      <link href="/posts/e308a55d/"/>
      <url>/posts/e308a55d/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/24.png" alt="从进程调度到分布式系统的并发控制（Operating-Systems）" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">操作系统学习</button><button type="button" class="tab">main.c</button><button type="button" class="tab">函数.h</button></div><div class="tab-contents"><div class="tab-item-content active"><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a><a href="/posts/e308a55d">操作系统</a></h3></div><div class="tab-item-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> Operating-Systems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 进程调度 </tag>
            
            <tag> 内存管理 </tag>
            
            <tag> 内存映射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从Socket编程到QUIC协议（Computer-Networking）</title>
      <link href="/posts/1d6b4bdc/"/>
      <url>/posts/1d6b4bdc/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/23.png" alt="从Socket编程到QUIC协议（Computer-Networking）" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">计算机网络学习</button><button type="button" class="tab">main.c</button><button type="button" class="tab">函数.h</button></div><div class="tab-contents"><div class="tab-item-content active"><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a><a href="/posts/1d6b4bdc"><strong>计算机网络</strong></a></h3></div><div class="tab-item-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> Computer-Networking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议栈 </tag>
            
            <tag> TCP/IP </tag>
            
            <tag> HTTP </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从逻辑门到多核CPU的硬件（Computer-Organization）</title>
      <link href="/posts/ed889906/"/>
      <url>/posts/ed889906/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/22.png" alt="从逻辑门到多核CPU的硬件（Computer-Organization）" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">计算机组成学习</button><button type="button" class="tab">main.c</button><button type="button" class="tab">函数.h</button></div><div class="tab-contents"><div class="tab-item-content active"><h3 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a><a href="/posts/ed889906"><strong>计算机组成</strong></a></h3></div><div class="tab-item-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> Computer-Organization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 冯·诺依曼架构 </tag>
            
            <tag> 硬件描述语言 </tag>
            
            <tag> Cache映射策略(LRU/FIFO) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从线性表到分布式（Data-Structures）</title>
      <link href="/posts/8ca7f13c/"/>
      <url>/posts/8ca7f13c/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/21.png" alt="从线性表到分布式（Data-Structures）" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">数据结构学习</button><button type="button" class="tab">main.c</button><button type="button" class="tab">函数.h</button></div><div class="tab-contents"><div class="tab-item-content active"><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><a href="/posts/8ca7f13c"><strong>数据结构</strong></a></h3></div><div class="tab-item-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> Data-Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法优化 </tag>
            
            <tag> 系列文章 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 伪代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再学习《C程序设计语言》</title>
      <link href="/posts/8527d974/"/>
      <url>/posts/8527d974/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/20.png" alt="《C程序设计语言》学习笔记" style="width: 80%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><p>笔者本身有C语言基础，所以对于旧书的整理较为简单，如果要入门还是得系统学习这门课打好基础，另外多打代码，多看大佬们写的开源项目。</p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">导言</button><button type="button" class="tab">类型、运算符与表达式</button><button type="button" class="tab">控制流</button><button type="button" class="tab">函数与程序结构</button><button type="button" class="tab">指针与数组</button><button type="button" class="tab">结构</button><button type="button" class="tab">输入与输出</button><button type="button" class="tab">UNIX系统接口</button></div><div class="tab-contents"><div class="tab-item-content active"><h1 id="一、导言"><a href="#一、导言" class="headerlink" title="一、导言"></a>一、导言</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── 核心概念</span><br><span class="line">│   ├── Hello World程序</span><br><span class="line">│   ├── 数据类型对比表</span><br><span class="line">└── └── 运算符优先级矩阵</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><h1 id="二、类型、运算符与表达式"><a href="#二、类型、运算符与表达式" class="headerlink" title="二、类型、运算符与表达式"></a>二、类型、运算符与表达式</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── 核心概念</span><br><span class="line">│   ├── 数据类型</span><br><span class="line">│   │   ├── 基本类型</span><br><span class="line">│   │   └── 派生类型</span><br><span class="line">│   ├── 运算符优先级表</span><br><span class="line">└── └── 表达式求值规则</span><br></pre></td></tr></table></figure><h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h2><table><thead><tr><th>类型</th><th>大小（字节）</th><th>范围</th><th>用途</th></tr></thead><tbody><tr><td><code>char</code></td><td>1</td><td><code>-128</code> ~ <code>127</code></td><td>字符&#x2F;小整数</td></tr><tr><td><code>short</code></td><td>2</td><td><code>-32768</code> ~ <code>32767</code></td><td>短整数</td></tr><tr><td><code>int</code></td><td>4</td><td><code>-2^31</code> ~ <code>2^31-1</code></td><td>通用整数</td></tr><tr><td><code>long</code></td><td>4&#x2F;8</td><td>平台依赖</td><td>大整数</td></tr><tr><td><code>float</code></td><td>4</td><td>约 <code>±3.4e38</code></td><td>单精度浮点数</td></tr><tr><td><code>double</code></td><td>8</td><td>约 <code>±1.8e308</code></td><td>双精度浮点数</td></tr></tbody></table><h2 id="2-运算符优先级"><a href="#2-运算符优先级" class="headerlink" title="2. 运算符优先级"></a>2. 运算符优先级</h2><table><thead><tr><th>优先级</th><th>运算符</th><th>结合性</th><th>示例</th></tr></thead><tbody><tr><td>1</td><td><code>()</code></td><td>左→右</td><td><code>(a + b) * c</code></td></tr><tr><td>2</td><td><code>* / %</code></td><td>左→右</td><td><code>10 / 3 * 2</code></td></tr><tr><td>3</td><td><code>+ -</code></td><td>左→右</td><td><code>a + b - c</code></td></tr><tr><td>4</td><td><code>&lt;&lt; &gt;&gt;</code></td><td>左→右</td><td><code>x &lt;&lt; 2</code>（左移2位）</td></tr><tr><td>5</td><td><code>&lt; &lt;= &gt; &gt;=</code></td><td>左→右</td><td><code>a &lt; b</code></td></tr><tr><td>6</td><td><code>== !=</code></td><td>左→右</td><td><code>x == y</code></td></tr><tr><td>7</td><td><code>&amp;</code></td><td>左→右</td><td><code>x &amp; y</code>（按位与）</td></tr><tr><td>8</td><td><code>^</code></td><td>左→右</td><td><code>x ^ y</code>（按位异或）</td></tr><tr><td>9</td><td>&#96;</td><td>&#96;</td><td>左→右</td></tr><tr><td>10</td><td><code>&amp;&amp;</code></td><td>左→右</td><td><code>a &amp;&amp; b</code>（逻辑与）</td></tr><tr><td>11</td><td>&#96;</td><td></td><td>&#96;</td></tr><tr><td>12</td><td><code>?:</code></td><td>右→左</td><td><code>a ? b : c</code>（三目运算符）</td></tr><tr><td>15</td><td><code>=</code></td><td>右→左</td><td><code>a = b = c</code></td></tr></tbody></table><h2 id="3-表达式求值"><a href="#3-表达式求值" class="headerlink" title="3. 表达式求值"></a>3. 表达式求值</h2><ul><li><strong>隐式类型转换规则</strong>：<ol><li>整型提升：<code>char</code>&#x2F;<code>short</code> → <code>int</code></li><li>算术运算中，较低类型转换为较高类型（如 <code>int + double → double</code>）</li></ol></li><li><strong>常见陷阱</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%d\n&quot;, 5 / 2);     // 输出2（整数除法）</span><br><span class="line">printf(&quot;%f\n&quot;, 5 / 2.0);   // 输出2.5（浮点除法）</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><h1 id="三、控制流"><a href="#三、控制流" class="headerlink" title="三、控制流"></a>三、控制流</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── 核心概念</span><br><span class="line">│   ├── 条件语句对比表</span><br><span class="line">│   ├── 循环结构决策树</span><br><span class="line">│   └── 跳转语句适用场景</span><br><span class="line">├── 重点与难点</span><br><span class="line">    ├── 循环变量作用域</span><br><span class="line">    └── 条件运算符优先级</span><br></pre></td></tr></table></figure><h2 id="1-条件语句"><a href="#1-条件语句" class="headerlink" title="1. 条件语句"></a>1. <strong>条件语句</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 基础if-else结构</span><br><span class="line">if (condition) &#123;</span><br><span class="line">    // 代码块1</span><br><span class="line">&#125; else if (condition2) &#123;</span><br><span class="line">    // 代码块2</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 默认代码块</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// switch-case结构</span><br><span class="line">switch (expression) &#123;</span><br><span class="line">    case value1:</span><br><span class="line">        // 代码块1</span><br><span class="line">        break;</span><br><span class="line">    case value2:</span><br><span class="line">        // 代码块2</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        // 默认代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关键点：<ul><li><code>switch</code>仅支持整型&#x2F;字符型表达式</li><li><code>case</code>穿透问题：需显式使用<code>break</code></li><li><code>default</code>可省略但建议保留</li></ul></li></ul><h2 id="2-循环结构"><a href="#2-循环结构" class="headerlink" title="2. 循环结构"></a>2. <strong>循环结构</strong></h2><h3 id="三大循环对比"><a href="#三大循环对比" class="headerlink" title="三大循环对比"></a><strong>三大循环对比</strong></h3><table><thead><tr><th align="center">循环类型</th><th align="center">适用场景</th><th align="center">初始化位置</th><th align="center">终止条件检查</th></tr></thead><tbody><tr><td align="center"><code>while</code></td><td align="center">未知循环次数</td><td align="center">循环体前</td><td align="center">每轮开始</td></tr><tr><td align="center"><code>for</code></td><td align="center">已知循环次数</td><td align="center">循环头内</td><td align="center">每轮开始</td></tr><tr><td align="center"><code>do-while</code></td><td align="center">至少执行一次</td><td align="center">循环体后</td><td align="center">每轮结束</td></tr></tbody></table><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 打印1~100的偶数（三种写法）</span><br><span class="line">// while版</span><br><span class="line">int i = 1;</span><br><span class="line">while (i &lt;= 100) &#123;</span><br><span class="line">    if (i % 2 == 0) printf(&quot;%d\n&quot;, i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// for版</span><br><span class="line">for (int i = 2; i &lt;= 100; i += 2) &#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// do-while版</span><br><span class="line">int j = 1;</span><br><span class="line">do &#123;</span><br><span class="line">    if (j % 2 == 0) printf(&quot;%d\n&quot;, j);</span><br><span class="line">    j++;</span><br><span class="line">&#125; while (j &lt;= 100);</span><br></pre></td></tr></table></figure><h2 id="3-跳转语句"><a href="#3-跳转语句" class="headerlink" title="3. 跳转语句"></a>3. <strong>跳转语句</strong></h2><table><thead><tr><th align="center">语句</th><th align="center">用途</th><th align="center">注意事项</th></tr></thead><tbody><tr><td align="center"><code>break</code></td><td align="center">终止当前循环&#x2F;switch</td><td align="center">仅跳出一层循环</td></tr><tr><td align="center"><code>continue</code></td><td align="center">跳过当前迭代</td><td align="center">需配合条件判断使用</td></tr><tr><td align="center"><code>goto</code></td><td align="center">跨越代码块（慎用）</td><td align="center">仅用于跳出深层循环或错误处理</td></tr></tbody></table></div><div class="tab-item-content"><h1 id="四、函数与程序结构"><a href="#四、函数与程序结构" class="headerlink" title="四、函数与程序结构"></a>四、函数与程序结构</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">├── 核心概念</span><br><span class="line">│   ├── 函数定义语法</span><br><span class="line">│   ├── 参数传递对比</span><br><span class="line">│   ├── 作用域层次图</span><br><span class="line">│   └── 递归决策树</span><br><span class="line">├── 高级主题</span><br><span class="line">│   ├── 头文件依赖管理</span><br><span class="line">│   └── 预处理器宏技巧</span><br><span class="line">└── 实战技巧</span><br><span class="line">    ├── 静态变量调试</span><br><span class="line">    └── 函数指针应用</span><br></pre></td></tr></table></figure><h2 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1. 函数定义"></a>1. <strong>函数定义</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 基础语法</span><br><span class="line">return_type function_name(parameter_list) &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">    return value;  // 可选（void类型无需返回）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 示例：计算两数之和</span><br><span class="line">int add(int a, int b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-参数传递"><a href="#2-参数传递" class="headerlink" title="2. 参数传递"></a>2. <strong>参数传递</strong></h2><table><thead><tr><th align="center">传递方式</th><th align="center">特性</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center"><strong>传值调用</strong></td><td align="center">形参是实参的副本，修改不影响原值</td><td align="center"><code>void swap(int a, int b) {...}</code></td></tr><tr><td align="center"><strong>传址调用</strong></td><td align="center">形参为指针，可直接修改实参值</td><td align="center"><code>void swap_ptr(int *a, int *b) {...}</code></td></tr></tbody></table><h2 id="3-作用域规则"><a href="#3-作用域规则" class="headerlink" title="3. 作用域规则"></a>3. <strong>作用域规则</strong></h2><table><thead><tr><th align="center">作用域类型</th><th align="center">生效范围</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center"><strong>局部变量</strong></td><td align="center">函数内部或代码块 <code>{}</code> 内</td><td align="center"><code>int local_var;</code></td></tr><tr><td align="center"><strong>全局变量</strong></td><td align="center">文件作用域（从声明到文件结束）</td><td align="center"><code>int global_var;</code></td></tr><tr><td align="center"><strong>静态变量</strong></td><td align="center">保持值跨函数调用</td><td align="center"><code>static int count = 0;</code></td></tr><tr><td align="center"><strong>外部变量</strong></td><td align="center">跨文件访问（需 <code>extern</code> 声明）</td><td align="center"><code>extern int ext_var;</code></td></tr></tbody></table><h2 id="4-递归"><a href="#4-递归" class="headerlink" title="4. 递归"></a>4. <strong>递归</strong></h2><ul><li><strong>核心要素</strong>：</li><li><strong>基线条件</strong>（Base Case）：终止递归的条件</li><li><strong>递归步骤</strong>：问题分解为更小子问题  </li><li><strong>示例</strong>：计算阶乘</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int factorial(int n) &#123;</span><br><span class="line">      if (n == 0) return 1;  // 基线条件</span><br><span class="line">    return n * factorial(n - 1);  // 递归调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-头文件与预处理器"><a href="#5-头文件与预处理器" class="headerlink" title="5. 头文件与预处理器"></a>5. <strong>头文件与预处理器</strong></h2><h3 id="头文件（-h）"><a href="#头文件（-h）" class="headerlink" title="头文件（.h）"></a><strong>头文件（<code>.h</code>）</strong></h3><ul><li><strong>用途</strong>：声明函数原型、宏定义、全局变量</li><li><strong>最佳实践</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// math_utils.h</span><br><span class="line">#ifndef MATH_UTILS_H</span><br><span class="line">#define MATH_UTILS_H</span><br><span class="line">int add(int a, int b);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="预处理器指令"><a href="#预处理器指令" class="headerlink" title="预处理器指令"></a><strong>预处理器指令</strong></h3><table><thead><tr><th align="center">指令</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center"><code>#include</code></td><td align="center">包含头文件</td></tr><tr><td align="center"><code>#define</code></td><td align="center">宏定义（常量或函数式宏）</td></tr><tr><td align="center"><code>#ifdef</code></td><td align="center">条件编译（平台适配）</td></tr></tbody></table><h2 id="6-静态与动态绑定"><a href="#6-静态与动态绑定" class="headerlink" title="6. 静态与动态绑定"></a>6. <strong>静态与动态绑定</strong></h2><table><thead><tr><th align="center">特性</th><th align="center">静态绑定（编译时）</th><th align="center">动态绑定（运行时）</th></tr></thead><tbody><tr><td align="center"><strong>函数调用</strong></td><td align="center">函数地址在编译时确定</td><td align="center">通过虚函数表（C++）实现</td></tr><tr><td align="center"><strong>变量访问</strong></td><td align="center">直接访问内存地址</td><td align="center">通过指针或引用间接访问</td></tr></tbody></table></div><div class="tab-item-content"><h1 id="五、指针与数组"><a href="#五、指针与数组" class="headerlink" title="五、指针与数组"></a>五、指针与数组</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── 核心概念</span><br><span class="line">│   ├── 指针运算规则</span><br><span class="line">│   ├── 数组内存模型</span><br><span class="line">│   └── 动态内存生命周期</span><br><span class="line">├── 重点与难点</span><br><span class="line">│   ├── 野指针预防</span><br><span class="line">│   └── 多级指针解析</span><br><span class="line">└── 代码实战</span><br><span class="line">    ├── 字符串操作</span><br><span class="line">    └── 数据结构实现</span><br></pre></td></tr></table></figure><h2 id="1-指针基础"><a href="#1-指针基础" class="headerlink" title="1. 指针基础"></a>1. <strong>指针基础</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 基础语法</span><br><span class="line">int *p;       // 指向int的指针</span><br><span class="line">int arr[5];   // 5个int的数组</span><br><span class="line">p = arr;      // 数组名即首元素地址</span><br></pre></td></tr></table></figure><h2 id="2-指针运算"><a href="#2-指针运算" class="headerlink" title="2. 指针运算"></a>2. <strong>指针运算</strong></h2><table><thead><tr><th>运算符</th><th>效果</th><th>示例</th></tr></thead><tbody><tr><td><code>p++</code></td><td>指向下一个元素（步长为元素大小）</td><td><code>int *p = arr; p++;</code></td></tr><tr><td><code>p + i</code></td><td>指向第<code>i</code>个元素</td><td><code>int *p = arr + 2;</code></td></tr><tr><td><code>*p</code></td><td>解引用（获取指针指向的值）</td><td><code>printf(&quot;%d&quot;, *p);</code></td></tr></tbody></table><h2 id="3-数组与指针的关系"><a href="#3-数组与指针的关系" class="headerlink" title="3. 数组与指针的关系"></a>3. <strong>数组与指针的关系</strong></h2><table><thead><tr><th>特性</th><th>数组</th><th>指针</th></tr></thead><tbody><tr><td>内存分配</td><td>编译时静态分配</td><td>运行时动态分配</td></tr><tr><td><code>sizeof</code>运算符</td><td>返回整个数组大小</td><td>返回指针大小（4&#x2F;8字节）</td></tr><tr><td><code>&amp;arr</code></td><td>数组首地址</td><td>指针变量地址</td></tr></tbody></table><h2 id="4-动态内存管理"><a href="#4-动态内存管理" class="headerlink" title="4. 动态内存管理"></a>4. <strong>动态内存管理</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 动态数组</span><br><span class="line">int *dyn_arr = malloc(5 * sizeof(int));  // 分配5个int空间</span><br><span class="line">dyn_arr[0] = 1;</span><br><span class="line">dyn_arr = realloc(dyn_arr, 10 * sizeof(int));  // 扩容</span><br><span class="line">free(dyn_arr);  // 释放内存</span><br><span class="line"></span><br><span class="line">// 常见陷阱</span><br><span class="line">int *invalid = malloc(sizeof(int) * 0);  // 分配0字节（未定义行为）</span><br></pre></td></tr></table></figure><h2 id="5-函数指针"><a href="#5-函数指针" class="headerlink" title="5. 函数指针"></a>5. <strong>函数指针</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 函数指针定义</span><br><span class="line">int (*func_ptr)(int, int);  // 指向返回int、接受两个int参数的函数</span><br><span class="line"></span><br><span class="line">// 使用示例</span><br><span class="line">int add(int a, int b) &#123; return a + b; &#125;</span><br><span class="line">func_ptr = add;</span><br><span class="line">printf(&quot;%d\n&quot;, func_ptr(3, 5));  // 输出8</span><br></pre></td></tr></table></figure><h2 id="6-多维数组与指针"><a href="#6-多维数组与指针" class="headerlink" title="6. 多维数组与指针"></a>6. <strong>多维数组与指针</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 二维数组与指针</span><br><span class="line">int matrix[3][3] = &#123;&#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8,9&#125;&#125;;</span><br><span class="line">int (*row_ptr)[3] = matrix;  // 指向第一行的指针</span><br><span class="line">printf(&quot;%d\n&quot;, *(*row_ptr + 1));  // 输出2（等价于 matrix[0][1]）</span><br></pre></td></tr></table></figure><h2 id="7-复杂声明解析"><a href="#7-复杂声明解析" class="headerlink" title="7. 复杂声明解析"></a>7. <strong>复杂声明解析</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 示例解析</span><br><span class="line">int *(*(*func)(int))[5];  // func是一个函数，参数为int，返回一个指针，该指针指向一个包含5个int指针的数组</span><br><span class="line"></span><br><span class="line">// 分解步骤：</span><br><span class="line">// 1. func 是一个函数，参数为int</span><br><span class="line">// 2. 返回值是一个指针（*func）</span><br><span class="line">// 3. 该指针指向一个数组（[5]）</span><br><span class="line">// 4. 数组元素是int指针（*(*func)(int))[5]</span><br></pre></td></tr></table></figure><h2 id="8-重点与难点"><a href="#8-重点与难点" class="headerlink" title="8. 重点与难点"></a>8. <strong>重点与难点</strong></h2><h3 id="1-指针与数组的本质区别"><a href="#1-指针与数组的本质区别" class="headerlink" title="1. 指针与数组的本质区别"></a>1. <strong>指针与数组的本质区别</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int arr[5] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">int *p = arr;</span><br><span class="line"></span><br><span class="line">printf(&quot;%zu\n&quot;, sizeof(arr));   // 输出20（数组总大小）</span><br><span class="line">printf(&quot;%zu\n&quot;, sizeof(p));     // 输出8（指针大小）</span><br></pre></td></tr></table></figure><h3 id="2-野指针与内存泄漏"><a href="#2-野指针与内存泄漏" class="headerlink" title="2. 野指针与内存泄漏"></a>2. <strong>野指针与内存泄漏</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int *invalid_ptr;</span><br><span class="line">*invalid_ptr = 5;  // 未初始化的野指针（崩溃风险）</span><br><span class="line"></span><br><span class="line">int *leak_ptr = malloc(sizeof(int));</span><br><span class="line">// 忘记free(leak_ptr)导致内存泄漏</span><br></pre></td></tr></table></figure><h3 id="3-多级指针操作"><a href="#3-多级指针操作" class="headerlink" title="3. 多级指针操作"></a>3. <strong>多级指针操作</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int *pa = &amp;a;</span><br><span class="line">int **ppa = &amp;pa;</span><br><span class="line">printf(&quot;%d\n&quot;, **ppa);  // 输出10</span><br></pre></td></tr></table></figure><h2 id="9-代码实战"><a href="#9-代码实战" class="headerlink" title="9.代码实战"></a>9.代码实战</h2><h3 id="1-字符串反转（指针版）"><a href="#1-字符串反转（指针版）" class="headerlink" title="1. 字符串反转（指针版）"></a>1. <strong>字符串反转（指针版）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void reverse(char *str) &#123;</span><br><span class="line">    char *end = str;</span><br><span class="line">    while (*end) end++;  // 移动到末尾</span><br><span class="line">    end--;               // 回退到最后一个字符</span><br><span class="line">    </span><br><span class="line">    while (str &lt; end) &#123;</span><br><span class="line">        char tmp = *str;</span><br><span class="line">        *str++ = *end;</span><br><span class="line">        *end-- = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char s[] = &quot;hello&quot;;</span><br><span class="line">    reverse(s);</span><br><span class="line">    printf(&quot;%s\n&quot;, s);  // 输出olleh</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-命令行参数解析"><a href="#2-命令行参数解析" class="headerlink" title="2. 命令行参数解析"></a>2. <strong>命令行参数解析</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    printf(&quot;程序名：%s\n&quot;, argv[0]);</span><br><span class="line">    for (int i = 1; i &lt; argc; i++) &#123;</span><br><span class="line">        printf(&quot;参数%d：%s\n&quot;, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><h1 id="六、结构"><a href="#六、结构" class="headerlink" title="六、结构"></a>六、结构</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── 核心概念</span><br><span class="line">│   ├── 结构体内存布局</span><br><span class="line">│   ├── 联合体重叠内存</span><br><span class="line">│   └── 位字段比特操作</span><br><span class="line">├── 高级主题</span><br><span class="line">│   ├── 结构体继承（C11 _Generic）</span><br><span class="line">│   └── 位操作宏定义</span><br><span class="line">└── 实战技巧</span><br><span class="line">    ├── 结构体序列化</span><br><span class="line">    └── 内存池分配</span><br></pre></td></tr></table></figure><h2 id="1-结构体（Struct）"><a href="#1-结构体（Struct）" class="headerlink" title="1. 结构体（Struct）"></a>1. <strong>结构体（Struct）</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 基础语法</span><br><span class="line">struct Point &#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 初始化</span><br><span class="line">struct Point p1 = &#123;3, 4&#125;;       // 直接初始化</span><br><span class="line">struct Point p2 = &#123;.y = 5, .x = 6&#125;; // 指定成员初始化</span><br></pre></td></tr></table></figure><h2 id="2-结构体高级特性"><a href="#2-结构体高级特性" class="headerlink" title="2. 结构体高级特性"></a>2. <strong>结构体高级特性</strong></h2><table><thead><tr><th>特性</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><strong>嵌套结构体</strong></td><td>结构体成员包含其他结构体</td><td><code>struct Rect { struct Point tl; struct Point br; };</code></td></tr><tr><td><strong>结构体指针</strong></td><td>通过指针访问成员</td><td><code>struct Point *ptr = &amp;p; ptr-&gt;x = 10;</code></td></tr><tr><td><strong>匿名结构体</strong></td><td>无标签的结构体（C11支持）</td><td><code>struct { int a; char b; } var;</code></td></tr></tbody></table><h2 id="3-联合体（Union）"><a href="#3-联合体（Union）" class="headerlink" title="3. 联合体（Union）"></a>3. <strong>联合体（Union）</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 内存共享特性</span><br><span class="line">union Data &#123;</span><br><span class="line">    int i;</span><br><span class="line">    float f;</span><br><span class="line">    char str[20];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">union Data data;</span><br><span class="line">data.i = 10;   // 写入int</span><br><span class="line">printf(&quot;%s\n&quot;, data.str); // 读取字符串（未定义行为，内存重叠）</span><br></pre></td></tr></table></figure><h2 id="4-位字段（Bit-Fields）"><a href="#4-位字段（Bit-Fields）" class="headerlink" title="4. 位字段（Bit Fields）"></a>4. <strong>位字段（Bit Fields）</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 紧凑存储（C语言扩展）</span><br><span class="line">struct Flags &#123;</span><br><span class="line">    unsigned is_active: 1;   // 1位布尔值</span><br><span class="line">    unsigned mode: 3;        // 3位标志位</span><br><span class="line">    unsigned reserved: 4;    // 保留位</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-重点与难点"><a href="#5-重点与难点" class="headerlink" title="5.重点与难点"></a>5.<strong>重点与难点</strong></h2><h3 id="1-内存对齐规则"><a href="#1-内存对齐规则" class="headerlink" title="1. 内存对齐规则"></a>1. <strong>内存对齐规则</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 示例：结构体内存布局</span><br><span class="line">struct Example &#123;</span><br><span class="line">    char c;   // 1字节</span><br><span class="line">    int i;    // 4字节（总占用8字节，对齐到4的倍数）</span><br><span class="line">&#125;;</span><br><span class="line">// sizeof(struct Example) = 8</span><br></pre></td></tr></table></figure><h3 id="2-联合体大小计算"><a href="#2-联合体大小计算" class="headerlink" title="2. 联合体大小计算"></a>2. <strong>联合体大小计算</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">union U &#123;</span><br><span class="line">    char c;   // 1字节</span><br><span class="line">    int i;    // 4字节（联合体大小取最大成员）</span><br><span class="line">&#125;;</span><br><span class="line">// sizeof(union U) = 4</span><br></pre></td></tr></table></figure><h3 id="3-结构体传参陷阱"><a href="#3-结构体传参陷阱" class="headerlink" title="3. 结构体传参陷阱"></a>3. <strong>结构体传参陷阱</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 错误写法：传值拷贝效率低</span><br><span class="line">void process(struct Point p) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">// 正确写法：传指针</span><br><span class="line">void process(struct Point *p) &#123; ... &#125;</span><br></pre></td></tr></table></figure><h2 id="6-代码实战"><a href="#6-代码实战" class="headerlink" title="6.代码实战"></a>6.<strong>代码实战</strong></h2><h3 id="1-复杂结构体操作"><a href="#1-复杂结构体操作" class="headerlink" title="1. 复杂结构体操作"></a>1. <strong>复杂结构体操作</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    char name[20];</span><br><span class="line">    int age;</span><br><span class="line">    double salary;</span><br><span class="line">&#125; Employee;</span><br><span class="line"></span><br><span class="line">// 函数返回结构体</span><br><span class="line">Employee create_employee(const char *name, int age, double salary) &#123;</span><br><span class="line">    Employee emp;</span><br><span class="line">    strcpy(emp.name, name);</span><br><span class="line">    emp.age = age;</span><br><span class="line">    emp.salary = salary;</span><br><span class="line">    return emp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Employee e = create_employee(&quot;Alice&quot;, 30, 5000.0);</span><br><span class="line">    printf(&quot;Employee: %s, %d, %.2f\n&quot;, e.name, e.age, e.salary);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-位字段应用"><a href="#2-位字段应用" class="headerlink" title="2. 位字段应用"></a>2. <strong>位字段应用</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">struct Bits &#123;</span><br><span class="line">    unsigned int flag_a: 1;</span><br><span class="line">    unsigned int flag_b: 1;</span><br><span class="line">    unsigned int value: 6;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    struct Bits bits;</span><br><span class="line">    bits.flag_a = 1;</span><br><span class="line">    bits.flag_b = 0;</span><br><span class="line">    bits.value = 42;</span><br><span class="line">    printf(&quot;Binary: %08x\n&quot;, *(unsigned int*)&amp;bits); // 输出二进制形式</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><h1 id="七、输入与输出"><a href="#七、输入与输出" class="headerlink" title="七、输入与输出"></a>七、输入与输出</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── 核心概念</span><br><span class="line">│   ├── 标准流关系图</span><br><span class="line">│   ├── 缓冲类型对比表</span><br><span class="line">│   └── 文件模式决策树</span><br><span class="line">├── 重点与难点</span><br><span class="line">│   ├── 格式化安全陷阱</span><br><span class="line">│   └── 二进制/文本模式差异</span><br><span class="line">└── 代码实战</span><br><span class="line">    ├── 高效文件拷贝</span><br><span class="line">    └── 自定义格式化输出</span><br></pre></td></tr></table></figure><h2 id="1-文件操作基础"><a href="#1-文件操作基础" class="headerlink" title="1. 文件操作基础"></a>1. <strong>文件操作基础</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 文件打开模式</span><br><span class="line">FILE *fp = fopen(&quot;file.txt&quot;, &quot;r&quot;);  // r=读, w=写, a=追加, +号表示读写</span><br><span class="line">fclose(fp);                        // 必须关闭文件（防止资源泄漏）</span><br></pre></td></tr></table></figure><h2 id="2-格式化I-O"><a href="#2-格式化I-O" class="headerlink" title="2. 格式化I&#x2F;O"></a>2. <strong>格式化I&#x2F;O</strong></h2><table><thead><tr><th>函数</th><th>用途</th><th>示例</th></tr></thead><tbody><tr><td><code>printf</code></td><td>格式化输出到标准输出</td><td><code>printf(&quot;%d %f&quot;, 10, 3.14);</code></td></tr><tr><td><code>scanf</code></td><td>格式化输入从标准输入</td><td><code>scanf(&quot;%d&quot;, &amp;num);</code></td></tr><tr><td><code>fprintf</code></td><td>格式化输出到文件</td><td><code>fprintf(fp, &quot;Name: %s&quot;, name);</code></td></tr><tr><td><code>fscanf</code></td><td>格式化输入从文件</td><td><code>fscanf(fp, &quot;%d&quot;, &amp;num);</code></td></tr></tbody></table><h2 id="3-缓冲机制"><a href="#3-缓冲机制" class="headerlink" title="3. 缓冲机制"></a>3. <strong>缓冲机制</strong></h2><table><thead><tr><th>缓冲类型</th><th>特性</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>全缓冲</strong></td><td>数据填满缓冲区后一次性写入</td><td>文件操作（默认）</td></tr><tr><td><strong>行缓冲</strong></td><td>遇到换行符时刷新缓冲区</td><td>终端交互（如<code>stdout</code>）</td></tr><tr><td><strong>无缓冲</strong></td><td>数据立即写入（不推荐）</td><td>错误日志（<code>stderr</code>）</td></tr></tbody></table><h2 id="4-重点与难点"><a href="#4-重点与难点" class="headerlink" title="4.重点与难点"></a>4.<strong>重点与难点</strong></h2><h3 id="1-格式化字符串安全"><a href="#1-格式化字符串安全" class="headerlink" title="1. 格式化字符串安全"></a>1. <strong>格式化字符串安全</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 错误示例：缓冲区溢出</span><br><span class="line">char buf[10];</span><br><span class="line">scanf(&quot;%s&quot;, buf);  // 若输入超过9字符，导致越界</span><br><span class="line"></span><br><span class="line">// 正确写法：限制输入长度</span><br><span class="line">scanf(&quot;%9s&quot;, buf);  // 最多读取9字符（留1字节给&#x27;\0&#x27;）</span><br></pre></td></tr></table></figure><h3 id="2-二进制与文本模式区别"><a href="#2-二进制与文本模式区别" class="headerlink" title="2. 二进制与文本模式区别"></a>2. <strong>二进制与文本模式区别</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 文本模式（默认）：自动转换换行符</span><br><span class="line">// Windows：&#x27;\n&#x27; ↔ &#x27;\r\n&#x27;</span><br><span class="line">// Linux/macOS：无转换</span><br><span class="line"></span><br><span class="line">// 二进制模式：保留原始数据</span><br><span class="line">FILE *fp_bin = fopen(&quot;data.bin&quot;, &quot;wb&quot;);  // 写二进制</span><br></pre></td></tr></table></figure><h3 id="3-文件指针操作"><a href="#3-文件指针操作" class="headerlink" title="3. 文件指针操作"></a>3. <strong>文件指针操作</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 文件定位</span><br><span class="line">fseek(fp, 10, SEEK_SET);  // 移动到文件开头+10字节</span><br><span class="line">long pos = ftell(fp);     // 获取当前位置</span><br><span class="line">rewind(fp);               // 移动到文件开头</span><br></pre></td></tr></table></figure><h2 id="5-代码实战"><a href="#5-代码实战" class="headerlink" title="5.代码实战"></a>5.<strong>代码实战</strong></h2><h3 id="1-文件复制（高效二进制模式）"><a href="#1-文件复制（高效二进制模式）" class="headerlink" title="1. 文件复制（高效二进制模式）"></a>1. <strong>文件复制（高效二进制模式）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    FILE *src = fopen(&quot;input.txt&quot;, &quot;rb&quot;);</span><br><span class="line">    FILE *dst = fopen(&quot;output.txt&quot;, &quot;wb&quot;);</span><br><span class="line">    </span><br><span class="line">    if (!src || !dst) &#123;</span><br><span class="line">        perror(&quot;File open failed&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    char buffer[4096];</span><br><span class="line">    size_t n;</span><br><span class="line">    while ((n = fread(buffer, 1, sizeof(buffer), src)) &gt; 0) &#123;</span><br><span class="line">        fwrite(buffer, 1, n, dst);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fclose(src);</span><br><span class="line">    fclose(dst);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-自定义格式化输出"><a href="#2-自定义格式化输出" class="headerlink" title="2. 自定义格式化输出"></a>2. <strong>自定义格式化输出</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    double pi = 3.1415926535;</span><br><span class="line">    printf(&quot;Default: %f\n&quot;, pi);       // 3.141593（默认6位小数）</span><br><span class="line">    printf(&quot;Precision: %.3f\n&quot;, pi);   // 3.142（保留3位小数）</span><br><span class="line">    printf(&quot;Hex: %a\n&quot;, pi);           // 0x1.921fb54442d18p+1（十六进制浮点）</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><h1 id="八、UNIX系统接口"><a href="#八、UNIX系统接口" class="headerlink" title="八、UNIX系统接口"></a>八、UNIX系统接口</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── 核心概念</span><br><span class="line">│   ├── 系统调用分类</span><br><span class="line">│   ├── 进程生命周期图</span><br><span class="line">│   └── 文件描述符状态机</span><br><span class="line">├── 重点与难点</span><br><span class="line">│   ├── fork返回值处理</span><br><span class="line">│   └── 僵尸进程预防</span><br><span class="line">└── 代码实战</span><br><span class="line">    ├── Shell原理实现</span><br><span class="line">    └── 管道通信范例</span><br></pre></td></tr></table></figure><h2 id="1-系统调用基础"><a href="#1-系统调用基础" class="headerlink" title="1. 系统调用基础"></a>1. <strong>系统调用基础</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 文件操作示例</span><br><span class="line">int fd = open(&quot;file.txt&quot;, O_RDONLY);  // 打开文件</span><br><span class="line">char buf[100];</span><br><span class="line">read(fd, buf, 100);                 // 读取数据</span><br><span class="line">write(STDOUT_FILENO, buf, 100);     // 输出到标准输出</span><br><span class="line">close(fd);                          // 关闭文件</span><br></pre></td></tr></table></figure><h2 id="2-进程控制"><a href="#2-进程控制" class="headerlink" title="2. 进程控制"></a>2. <strong>进程控制</strong></h2><table><thead><tr><th>函数</th><th>用途</th><th>示例</th></tr></thead><tbody><tr><td><code>fork()</code></td><td>创建子进程</td><td><code>pid_t pid = fork();</code></td></tr><tr><td><code>exec()</code>系列</td><td>替换当前进程映像</td><td><code>execl(&quot;/bin/ls&quot;, &quot;ls&quot;, NULL);</code></td></tr><tr><td><code>wait()</code></td><td>等待子进程结束</td><td><code>wait(NULL);</code></td></tr></tbody></table><h2 id="3-文件描述符管理"><a href="#3-文件描述符管理" class="headerlink" title="3. 文件描述符管理"></a>3. <strong>文件描述符管理</strong></h2><ul><li><strong>标准流与文件描述符</strong>：<ul><li><code>stdin</code> → <code>0</code></li><li><code>stdout</code> → <code>1</code></li><li><code>stderr</code> → <code>2</code></li></ul></li><li><strong>文件描述符特性</strong>：<ul><li>默认继承性（父子进程共享）</li><li>需手动关闭（避免泄漏）</li></ul></li></ul><h2 id="4-重点与难点"><a href="#4-重点与难点" class="headerlink" title="4.重点与难点"></a>4.<strong>重点与难点</strong></h2><h3 id="1-fork-的返回值处理"><a href="#1-fork-的返回值处理" class="headerlink" title="1. fork()的返回值处理"></a>1. <strong>fork()的返回值处理</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pid_t pid = fork();</span><br><span class="line">if (pid &lt; 0) &#123;</span><br><span class="line">    perror(&quot;fork failed&quot;);  // 错误处理</span><br><span class="line">&#125; else if (pid == 0) &#123;</span><br><span class="line">    // 子进程代码</span><br><span class="line">    execl(&quot;/bin/date&quot;, &quot;date&quot;, NULL);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 父进程代码</span><br><span class="line">    wait(NULL);  // 等待子进程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-僵尸进程与孤儿进程"><a href="#2-僵尸进程与孤儿进程" class="headerlink" title="2. 僵尸进程与孤儿进程"></a>2. <strong>僵尸进程与孤儿进程</strong></h3><ul><li><strong>僵尸进程</strong>：子进程退出后，父进程未调用<code>wait()</code>回收状态。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 避免僵尸进程：父进程回收子进程</span><br><span class="line">pid_t pid = fork();</span><br><span class="line">if (pid == 0) exit(0);  // 子进程立即退出</span><br><span class="line">wait(NULL);             // 父进程等待</span><br></pre></td></tr></table></figure><ul><li><strong>孤儿进程</strong>：父进程先于子进程退出，子进程由<code>init</code>接管。</li></ul><h3 id="3-文件描述符泄漏"><a href="#3-文件描述符泄漏" class="headerlink" title="3. 文件描述符泄漏"></a>3. <strong>文件描述符泄漏</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int fd = open(&quot;file.txt&quot;, O_RDONLY);</span><br><span class="line">// 未调用close(fd); → 资源泄漏</span><br></pre></td></tr></table></figure><h2 id="5-代码实战"><a href="#5-代码实战" class="headerlink" title="5.代码实战"></a>5.<strong>代码实战</strong></h2><h3 id="1-简单Shell实现"><a href="#1-简单Shell实现" class="headerlink" title="1. 简单Shell实现"></a>1. <strong>简单Shell实现</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char cmd[100];</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        printf(&quot;&gt; &quot;);</span><br><span class="line">        fgets(cmd, 100, stdin);</span><br><span class="line">        cmd[strcspn(cmd, &quot;\n&quot;)] = 0;  // 去除换行符</span><br><span class="line">        </span><br><span class="line">        pid_t pid = fork();</span><br><span class="line">        if (pid == 0) &#123;</span><br><span class="line">            execlp(cmd, cmd, NULL);</span><br><span class="line">            perror(&quot;exec failed&quot;);  // 仅当execlp失败时执行</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            wait(NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-管道（Pipe）通信"><a href="#2-管道（Pipe）通信" class="headerlink" title="2. 管道（Pipe）通信"></a>2. <strong>管道（Pipe）通信</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int pipefd[2];</span><br><span class="line">    pipe(pipefd);  // 创建管道</span><br><span class="line">    </span><br><span class="line">    pid_t pid = fork();</span><br><span class="line">    if (pid == 0) &#123;</span><br><span class="line">        close(pipefd[0]);  // 子进程关闭读端</span><br><span class="line">        write(pipefd[1], &quot;Hello from child!&quot;, 20);</span><br><span class="line">        close(pipefd[1]);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        close(pipefd[1]);  // 父进程关闭写端</span><br><span class="line">        char buf[20];</span><br><span class="line">        read(pipefd[0], buf, 20);</span><br><span class="line">        printf(&quot;Parent received: %s\n&quot;, buf);</span><br><span class="line">        close(pipefd[0]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> C-Code </category>
          
          <category> Practical System Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 函数 </tag>
            
            <tag> Data-Structures </tag>
            
            <tag> Computer-Organization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现二叉搜索树（BST）：从增删改查到三种遍历的完整解析</title>
      <link href="/posts/6f84ed1e/"/>
      <url>/posts/6f84ed1e/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/19.png" alt="C语言实现二叉搜索树（BST）：从增删改查到三种遍历的完整解析" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>二叉搜索树（Binary Search Tree, BST）是一种经典的动态数据结构，因其高效的查找、插入和删除操作（平均时间复杂度O(logn)），广泛应用于数据库索引、缓存系统、排序算法等领域。本文将基于C语言实现一个完整的BST，详细解析其核心原理、关键操作及三种遍历方式，并通过测试用例验证功能正确性。</p><hr><h2 id="一、BST基础概念：定义与核心性质"><a href="#一、BST基础概念：定义与核心性质" class="headerlink" title="一、BST基础概念：定义与核心性质"></a>一、BST基础概念：定义与核心性质</h2><h3 id="1-1-BST的定义"><a href="#1-1-BST的定义" class="headerlink" title="1.1 BST的定义"></a>1.1 BST的定义</h3><p>二叉搜索树（BST）是一种特殊的二叉树，满足以下性质：</p><ul><li><strong>左子树性质</strong>：对于任意节点，其左子树中所有节点的键值均小于该节点的键值。</li><li><strong>右子树性质</strong>：对于任意节点，其右子树中所有节点的键值均大于或等于该节点的键值（注：部分定义要求严格大于，本文采用“大于等于”以支持重复值处理）。</li><li><strong>递归结构</strong>：左子树和右子树本身也是BST。</li></ul><h3 id="1-2-BST与普通二叉树的区别"><a href="#1-2-BST与普通二叉树的区别" class="headerlink" title="1.2 BST与普通二叉树的区别"></a>1.2 BST与普通二叉树的区别</h3><p>普通二叉树仅要求节点最多有两个子节点，而BST通过键值的有序性赋予了更强大的功能：</p><ul><li><strong>高效查找</strong>：利用有序性，可通过比较键值快速缩小搜索范围。</li><li><strong>动态排序</strong>：插入和删除操作自动维护有序性，无需额外排序步骤。</li><li><strong>范围查询</strong>：可高效查询某个区间内的所有键值（如“查找所有大于10且小于50的键”）。</li></ul><hr><h2 id="二、节点结构设计：为什么选择int类型？"><a href="#二、节点结构设计：为什么选择int类型？" class="headerlink" title="二、节点结构设计：为什么选择int类型？"></a>二、节点结构设计：为什么选择int类型？</h2><h3 id="2-1-TreeNode结构体解析"><a href="#2-1-TreeNode结构体解析" class="headerlink" title="2.1 TreeNode结构体解析"></a>2.1 TreeNode结构体解析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef int KeyType;  // 键类型为整数</span><br><span class="line"></span><br><span class="line">typedef struct node &#123;</span><br><span class="line">    KeyType key;          // 节点键值（唯一标识）</span><br><span class="line">    struct node *left;    // 左子树指针（指向更小键值的子树）</span><br><span class="line">    struct node *right;   // 右子树指针（指向更大或相等的子树）</span><br><span class="line">&#125; TreeNode;</span><br></pre></td></tr></table></figure><ul><li><strong>key</strong>：存储节点的唯一键值，是BST有序性的核心依据。</li><li><strong>left&#x2F;right</strong>：分别指向左子树和右子树的根节点，构成递归结构。</li></ul><h3 id="2-2-为什么选择int类型？"><a href="#2-2-为什么选择int类型？" class="headerlink" title="2.2 为什么选择int类型？"></a>2.2 为什么选择int类型？</h3><p>当前代码中<code>KeyType</code>被定义为<code>int</code>，这是为了简化实现并满足大多数基础场景的需求。实际应用中，可通过以下方式扩展为泛型：</p><ul><li>使用<code>void*</code>类型存储任意类型的键值。</li><li>添加一个比较函数指针（如<code>int (*compare)(const void*, const void*)</code>），用于自定义键值的比较逻辑（如字符串、结构体等）。</li></ul><hr><h2 id="三、增删改查实现：核心操作的逻辑与细节"><a href="#三、增删改查实现：核心操作的逻辑与细节" class="headerlink" title="三、增删改查实现：核心操作的逻辑与细节"></a>三、增删改查实现：核心操作的逻辑与细节</h2><h3 id="3-1-插入操作（Insert）：保持BST性质的关键"><a href="#3-1-插入操作（Insert）：保持BST性质的关键" class="headerlink" title="3.1 插入操作（Insert）：保持BST性质的关键"></a>3.1 插入操作（Insert）：保持BST性质的关键</h3><p>插入操作的目标是将新节点添加到正确位置，同时维持BST的有序性。当前代码采用<strong>递归实现</strong>，逻辑如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 辅助函数：递归插入节点（返回插入后的子树根）</span><br><span class="line">static TreeNode *bst_insert_helper(TreeNode *node, KeyType key, bool *inserted) &#123;</span><br><span class="line">    if (!node) &#123;  // 空位置插入新节点</span><br><span class="line">        TreeNode *new_node = (TreeNode *)malloc(sizeof(TreeNode));</span><br><span class="line">        new_node-&gt;key = key;</span><br><span class="line">        new_node-&gt;left = new_node-&gt;right = NULL;</span><br><span class="line">        *inserted = true;  // 标记插入成功</span><br><span class="line">        return new_node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (key == node-&gt;key) &#123;  // 键已存在，插入失败</span><br><span class="line">        *inserted = false;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (key &lt; node-&gt;key) &#123;  // 插入左子树</span><br><span class="line">        node-&gt;left = bst_insert_helper(node-&gt;left, key, inserted);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;  // 插入右子树（允许等于，取决于需求）</span><br><span class="line">        node-&gt;right = bst_insert_helper(node-&gt;right, key, inserted);</span><br><span class="line">    &#125;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关键逻辑："><a href="#关键逻辑：" class="headerlink" title="关键逻辑："></a>关键逻辑：</h4><ul><li><strong>终止条件</strong>：当当前节点为空时，创建新节点并插入。</li><li><strong>键值比较</strong>：若键已存在（<code>key == node-&gt;key</code>），标记插入失败（当前代码忽略重复键）；若键更小，递归插入左子树；否则递归插入右子树。</li><li><strong>保持有序性</strong>：通过递归路径确保新节点最终位于正确位置，维持BST的左小右大性质。</li></ul><h4 id="测试验证："><a href="#测试验证：" class="headerlink" title="测试验证："></a>测试验证：</h4><p>插入序列<code>&#123;50, 30, 20, 40, 70, 60, 80&#125;</code>后，BST的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     50</span><br><span class="line">   /    \</span><br><span class="line">  30     70</span><br><span class="line"> /  \   /  \</span><br><span class="line">20  40 60   80</span><br></pre></td></tr></table></figure><h3 id="3-2-查找操作（Search）：利用有序性快速定位"><a href="#3-2-查找操作（Search）：利用有序性快速定位" class="headerlink" title="3.2 查找操作（Search）：利用有序性快速定位"></a>3.2 查找操作（Search）：利用有序性快速定位</h3><p>查找操作通过比较键值与当前节点的键值，逐步缩小搜索范围。当前代码提供递归实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 辅助函数：递归搜索节点</span><br><span class="line">static TreeNode *bst_search_helper(TreeNode *node, KeyType key) &#123;</span><br><span class="line">    if (!node) return NULL;  // 空树或未找到</span><br><span class="line">    if (key == node-&gt;key) &#123;</span><br><span class="line">        return node;  // 找到目标节点</span><br><span class="line">    &#125;</span><br><span class="line">    else if (key &lt; node-&gt;key) &#123;</span><br><span class="line">        return bst_search_helper(node-&gt;left, key);  // 搜索左子树</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return bst_search_helper(node-&gt;right, key);  // 搜索右子树</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度分析："><a href="#时间复杂度分析：" class="headerlink" title="时间复杂度分析："></a>时间复杂度分析：</h4><ul><li><strong>平均情况</strong>：O(logn)（树高为logn，每次比较缩小一半范围）。</li><li><strong>最坏情况</strong>：O(n)（树退化为链表，如插入序列为<code>&#123;1,2,3,4,...&#125;</code>）。</li></ul><h3 id="3-3-删除操作（Delete）：维持树结构的核心挑战"><a href="#3-3-删除操作（Delete）：维持树结构的核心挑战" class="headerlink" title="3.3 删除操作（Delete）：维持树结构的核心挑战"></a>3.3 删除操作（Delete）：维持树结构的核心挑战</h3><p>删除操作需处理三种情况，并确保删除后树仍满足BST性质：</p><h4 id="情况1：节点无子节点（叶子节点）"><a href="#情况1：节点无子节点（叶子节点）" class="headerlink" title="情况1：节点无子节点（叶子节点）"></a>情况1：节点无子节点（叶子节点）</h4><p>直接删除节点，父节点对应指针置空。</p><h4 id="情况2：节点只有一个子节点"><a href="#情况2：节点只有一个子节点" class="headerlink" title="情况2：节点只有一个子节点"></a>情况2：节点只有一个子节点</h4><p>用子节点替换当前节点，父节点指针指向子节点。</p><h4 id="情况3：节点有两个子节点"><a href="#情况3：节点有两个子节点" class="headerlink" title="情况3：节点有两个子节点"></a>情况3：节点有两个子节点</h4><p>找到右子树的最小节点（后继节点），用其键值替换当前节点的键值，然后删除右子树中的最小节点（避免破坏BST性质）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 辅助函数：递归删除节点（返回删除后的子树根）</span><br><span class="line">static TreeNode *bst_delete_helper(TreeNode *node, KeyType key, bool *deleted) &#123;</span><br><span class="line">    if (!node) &#123;  // 未找到目标节点</span><br><span class="line">        *deleted = false;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (key &lt; node-&gt;key) &#123;  // 目标在左子树</span><br><span class="line">        node-&gt;left = bst_delete_helper(node-&gt;left, key, deleted);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (key &gt; node-&gt;key) &#123;  // 目标在右子树</span><br><span class="line">        node-&gt;right = bst_delete_helper(node-&gt;right, key, deleted);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;  // 找到目标节点</span><br><span class="line">        *deleted = true;</span><br><span class="line"></span><br><span class="line">        // 情况1：无左子树（只有右子树或无子树）</span><br><span class="line">        if (!node-&gt;left) &#123;</span><br><span class="line">            TreeNode *temp = node-&gt;right;</span><br><span class="line">            free(node);</span><br><span class="line">            return temp;</span><br><span class="line">        &#125;</span><br><span class="line">        // 情况2：无右子树（只有左子树）</span><br><span class="line">        else if (!node-&gt;right) &#123;</span><br><span class="line">            TreeNode *temp = node-&gt;left;</span><br><span class="line">            free(node);</span><br><span class="line">            return temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 情况3：有两个子节点（找右子树的最小节点替换）</span><br><span class="line">        TreeNode *min_node = bst_min(node-&gt;right);  // 找右子树最小节点</span><br><span class="line">        node-&gt;key = min_node-&gt;key;  // 替换当前节点的键</span><br><span class="line">        node-&gt;right = bst_delete_helper(node-&gt;right, min_node-&gt;key, deleted);  // 删除右子树的最小节点</span><br><span class="line">    &#125;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关键细节："><a href="#关键细节：" class="headerlink" title="关键细节："></a>关键细节：</h4><ul><li><strong>后继节点</strong>：右子树的最小节点（最左节点）是删除双子节点时的最佳替换候选，因为它不会破坏左子树的有序性。</li><li><strong>内存管理</strong>：删除节点后需释放其内存，避免内存泄漏。</li></ul><h3 id="3-4-修改操作（Update）：先查找后更新的完整流程"><a href="#3-4-修改操作（Update）：先查找后更新的完整流程" class="headerlink" title="3.4 修改操作（Update）：先查找后更新的完整流程"></a>3.4 修改操作（Update）：先查找后更新的完整流程</h3><p>修改操作需先找到目标节点，再更新其键值。需注意：修改键值后可能破坏BST性质，因此需重新调整树结构（或直接删除旧节点并插入新节点）。</p><p>当前代码未直接提供修改函数，但可通过以下步骤实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool bst_update(BST *tree, KeyType old_key, KeyType new_key) &#123;</span><br><span class="line">    TreeNode *node = bst_search(tree, old_key);</span><br><span class="line">    if (!node) return false;  // 旧键不存在</span><br><span class="line"></span><br><span class="line">    // 方法1：删除旧节点，插入新节点（简单但可能影响性能）</span><br><span class="line">    bst_delete(tree, old_key);</span><br><span class="line">    return bst_insert(tree, new_key);</span><br><span class="line"></span><br><span class="line">    // 方法2：直接修改键值（需调整树结构，复杂度较高）</span><br><span class="line">    // 注意：修改后需确保左子树所有节点 &lt; new_key，右子树所有节点 &gt;= new_key</span><br><span class="line">    // 若new_key &lt; node-&gt;key，需将原左子树中 &gt;= new_key的节点移到右子树，反之亦然（不推荐）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="四、三种遍历方式：深度优先搜索（DFS）的应用"><a href="#四、三种遍历方式：深度优先搜索（DFS）的应用" class="headerlink" title="四、三种遍历方式：深度优先搜索（DFS）的应用"></a>四、三种遍历方式：深度优先搜索（DFS）的应用</h2><p>遍历是访问树中所有节点的过程，BST的三种经典遍历方式（前序、中序、后序）均基于深度优先搜索（DFS），区别在于访问节点的时机。</p><h3 id="4-1-前序遍历（根→左→右）"><a href="#4-1-前序遍历（根→左→右）" class="headerlink" title="4.1 前序遍历（根→左→右）"></a>4.1 前序遍历（根→左→右）</h3><p><strong>逻辑</strong>：先访问根节点，再递归遍历左子树，最后递归遍历右子树。<br> ​<strong>​应用场景​</strong>​：复制树结构、序列化（如JSON格式）。<br> ​<strong>​递归实现​</strong>​：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void bst_preorder_helper(TreeNode *node) &#123;</span><br><span class="line">    if (!node) return;</span><br><span class="line">    printf(&quot;%d &quot;, node-&gt;key);  // 访问根节点</span><br><span class="line">    bst_preorder_helper(node-&gt;left);  // 遍历左子树</span><br><span class="line">    bst_preorder_helper(node-&gt;right);  // 遍历右子树</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-中序遍历（左→根→右）"><a href="#4-2-中序遍历（左→根→右）" class="headerlink" title="4.2 中序遍历（左→根→右）"></a>4.2 中序遍历（左→根→右）</h3><p><strong>逻辑</strong>：先递归遍历左子树，再访问根节点，最后递归遍历右子树。<br> ​<strong>​特性​</strong>​：BST的中序遍历结果是有序序列（升序）。<br> ​<strong>​应用场景​</strong>​：排序、验证BST性质。<br> ​<strong>​递归实现​</strong>​：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void bst_inorder_helper(TreeNode *node) &#123;</span><br><span class="line">    if (!node) return;</span><br><span class="line">    bst_inorder_helper(node-&gt;left);  // 遍历左子树</span><br><span class="line">    printf(&quot;%d &quot;, node-&gt;key);  // 访问根节点</span><br><span class="line">    bst_inorder_helper(node-&gt;right);  // 遍历右子树</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-后序遍历（左→右→根）"><a href="#4-3-后序遍历（左→右→根）" class="headerlink" title="4.3 后序遍历（左→右→根）"></a>4.3 后序遍历（左→右→根）</h3><p><strong>逻辑</strong>：先递归遍历左子树，再递归遍历右子树，最后访问根节点。<br> ​<strong>​应用场景​</strong>​：释放内存（确保子节点先被释放）、后序表达式求值。<br> ​<strong>​递归实现​</strong>​：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void bst_postorder_helper(TreeNode *node) &#123;</span><br><span class="line">    if (!node) return;</span><br><span class="line">    bst_postorder_helper(node-&gt;left);  // 遍历左子树</span><br><span class="line">    bst_postorder_helper(node-&gt;right);  // 遍历右子树</span><br><span class="line">    printf(&quot;%d &quot;, node-&gt;key);  // 访问根节点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="五、完整示例与测试：验证功能正确性"><a href="#五、完整示例与测试：验证功能正确性" class="headerlink" title="五、完整示例与测试：验证功能正确性"></a>五、完整示例与测试：验证功能正确性</h2><h3 id="5-1-测试代码说明"><a href="#5-1-测试代码说明" class="headerlink" title="5.1 测试代码说明"></a>5.1 测试代码说明</h3><p>以下测试用例覆盖插入、重复插入、搜索、删除和遍历操作，验证BST的核心功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">void test_bst() &#123;</span><br><span class="line">    BST *bst = bst_create();</span><br><span class="line">    if (!bst) &#123;</span><br><span class="line">        printf(&quot;创建BST失败\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 测试插入操作</span><br><span class="line">    int keys_to_insert[] = &#123;50, 30, 20, 40, 70, 60, 80&#125;;</span><br><span class="line">    for (int i = 0; i &lt; sizeof(keys_to_insert)/sizeof(keys_to_insert[0]); i++) &#123;</span><br><span class="line">        if (bst_insert(bst, keys_to_insert[i])) &#123;</span><br><span class="line">            printf(&quot;插入键 %d 成功\n&quot;, keys_to_insert[i]);</span><br><span class="line">            bst_inorder(bst);  // 中序遍历应输出有序序列</span><br><span class="line">            printf(&quot;</span><br><span class="line">&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;插入键 %d 失败（已存在）\n&quot;, keys_to_insert[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 测试重复插入</span><br><span class="line">    bst_insert(bst, 50);  // 应失败</span><br><span class="line">    bst_inorder(bst);     // 序列不变</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 测试搜索操作</span><br><span class="line">    int keys_to_search[] = &#123;40, 90&#125;;</span><br><span class="line">    for (int i = 0; i &lt; sizeof(keys_to_search)/sizeof(keys_to_search[0]); i++) &#123;</span><br><span class="line">        TreeNode *result = bst_search(bst, keys_to_search[i]);</span><br><span class="line">        if (result) &#123;</span><br><span class="line">            printf(&quot;找到键 %d\n&quot;, keys_to_search[i]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;未找到键 %d\n&quot;, keys_to_search[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 测试删除操作</span><br><span class="line">    int keys_to_delete[] = &#123;20, 50, 100&#125;;</span><br><span class="line">    for (int i = 0; i &lt; sizeof(keys_to_delete)/sizeof(keys_to_delete[0]); i++) &#123;</span><br><span class="line">        if (bst_delete(bst, keys_to_delete[i])) &#123;</span><br><span class="line">            printf(&quot;删除键 %d 成功\n&quot;, keys_to_delete[i]);</span><br><span class="line">            bst_inorder(bst);  // 中序遍历应保持有序</span><br><span class="line">            printf(&quot;\n&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;删除键 %d 失败（不存在）\n&quot;, keys_to_delete[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bst_destroy(bst);</span><br><span class="line">    printf(&quot;BST销毁成功\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-测试结果验证"><a href="#5-2-测试结果验证" class="headerlink" title="5.2 测试结果验证"></a>5.2 测试结果验证</h3><p>运行测试代码，输出结果如下（关键步骤）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">插入键 50 成功</span><br><span class="line">50 </span><br><span class="line">插入键 30 成功</span><br><span class="line">30 50 </span><br><span class="line">插入键 20 成功</span><br><span class="line">20 30 50 </span><br><span class="line">插入键 40 成功</span><br><span class="line">20 30 40 50 </span><br><span class="line">插入键 70 成功</span><br><span class="line">20 30 40 50 70 </span><br><span class="line">插入键 60 成功</span><br><span class="line">20 30 40 50 60 70 </span><br><span class="line">插入键 80 成功</span><br><span class="line">20 30 40 50 60 70 80 </span><br><span class="line">插入键 50 失败（已存在）</span><br><span class="line">20 30 40 50 60 70 80 </span><br><span class="line"></span><br><span class="line">找到键 40</span><br><span class="line">未找到键 90</span><br><span class="line"></span><br><span class="line">删除键 20 成功</span><br><span class="line">30 40 50 60 70 80 </span><br><span class="line">删除键 50 成功</span><br><span class="line">30 40 60 70 80 </span><br><span class="line">删除键 100 失败（不存在）</span><br><span class="line">30 40 60 70 80 </span><br><span class="line"></span><br><span class="line">BST销毁成功</span><br></pre></td></tr></table></figure><hr><h2 id="六、总结与扩展"><a href="#六、总结与扩展" class="headerlink" title="六、总结与扩展"></a>六、总结与扩展</h2><h3 id="6-1-BST的优势与局限"><a href="#6-1-BST的优势与局限" class="headerlink" title="6.1 BST的优势与局限"></a>6.1 BST的优势与局限</h3><ul><li><strong>优势</strong>：高效的动态排序（插入、删除、查找平均O(logn)）、支持范围查询。</li><li><strong>局限</strong>：最坏情况下树高为n（退化为链表），时间复杂度退化为O(n)（可通过平衡BST如AVL树、红黑树优化）。</li></ul><h3 id="6-2-扩展方向"><a href="#6-2-扩展方向" class="headerlink" title="6.2 扩展方向"></a>6.2 扩展方向</h3><ul><li><strong>泛型支持</strong>：使用<code>void*</code>和比较函数指针，支持任意类型的键值。</li><li><strong>平衡BST</strong>：实现AVL树或红黑树，确保最坏时间复杂度为O(logn)。</li><li><strong>迭代实现</strong>：将递归操作改为迭代（使用栈模拟递归），避免栈溢出（适用于大深度树）。</li></ul><p>通过本文的详细解析，读者已掌握BST的核心原理与实现细节。实际应用中，可根据需求选择递归或迭代实现，并根据数据规模选择普通BST或平衡BST。</p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">头文件.h</button><button type="button" class="tab">main.c</button><button type="button" class="tab">函数.h</button></div><div class="tab-contents"><div class="tab-item-content active"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#ifndef BST_H</span><br><span class="line">#define BST_H</span><br><span class="line"></span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int KeyType;  // 键类型为整数</span><br><span class="line"></span><br><span class="line">// 二叉搜索树节点结构体</span><br><span class="line">typedef struct node &#123;</span><br><span class="line">    KeyType key;          // 节点键值（唯一）</span><br><span class="line">    struct node *left;    // 左子树指针</span><br><span class="line">    struct node *right;   // 右子树指针</span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line">// 二叉搜索树结构体（封装根节点）</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    TreeNode *root;       // 根节点指针</span><br><span class="line">&#125; BST;</span><br><span class="line"></span><br><span class="line">// 基础操作函数声明</span><br><span class="line">BST *bst_create();                  // 创建空BST</span><br><span class="line">bool bst_insert(BST *tree, KeyType key);  // 插入新节点（键唯一）</span><br><span class="line">TreeNode *bst_search(BST *tree, KeyType key);  // 搜索节点（返回节点指针）</span><br><span class="line">bool bst_delete(BST *tree, KeyType key);  // 删除节点（键存在时成功）</span><br><span class="line">void bst_destroy(BST *tree);          // 销毁BST（释放所有内存）</span><br><span class="line"></span><br><span class="line">void bst_preorder(BST *tree);</span><br><span class="line">void bst_inorder(BST *tree);</span><br><span class="line">void bst_postorder(BST *tree);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bst.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 打印三种遍历结果的辅助函数</span><br><span class="line">void print_traversals(BST *bst) &#123;</span><br><span class="line">    printf(&quot;先序遍历结果: &quot;);</span><br><span class="line">    bst_preorder(bst);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;中序遍历结果: &quot;);</span><br><span class="line">    bst_inorder(bst);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;后序遍历结果: &quot;);</span><br><span class="line">    bst_postorder(bst);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试函数</span><br><span class="line">void test_bst() &#123;</span><br><span class="line">    // 创建空BST</span><br><span class="line">    BST *bst = bst_create();</span><br><span class="line">    if (!bst) &#123;</span><br><span class="line">        printf(&quot;创建BST失败\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 测试插入操作</span><br><span class="line">    int keys_to_insert[] = &#123; 50, 30, 20, 40, 70, 60, 80 &#125;;</span><br><span class="line">    int num_keys = sizeof(keys_to_insert) / sizeof(keys_to_insert[0]);</span><br><span class="line">    for (int i = 0; i &lt; num_keys; i++) &#123;</span><br><span class="line">        if (bst_insert(bst, keys_to_insert[i])) &#123;</span><br><span class="line">            printf(&quot;成功插入键: %d\n&quot;, keys_to_insert[i]);</span><br><span class="line">            print_traversals(bst);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            printf(&quot;插入键 %d 失败，键已存在\n&quot;, keys_to_insert[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 测试重复插入</span><br><span class="line">    if (!bst_insert(bst, 50)) &#123;</span><br><span class="line">        printf(&quot;成功检测到重复键 50，插入失败\n&quot;);</span><br><span class="line">        print_traversals(bst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 测试搜索操作</span><br><span class="line">    int keys_to_search[] = &#123; 40, 90 &#125;;</span><br><span class="line">    int num_search_keys = sizeof(keys_to_search) / sizeof(keys_to_search[0]);</span><br><span class="line">    for (int i = 0; i &lt; num_search_keys; i++) &#123;</span><br><span class="line">        TreeNode *result = bst_search(bst, keys_to_search[i]);</span><br><span class="line">        if (result) &#123;</span><br><span class="line">            printf(&quot;找到键: %d\n&quot;, keys_to_search[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            printf(&quot;未找到键: %d\n&quot;, keys_to_search[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 测试删除操作</span><br><span class="line">    int keys_to_delete[] = &#123; 20, 50, 100 &#125;;</span><br><span class="line">    int num_delete_keys = sizeof(keys_to_delete) / sizeof(keys_to_delete[0]);</span><br><span class="line">    for (int i = 0; i &lt; num_delete_keys; i++) &#123;</span><br><span class="line">        if (bst_delete(bst, keys_to_delete[i])) &#123;</span><br><span class="line">            printf(&quot;成功删除键: %d\n&quot;, keys_to_delete[i]);</span><br><span class="line">            print_traversals(bst);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            printf(&quot;删除键 %d 失败，键不存在\n&quot;, keys_to_delete[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 销毁BST</span><br><span class="line">    bst_destroy(bst);</span><br><span class="line">    printf(&quot;BST已成功销毁\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    test_bst();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bst.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">// 创建空BST</span><br><span class="line">BST *bst_create() &#123;</span><br><span class="line">    BST *bst = (BST *)malloc(sizeof(BST));</span><br><span class="line">    if (!bst) &#123;</span><br><span class="line">        perror(&quot;BST内存分配失败&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    bst-&gt;root = NULL;  // 初始根节点为空</span><br><span class="line">    return bst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 辅助函数：递归插入节点（返回插入后的子树根）</span><br><span class="line">static TreeNode *bst_insert_helper(TreeNode *node, KeyType key, bool *inserted) &#123;</span><br><span class="line">    if (!node) &#123;  // 空位置插入新节点</span><br><span class="line">        TreeNode *new_node = (TreeNode *)malloc(sizeof(TreeNode));</span><br><span class="line">        if (!new_node) &#123;</span><br><span class="line">            perror(&quot;新节点内存分配失败&quot;);</span><br><span class="line">            exit(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        new_node-&gt;key = key;</span><br><span class="line">        new_node-&gt;left = new_node-&gt;right = NULL;</span><br><span class="line">        *inserted = true;  // 标记插入成功</span><br><span class="line">        return new_node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (key == node-&gt;key) &#123;  // 键已存在，插入失败</span><br><span class="line">        *inserted = false;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (key &lt; node-&gt;key) &#123;  // 插入左子树</span><br><span class="line">        node-&gt;left = bst_insert_helper(node-&gt;left, key, inserted);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;  // 插入右子树</span><br><span class="line">        node-&gt;right = bst_insert_helper(node-&gt;right, key, inserted);</span><br><span class="line">    &#125;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 插入新节点（键唯一，存在则失败）</span><br><span class="line">bool bst_insert(BST *tree, KeyType key) &#123;</span><br><span class="line">    if (!tree) return false;</span><br><span class="line">    bool inserted = false;</span><br><span class="line">    tree-&gt;root = bst_insert_helper(tree-&gt;root, key, &amp;inserted);</span><br><span class="line">    return inserted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 辅助函数：递归搜索节点</span><br><span class="line">static TreeNode *bst_search_helper(TreeNode *node, KeyType key) &#123;</span><br><span class="line">    if (!node) return NULL;  // 空树或未找到</span><br><span class="line">    if (key == node-&gt;key) &#123;</span><br><span class="line">        return node;  // 找到目标节点</span><br><span class="line">    &#125;</span><br><span class="line">    else if (key &lt; node-&gt;key) &#123;</span><br><span class="line">        return bst_search_helper(node-&gt;left, key);  // 搜索左子树</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return bst_search_helper(node-&gt;right, key);  // 搜索右子树</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 搜索节点（返回节点指针，不存在返回NULL）</span><br><span class="line">TreeNode *bst_search(BST *tree, KeyType key) &#123;</span><br><span class="line">    if (!tree) return NULL;</span><br><span class="line">    return bst_search_helper(tree-&gt;root, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 辅助函数：找以node为根的最小节点（最左节点）</span><br><span class="line">static TreeNode *bst_min(TreeNode *node) &#123;</span><br><span class="line">    while (node &amp;&amp; node-&gt;left) &#123;</span><br><span class="line">        node = node-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line">// 辅助函数：递归删除节点（返回删除后的子树根）</span><br><span class="line">static TreeNode *bst_delete_helper(TreeNode *node, KeyType key, bool *deleted) &#123;</span><br><span class="line">    if (!node) &#123;  // 未找到目标节点</span><br><span class="line">        *deleted = false;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (key &lt; node-&gt;key) &#123;  // 目标在左子树</span><br><span class="line">        node-&gt;left = bst_delete_helper(node-&gt;left, key, deleted);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (key &gt; node-&gt;key) &#123;  // 目标在右子树</span><br><span class="line">        node-&gt;right = bst_delete_helper(node-&gt;right, key, deleted);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;  // 找到目标节点</span><br><span class="line">        *deleted = true;</span><br><span class="line"></span><br><span class="line">        // 情况1：叶子节点或只有一个子节点</span><br><span class="line">        if (!node-&gt;left) &#123;  // 只有右子树或无子树</span><br><span class="line">            TreeNode *temp = node-&gt;right;</span><br><span class="line">            free(node);  // 释放当前节点</span><br><span class="line">            return temp;  // 返回右子树（可能为NULL）</span><br><span class="line">        &#125;</span><br><span class="line">        else if (!node-&gt;right) &#123;  // 只有左子树</span><br><span class="line">            TreeNode *temp = node-&gt;left;</span><br><span class="line">            free(node);  // 释放当前节点</span><br><span class="line">            return temp;  // 返回左子树（可能为NULL）</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 情况2：有两个子节点（找右子树的最小节点替换）</span><br><span class="line">        TreeNode *min_node = bst_min(node-&gt;right);  // 找右子树最小节点</span><br><span class="line">        node-&gt;key = min_node-&gt;key;  // 替换当前节点的键</span><br><span class="line">        // 删除右子树中的最小节点（递归）</span><br><span class="line">        node-&gt;right = bst_delete_helper(node-&gt;right, min_node-&gt;key, deleted);</span><br><span class="line">    &#125;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除节点（键存在时成功）</span><br><span class="line">bool bst_delete(BST *tree, KeyType key) &#123;</span><br><span class="line">    if (!tree) return false;</span><br><span class="line">    bool deleted = false;</span><br><span class="line">    tree-&gt;root = bst_delete_helper(tree-&gt;root, key, &amp;deleted);</span><br><span class="line">    return deleted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 辅助函数：递归销毁所有节点</span><br><span class="line">static void bst_destroy_helper(TreeNode *node) &#123;</span><br><span class="line">    if (!node) return;</span><br><span class="line">    bst_destroy_helper(node-&gt;left);   // 销毁左子树</span><br><span class="line">    bst_destroy_helper(node-&gt;right);  // 销毁右子树</span><br><span class="line">    free(node);                       // 释放当前节点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 销毁BST（释放所有内存）</span><br><span class="line">void bst_destroy(BST *tree) &#123;</span><br><span class="line">    if (!tree) return;</span><br><span class="line">    bst_destroy_helper(tree-&gt;root);  // 销毁所有节点</span><br><span class="line">    free(tree);                      // 释放BST结构体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 深度优先-先序遍历（根-左-右）</span><br><span class="line">// 先序遍历辅助函数（递归核心）</span><br><span class="line">static void bst_preorder_helper(TreeNode *node) &#123;</span><br><span class="line">    if (!node) return;  // 递归终止条件：当前节点为空</span><br><span class="line">    printf(&quot;%d &quot;, node-&gt;key);  // 访问当前节点（根）</span><br><span class="line">    bst_preorder_helper(node-&gt;left);  // 遍历左子树</span><br><span class="line">    bst_preorder_helper(node-&gt;right);  // 遍历右子树</span><br><span class="line">&#125;</span><br><span class="line">void bst_preorder(BST *tree) &#123;</span><br><span class="line">    // 检查树或根节点是否为空，避免空指针解引用</span><br><span class="line">    if (!tree || !tree-&gt;root) return;</span><br><span class="line">    // 调用辅助函数处理递归</span><br><span class="line">    bst_preorder_helper(tree-&gt;root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 中序遍历辅助函数（递归核心）</span><br><span class="line">static void bst_inorder_helper(TreeNode *node) &#123;</span><br><span class="line">    if (!node) return;</span><br><span class="line">    bst_inorder_helper(node-&gt;left);  // 遍历左子树</span><br><span class="line">    printf(&quot;%d &quot;, node-&gt;key);  // 访问当前节点（根）</span><br><span class="line">    bst_inorder_helper(node-&gt;right);  // 遍历右子树</span><br><span class="line">&#125;</span><br><span class="line">// 深度优先-中序遍历（左-根-右）</span><br><span class="line">void bst_inorder(BST *tree) &#123;</span><br><span class="line">    if (!tree || !tree-&gt;root) return;</span><br><span class="line">    bst_inorder_helper(tree-&gt;root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 后序遍历辅助函数（递归核心）</span><br><span class="line">static void bst_postorder_helper(TreeNode *node) &#123;</span><br><span class="line">    if (!node) return;</span><br><span class="line">    bst_postorder_helper(node-&gt;left);  // 遍历左子树</span><br><span class="line">    bst_postorder_helper(node-&gt;right);  // 遍历右子树</span><br><span class="line">    printf(&quot;%d &quot;, node-&gt;key);  // 访问当前节点（根）</span><br><span class="line">&#125;</span><br><span class="line">// 深度优先-后序遍历（左-右-根）</span><br><span class="line">void bst_postorder(BST *tree) &#123;</span><br><span class="line">    if (!tree || !tree-&gt;root) return;</span><br><span class="line">    bst_postorder_helper(tree-&gt;root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> C-Code </category>
          
          <category> Data Structures and Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉搜索树 </tag>
            
            <tag> 遍历算法 </tag>
            
            <tag> 递归实现 </tag>
            
            <tag> 动态数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用C语言文件流实现轻量级图书管理系统：从0到1的实战解析</title>
      <link href="/posts/834f76ba/"/>
      <url>/posts/834f76ba/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/15.png" alt="用C语言文件流实现轻量级图书管理系统：从0到1的实战解析" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在C语言的学习过程中，文件操作是一个绕不开的核心技能。无论是保存用户数据、记录日志，还是实现小型系统，“如何将数据持久化到本地”都是必须解决的问题。今天，基于之前写的<a href="/posts/12989e68"><strong>轻量级图书管理系统</strong></a>，通过文件流复现，带你深入理解C语言文件流的核心概念（如文件指针、文本&#x2F;二进制模式、文件读写逻辑），并展示如何用文件流替代内存存储，解决小型系统的实际需求。</p><hr><h2 id="一、为什么选择文件流？——对比内存存储的局限性"><a href="#一、为什么选择文件流？——对比内存存储的局限性" class="headerlink" title="一、为什么选择文件流？——对比内存存储的局限性"></a>一、为什么选择文件流？——对比内存存储的局限性</h2><p>在开发小型系统时，我们可能会先用数组或链表在内存中存储数据。但内存存储存在两个致命问题：</p><ol><li><strong>临时性</strong>：程序退出后，内存数据会被操作系统回收，无法长期保存。</li><li><strong>容量限制</strong>：内存大小有限（如32位系统约4GB），无法处理大规模数据。</li></ol><p>而文件流（File Stream）是操作系统提供的“持久化存储接口”，通过将数据写入磁盘文件，可以实现：</p><ul><li><strong>数据持久化</strong>：程序退出后，数据仍保留在文件中，下次启动可重新加载。</li><li><strong>跨程序共享</strong>：文件是操作系统级别的资源，其他程序也能访问。</li><li><strong>灵活扩展</strong>：通过调整文件读写逻辑，可轻松支持新增字段或功能。</li></ul><p>本文的图书管理系统将使用<strong>二进制文件流</strong>存储图书数据（结构体直接写入文件），兼顾效率与易用性。</p><hr><h2 id="二、核心设计：文件如何存储图书数据？"><a href="#二、核心设计：文件如何存储图书数据？" class="headerlink" title="二、核心设计：文件如何存储图书数据？"></a>二、核心设计：文件如何存储图书数据？</h2><h3 id="2-1-文件模式的选择：文本模式vs二进制模式"><a href="#2-1-文件模式的选择：文本模式vs二进制模式" class="headerlink" title="2.1 文件模式的选择：文本模式vs二进制模式"></a>2.1 文件模式的选择：文本模式vs二进制模式</h3><p>C语言中，文件操作通过<code>fopen</code>函数指定模式，常见的有：</p><ul><li><strong>文本模式（如&quot;r&quot;&#x2F;&quot;w&quot;）</strong>：以字符形式读写，自动转换换行符（如Windows的<code>\r </code>转Unix的<code> </code>）。</li><li><strong>二进制模式（如&quot;rb&quot;&#x2F;&quot;wb&quot;）</strong>：以字节形式直接读写，不进行任何转换。</li></ul><p><strong>为什么选择二进制模式？</strong><br> 图书管理系统需要存储结构体<code>Book</code>（包含<code>int num</code>、<code>char name[15]</code>等字段）。若用文本模式，需手动将结构体序列化为字符串（如用<code>|</code>分隔字段），读取时再解析。这种方式不仅代码复杂，还可能因格式错误（如字段缺失）导致数据损坏。而二进制模式直接写入结构体的内存字节，读写逻辑更简单，效率更高（无需字符串转换）。</p><h3 id="2-2-结构体与文件的交互：序列化与反序列化"><a href="#2-2-结构体与文件的交互：序列化与反序列化" class="headerlink" title="2.2 结构体与文件的交互：序列化与反序列化"></a>2.2 结构体与文件的交互：序列化与反序列化</h3><p>在C语言中，结构体是内存中的一段连续字节。通过<code>fwrite</code>和<code>fread</code>函数，可以直接将结构体对象写入文件（序列化），或从文件读取字节并还原为结构体对象（反序列化）。</p><p>例如，写入一个<code>Book</code>结构体的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Book book = &#123;.num=1, .name=&quot;三体&quot;, .author=&quot;刘慈欣&quot;, .genre=SCIENCE_FICTION&#125;;</span><br><span class="line">FILE *fp = fopen(&quot;book.dat&quot;, &quot;wb&quot;); // 二进制写模式</span><br><span class="line">fwrite(&amp;book, sizeof(Book), 1, fp); // 写入1个Book结构体的字节</span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure><p>读取时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Book book;</span><br><span class="line">FILE *fp = fopen(&quot;book.dat&quot;, &quot;rb&quot;); // 二进制读模式</span><br><span class="line">fread(&amp;book, sizeof(Book), 1, fp); // 从文件读取1个Book结构体的字节</span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：二进制模式要求结构体在内存中是连续存储的（无填充或对齐问题）。C语言默认会对结构体进行内存对齐（如<code>char</code>后填充3字节使<code>int</code>对齐到4字节边界），但<code>fwrite</code>和<code>fread</code>会按实际内存布局读写，因此只要读写时的结构体定义一致，数据不会出错。</p><hr><h2 id="三、关键代码解析：文件流的核心操作"><a href="#三、关键代码解析：文件流的核心操作" class="headerlink" title="三、关键代码解析：文件流的核心操作"></a>三、关键代码解析：文件流的核心操作</h2><h3 id="3-1-文件打开与关闭：fopen与fclose"><a href="#3-1-文件打开与关闭：fopen与fclose" class="headerlink" title="3.1 文件打开与关闭：fopen与fclose"></a>3.1 文件打开与关闭：<code>fopen</code>与<code>fclose</code></h3><p><code>fopen</code>函数的原型是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *fopen(const char *filename, const char *mode);</span><br></pre></td></tr></table></figure><ul><li><code>filename</code>：文件路径（如<code>&quot;book.dat&quot;</code>）。</li><li><code>mode</code>：打开模式（如<code>&quot;rb&quot;</code>表示二进制读，<code>&quot;wb&quot;</code>表示二进制写）。</li></ul><p><strong>关键模式说明</strong>：</p><ul><li><code>&quot;rb&quot;</code>：只读二进制模式（文件必须存在，否则返回<code>NULL</code>）。</li><li><code>&quot;wb&quot;</code>：只写二进制模式（文件不存在则创建，存在则清空内容）。</li><li><code>&quot;ab+&quot;</code>：读写二进制模式（文件不存在则创建，存在则追加内容到末尾）。</li></ul><p><code>fclose</code>函数用于关闭文件，释放系统资源。<strong>必须确保每次<code>fopen</code>都有对应的<code>fclose</code></strong>，否则可能导致文件损坏或数据丢失。</p><h3 id="3-2-写入文件：fwrite的用法"><a href="#3-2-写入文件：fwrite的用法" class="headerlink" title="3.2 写入文件：fwrite的用法"></a>3.2 写入文件：<code>fwrite</code>的用法</h3><p><code>fwrite</code>的原型是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);</span><br></pre></td></tr></table></figure><ul><li><code>ptr</code>：指向要写入数据的内存指针（如<code>&amp;book</code>）。</li><li><code>size</code>：单个元素的大小（如<code>sizeof(Book)</code>）。</li><li><code>nmemb</code>：要写入的元素个数（如<code>1</code>表示写入1个<code>Book</code>结构体）。</li><li><code>stream</code>：文件指针（由<code>fopen</code>返回）。</li></ul><p><strong>示例</strong>：将1个<code>Book</code>结构体写入文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Book new_book = &#123;.num=10, .name=&quot;C Primer Plus&quot;, .author=&quot;Stephen Prata&quot;, .genre=TECHNOLOGY&#125;;</span><br><span class="line">FILE *fp = fopen(&quot;book.dat&quot;, &quot;ab+&quot;); // 追加模式（避免覆盖原有数据）</span><br><span class="line">if (fp == NULL) &#123;</span><br><span class="line">    perror(&quot;无法打开文件&quot;); // 输出错误信息（如“权限不足”）</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">fwrite(&amp;new_book, sizeof(Book), 1, fp); // 写入1个Book结构体</span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure><h3 id="3-3-读取文件：fread的用法"><a href="#3-3-读取文件：fread的用法" class="headerlink" title="3.3 读取文件：fread的用法"></a>3.3 读取文件：<code>fread</code>的用法</h3><p><code>fread</code>的原型是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</span><br></pre></td></tr></table></figure><ul><li><code>ptr</code>：指向存储读取数据的内存指针（如<code>&amp;books</code>数组）。</li><li><code>size</code>：单个元素的大小（如<code>sizeof(Book)</code>）。</li><li><code>nmemb</code>：要读取的元素个数（如<code>MAX_BOOKS</code>表示最多读取100本）。</li><li><code>stream</code>：文件指针。</li></ul><p><strong>示例</strong>：从文件读取所有图书数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Book books[MAX_BOOKS];</span><br><span class="line">FILE *fp = fopen(&quot;book.dat&quot;, &quot;rb&quot;);</span><br><span class="line">if (fp == NULL) &#123;</span><br><span class="line">    printf(&quot;文件不存在，将使用默认数据。\n&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">int cnt = fread(books, sizeof(Book), MAX_BOOKS, fp); // 读取最多100本</span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure><h3 id="3-4-错误处理：避免程序崩溃"><a href="#3-4-错误处理：避免程序崩溃" class="headerlink" title="3.4 错误处理：避免程序崩溃"></a>3.4 错误处理：避免程序崩溃</h3><p>文件操作可能遇到多种错误（如文件不存在、磁盘空间不足），必须进行错误检查：</p><ul><li><strong><code>fopen</code>返回<code>NULL</code></strong>：说明文件无法打开（如路径错误、权限不足）。此时应输出错误信息（用<code>perror</code>函数）并终止相关操作。</li><li><strong><code>fread</code>&#x2F;<code>fwrite</code>返回值异常</strong>：这两个函数返回实际读写的元素个数。若返回值小于预期（如<code>fread</code>返回0但文件未结束），可能是文件损坏或磁盘错误。</li></ul><p><strong>示例：安全的文件读取逻辑</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp = fopen(&quot;book.dat&quot;, &quot;rb&quot;);</span><br><span class="line">if (fp == NULL) &#123;</span><br><span class="line">    perror(&quot;错误：无法打开文件&quot;);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">int cnt = fread(books, sizeof(Book), MAX_BOOKS, fp);</span><br><span class="line">if (cnt == 0 &amp;&amp; ferror(fp)) &#123; // 检查是否因错误导致读取失败</span><br><span class="line">    perror(&quot;错误：读取文件失败&quot;);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure><hr><h2 id="四、实战演示：用户操作与文件交互"><a href="#四、实战演示：用户操作与文件交互" class="headerlink" title="四、实战演示：用户操作与文件交互"></a>四、实战演示：用户操作与文件交互</h2><h3 id="4-1-添加一本《C-Primer-Plus》"><a href="#4-1-添加一本《C-Primer-Plus》" class="headerlink" title="4.1 添加一本《C Primer Plus》"></a>4.1 添加一本《C Primer Plus》</h3><p>假设当前文件<code>book.dat</code>中已有10本书，现在添加第11本《C Primer Plus》：</p><ol><li>用户选择“输入新的书籍信息”（选项2）。</li><li>程序调用<code>find_empty_num</code>查找最小空缺序号（假设当前最大序号是10，返回11）。</li><li>用户输入书名、作者、类别（假设选3:科技）。</li><li>程序创建<code>Book</code>结构体并写入文件（<code>fwrite</code>）。</li><li>最后调用<code>write_to_file</code>将整个数组重新写入文件（覆盖原内容）。</li></ol><p><strong>关键代码逻辑（<code>input_book</code>函数）</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int input_book(Book *books, int cnt) &#123;</span><br><span class="line">    if (cnt &gt;= MAX_BOOKS) &#123;</span><br><span class="line">        puts(&quot;书籍数量已达上限（100本），无法继续添加。\n&quot;);</span><br><span class="line">        return cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    Book new_book;</span><br><span class="line">    new_book.num = find_empty_num(books, cnt); // 查找空缺序号</span><br><span class="line">    printf(&quot;请输入书籍名称: &quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, new_book.name);</span><br><span class="line">    printf(&quot;请输入书籍作者: &quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, new_book.author);</span><br><span class="line">    int g;</span><br><span class="line">    do &#123;</span><br><span class="line">        printf(&quot;请输入类别编号（0:科幻 1:文学 2:历史 3:科技 4:其他）: &quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;g);</span><br><span class="line">    &#125; while (g &lt; 0 || g &gt; 4);</span><br><span class="line">    new_book.genre = g;</span><br><span class="line">    books[cnt] = new_book; // 添加到数组末尾</span><br><span class="line">    return cnt + 1; // 数量加1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-删除一本《C-Primer-Plus》"><a href="#4-2-删除一本《C-Primer-Plus》" class="headerlink" title="4.2 删除一本《C Primer Plus》"></a>4.2 删除一本《C Primer Plus》</h3><p>删除操作的核心是<strong>定位目标书籍并覆盖后续数据</strong>：</p><ol><li>用户选择“按序号删除书籍”（选项3），输入要删除的序号（如11）。</li><li>程序遍历数组找到该书籍的位置（假设索引为10）。</li><li>将该位置之后的所有书籍向前移动一位（覆盖被删除的书籍）。</li><li>最后调用<code>write_to_file</code>将更新后的数组写入文件。</li></ol><p><strong>关键代码逻辑（<code>delete_by_num</code>函数）</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int delete_by_num(Book *books, int cnt, int num) &#123;</span><br><span class="line">    for (int i = 0; i &lt; cnt; i++) &#123;</span><br><span class="line">        if (books[i].num == num) &#123;</span><br><span class="line">            // 后续书籍前移，覆盖被删除的位置</span><br><span class="line">            for (int j = i; j &lt; cnt - 1; j++) &#123;</span><br><span class="line">                books[j] = books[j + 1];</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;编号为 %d 的书籍已删除。\n&quot;, num);</span><br><span class="line">            return cnt - 1; // 数量减1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;未找到编号为 %d 的书籍，无法删除。\n&quot;, num);</span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-用文本编辑器查看文件内容（二进制文件）"><a href="#4-3-用文本编辑器查看文件内容（二进制文件）" class="headerlink" title="4.3 用文本编辑器查看文件内容（二进制文件）"></a>4.3 用文本编辑器查看文件内容（二进制文件）</h3><p>虽然二进制文件无法直接用文本编辑器阅读，但我们可以通过<code>hexdump</code>（Linux）或<code>HxD</code>（Windows）工具查看其字节结构，验证数据是否正确存储。例如，一个<code>Book</code>结构体的二进制存储可能如下（假设<code>num=11</code>，<code>name=&quot;C Primer Plus&quot;</code>，<code>author=&quot;Stephen Prata&quot;</code>，<code>genre=3</code>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000: 0000000b 43205072 696d657220 506c7573  ....C Primer Plu</span><br><span class="line">00000010: 73005374 65706865 6e205072 61746100  s.Stephen Prata.</span><br><span class="line">00000020: 03000000                                ....</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>前4字节是<code>num=11</code>（十六进制<code>0b</code>）。</li><li>接下来15字节是<code>name</code>（<code>&quot;C Primer Plus&quot;</code>，不足15字节补<code>\0</code>）。</li><li>接下来20字节是<code>author</code>（<code>&quot;Stephen Prata&quot;</code>，不足20字节补<code>\0</code>）。</li><li>最后4字节是<code>genre=3</code>（十六进制<code>03</code>）。</li></ul><hr><h2 id="五、总结与扩展"><a href="#五、总结与扩展" class="headerlink" title="五、总结与扩展"></a>五、总结与扩展</h2><h3 id="5-1-文件流的优缺点"><a href="#5-1-文件流的优缺点" class="headerlink" title="5.1 文件流的优缺点"></a>5.1 文件流的优缺点</h3><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>实现简单（无需数据库）</td><td>读写效率较低（适合小数据量）</td></tr><tr><td>数据持久化（程序退出后保留）</td><td>无索引功能（查询效率随数据量增加下降）</td></tr><tr><td>跨平台兼容（文件是通用资源）</td><td>需手动处理数据格式（如结构体对齐）</td></tr></tbody></table><h3 id="5-2-未来优化方向"><a href="#5-2-未来优化方向" class="headerlink" title="5.2 未来优化方向"></a>5.2 未来优化方向</h3><ul><li><strong>改用二进制模式提升速度</strong>：当前代码已使用二进制模式，若数据量极大（如10万本），可进一步优化读写逻辑（如批量读写）。</li><li><strong>增加索引功能</strong>：为<code>num</code>或<code>name</code>字段建立索引（如用数组记录序号对应的文件偏移量），提升查询效率。</li><li><strong>数据校验</strong>：在写入文件时添加校验码（如CRC校验），防止文件损坏导致数据丢失。</li><li><strong>支持更多字段</strong>：扩展<code>Book</code>结构体（如添加出版时间、价格），并调整文件读写逻辑。</li></ul><hr><h2 id="附录：完整代码片段（关键函数）"><a href="#附录：完整代码片段（关键函数）" class="headerlink" title="附录：完整代码片段（关键函数）"></a>附录：完整代码片段（关键函数）</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">`write_to_file`</button><button type="button" class="tab">`read_from_file`</button><button type="button" class="tab">`main.c`</button></div><div class="tab-contents"><div class="tab-item-content active"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void write_to_file(Book *books, int cnt) &#123;</span><br><span class="line">    FILE *fp = fopen(&quot;book.dat&quot;, &quot;wb&quot;); // 二进制写模式（清空原内容）</span><br><span class="line">    if (fp == NULL) &#123;</span><br><span class="line">        perror(&quot;错误：无法打开文件写入&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    fwrite(books, sizeof(Book), cnt, fp); // 写入所有书籍数据</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int read_from_file(Book *books) &#123;</span><br><span class="line">    FILE *fp = fopen(&quot;book.dat&quot;, &quot;rb&quot;); // 二进制读模式（文件不存在返回NULL）</span><br><span class="line">    if (fp == NULL) &#123;</span><br><span class="line">        return 0; // 文件不存在，返回0本</span><br><span class="line">    &#125;</span><br><span class="line">    int cnt = fread(books, sizeof(Book), MAX_BOOKS, fp); // 读取最多100本</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return cnt; // 返回实际读取的数量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAX_BOOKS 100</span><br><span class="line"></span><br><span class="line">typedef enum Genre &#123;</span><br><span class="line">SCIENCE_FICTION, LITERATURE, HISTORY, TECHNOLOGY, OTHER</span><br><span class="line">&#125; Genre;</span><br><span class="line"></span><br><span class="line">typedef struct Book &#123;</span><br><span class="line">int num;</span><br><span class="line">char name[15];</span><br><span class="line">char author[20];</span><br><span class="line">Genre genre;</span><br><span class="line">&#125; Book;</span><br><span class="line"></span><br><span class="line">const char *Genre_Zn(Genre g) &#123;</span><br><span class="line">const char *genres[] = &#123; &quot;科幻&quot;, &quot;文学&quot;, &quot;历史&quot;, &quot;科技&quot;, &quot;其他&quot; &#125;;</span><br><span class="line">return g &gt;= 0 &amp;&amp; g &lt; 5 ? genres[g] : &quot;未知&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 按序号排序书籍（冒泡排序）</span><br><span class="line">void sort_books(Book *books, int cnt) &#123;</span><br><span class="line">for (int i = 0; i &lt; cnt - 1; i++)</span><br><span class="line">for (int j = 0; j &lt; cnt - i - 1; j++)</span><br><span class="line">if (books[j].num &gt; books[j + 1].num) &#123;</span><br><span class="line">Book tmp = books[j];</span><br><span class="line">books[j] = books[j + 1];</span><br><span class="line">books[j + 1] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印书籍信息</span><br><span class="line">void print_books(Book *books, int cnt) &#123;</span><br><span class="line">sort_books(books, cnt);</span><br><span class="line">puts(&quot;--------------------- 所有的书籍信息 ---------------------&quot;);</span><br><span class="line">for (int i = 0; i &lt; cnt; i++)</span><br><span class="line">printf(&quot;编号:%-2d  书名:%-12s  作者:%-13s   类别:%-8s\n&quot;,</span><br><span class="line">books[i].num, books[i].name, books[i].author, Genre_Zn(books[i].genre));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 按类别查找书籍</span><br><span class="line">void find_by_genre(Book *books, int cnt, Genre g) &#123;</span><br><span class="line">for (int i = 0; i &lt; cnt; i++)</span><br><span class="line">if (books[i].genre == g)</span><br><span class="line">printf(&quot;编号:%-2d  书名:%-12s  作者:%-13s   类别:%-8s\n&quot;,</span><br><span class="line">books[i].num, books[i].name, books[i].author, Genre_Zn(books[i].genre));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 按序号查找书籍</span><br><span class="line">void find_by_num(Book *books, int cnt, int num) &#123;</span><br><span class="line">for (int i = 0; i &lt; cnt; i++)</span><br><span class="line">if (books[i].num == num) &#123;</span><br><span class="line">printf(&quot;编号:%-2d  书名:%-12s  作者:%-13s   类别:%-8s\n&quot;,</span><br><span class="line">books[i].num, books[i].name, books[i].author, Genre_Zn(books[i].genre));</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;未找到编号为 %d 的书籍。\n&quot;, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 按序号删除书籍</span><br><span class="line">int delete_by_num(Book *books, int cnt, int num) &#123;</span><br><span class="line">for (int i = 0; i &lt; cnt; i++)</span><br><span class="line">if (books[i].num == num) &#123;</span><br><span class="line">for (int j = i; j &lt; cnt - 1; j++)</span><br><span class="line">books[j] = books[j + 1];</span><br><span class="line">printf(&quot;编号为 %d 的书籍已删除。\n&quot;, num);</span><br><span class="line">return cnt - 1;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;未找到编号为 %d 的书籍，无法删除。\n&quot;, num);</span><br><span class="line">return cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 写入文件</span><br><span class="line">void write_to_file(Book *books, int cnt) &#123;</span><br><span class="line">FILE *fp = fopen(&quot;book.txt&quot;, &quot;wb&quot;);</span><br><span class="line">if (fp) &#123;</span><br><span class="line">fwrite(books, sizeof(Book), cnt, fp);</span><br><span class="line">fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">perror(&quot;book.txt open&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 读取文件</span><br><span class="line">int read_from_file(Book *books) &#123;</span><br><span class="line">FILE *fp = fopen(&quot;book.txt&quot;, &quot;rb&quot;);</span><br><span class="line">if (!fp) &#123;</span><br><span class="line">perror(&quot;book.txt open&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">int cnt = fread(books, sizeof(Book), MAX_BOOKS, fp);</span><br><span class="line">fclose(fp);</span><br><span class="line">return cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查找最小空缺序号</span><br><span class="line">int find_empty_num(Book *books, int cnt) &#123;</span><br><span class="line">bool used[MAX_BOOKS + 1] = &#123; false &#125;;</span><br><span class="line">for (int i = 0; i &lt; cnt; i++)</span><br><span class="line">if (books[i].num &lt;= MAX_BOOKS) used[books[i].num] = true;</span><br><span class="line">for (int i = 1; i &lt;= MAX_BOOKS; i++)</span><br><span class="line">if (!used[i]) return i;</span><br><span class="line">// 若没有空缺，返回最大序号 + 1</span><br><span class="line">int max = 0;</span><br><span class="line">for (int i = 0; i &lt; cnt; i++)</span><br><span class="line">if (books[i].num &gt; max) max = books[i].num;</span><br><span class="line">return max + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输入新书籍信息</span><br><span class="line">int input_book(Book *books, int cnt) &#123;</span><br><span class="line">if (cnt &gt;= MAX_BOOKS) &#123;</span><br><span class="line">puts(&quot;书籍数量已达上限，无法继续添加。&quot;);</span><br><span class="line">return cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Book new_book = &#123; .num = find_empty_num(books, cnt) &#125;;</span><br><span class="line">printf(&quot;请输入书籍名称: &quot;);</span><br><span class="line">scanf(&quot;%s&quot;, new_book.name);</span><br><span class="line">printf(&quot;请输入书籍作者: &quot;);</span><br><span class="line">scanf(&quot;%s&quot;, new_book.author);</span><br><span class="line"></span><br><span class="line">int g;</span><br><span class="line">do &#123;</span><br><span class="line">printf(&quot;请输入书籍类别编号（0:科幻 1:文学 2:历史 3:科技 4:其他）: &quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;g);</span><br><span class="line">&#125; while (g &lt; 0 || g &gt; 4);</span><br><span class="line">new_book.genre = g;</span><br><span class="line"></span><br><span class="line">books[cnt] = new_book;</span><br><span class="line">return cnt + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">Book books[MAX_BOOKS];</span><br><span class="line">int cnt = read_from_file(books);</span><br><span class="line"></span><br><span class="line">if (!cnt) &#123;</span><br><span class="line">Book init_books[] = &#123;</span><br><span class="line">&#123;1, &quot;三体&quot;, &quot;刘慈欣&quot;, SCIENCE_FICTION&#125;,</span><br><span class="line">&#123;2, &quot;红楼梦&quot;, &quot;曹雪芹&quot;, LITERATURE&#125;,</span><br><span class="line">&#123;3, &quot;中国通史&quot;, &quot;吕思勉&quot;, HISTORY&#125;,</span><br><span class="line">&#123;4, &quot;时间简史&quot;, &quot;史蒂芬_霍金&quot;, TECHNOLOGY&#125;,</span><br><span class="line">&#123;5, &quot;围城&quot;, &quot;钱钟书&quot;, LITERATURE&#125;,</span><br><span class="line">&#123;6, &quot;傲慢与偏见&quot;, &quot;简_奥斯汀&quot;, LITERATURE&#125;,</span><br><span class="line">&#123;7, &quot;呼啸山庄&quot;, &quot;艾米莉_勃朗特&quot;, LITERATURE&#125;,</span><br><span class="line">&#123;8, &quot;活着&quot;, &quot;余华&quot;, LITERATURE&#125;,</span><br><span class="line">&#123;9, &quot;明朝那些事儿&quot;, &quot;当年明月&quot;, HISTORY&#125;,</span><br><span class="line">&#123;10, &quot;乌合之众&quot;, &quot;古斯塔夫_勒庞&quot;, OTHER&#125;</span><br><span class="line">&#125;;</span><br><span class="line">cnt = sizeof(init_books) / sizeof(Book);</span><br><span class="line">for (int i = 0; i &lt; cnt; i++) books[i] = init_books[i];</span><br><span class="line">write_to_file(books, cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int choice;</span><br><span class="line">do &#123;</span><br><span class="line">print_books(books, cnt);</span><br><span class="line">puts(&quot;\n请选择操作：&quot;);</span><br><span class="line">puts(&quot;0: 按类别查找书籍&quot;);</span><br><span class="line">puts(&quot;1: 按序号查找书籍&quot;);</span><br><span class="line">puts(&quot;2: 输入新的书籍信息&quot;);</span><br><span class="line">puts(&quot;3: 按序号删除书籍&quot;);</span><br><span class="line">puts(&quot;4: 退出&quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;choice);</span><br><span class="line"></span><br><span class="line">switch (choice) &#123;</span><br><span class="line">case 0: &#123;</span><br><span class="line">int g;</span><br><span class="line">do &#123;</span><br><span class="line">puts(&quot;\n请输入书籍类别编号（0:科幻 1:文学 2:历史 3:科技 4:其他 5:返回上一级）&quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;g);</span><br><span class="line">if (g != 5) find_by_genre(books, cnt, g);</span><br><span class="line">&#125; while (g != 5);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">case 1: &#123;</span><br><span class="line">int num;</span><br><span class="line">printf(&quot;请输入要查找的书籍序号: &quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">find_by_num(books, cnt, num);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">case 2:</span><br><span class="line">cnt = input_book(books, cnt);</span><br><span class="line">write_to_file(books, cnt);</span><br><span class="line">break;</span><br><span class="line">case 3: &#123;</span><br><span class="line">int num;</span><br><span class="line">printf(&quot;请输入要删除的书籍序号: &quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">cnt = delete_by_num(books, cnt, num);</span><br><span class="line">write_to_file(books, cnt);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">case 4:</span><br><span class="line">puts(&quot;退出程序。&quot;);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">puts(&quot;无效的选择，请重新输入。&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125; while (choice != 4);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>通过这个案例，我们不仅实现了图书管理的基本功能，更深入理解了C语言文件流的核心机制。文件流是C语言与外部世界交互的重要桥梁，掌握它后，你可以轻松实现日志记录、配置保存、数据导出等功能。下次遇到需要持久化存储的需求时，不妨试试文件流！</p>]]></content>
      
      
      <categories>
          
          <category> C-Code </category>
          
          <category> Practical System Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 程序 </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态哈希表：从0到1解析C语言动态数组+链表冲突解决方案</title>
      <link href="/posts/a57786d7/"/>
      <url>/posts/a57786d7/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/17.png" alt="动态哈希表：从0到1解析C语言动态数组+链表冲突解决方案" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>哈希表（Hash Map）是一种高效的数据结构，通过哈希函数将键映射到数组索引，实现O(1)时间复杂度的插入、查询和删除操作。但传统静态哈希表（固定容量数组）存在<strong>空间浪费</strong>（数据少时数组空置）和<strong>冲突频发</strong>（数据多时哈希碰撞概率激增）的痛点。本文将基于C语言，手把手实现一个<strong>动态哈希表</strong>，通过「动态数组+链表」的组合方案解决这些问题，并深入解析核心设计与实现细节。</p><hr><h2 id="一、设计背景：为什么选择「动态数组-链表」？"><a href="#一、设计背景：为什么选择「动态数组-链表」？" class="headerlink" title="一、设计背景：为什么选择「动态数组+链表」？"></a>一、设计背景：为什么选择「动态数组+链表」？</h2><h3 id="1-1-传统静态哈希表的痛点"><a href="#1-1-传统静态哈希表的痛点" class="headerlink" title="1.1 传统静态哈希表的痛点"></a>1.1 传统静态哈希表的痛点</h3><p>传统哈希表通常使用<strong>固定大小的数组</strong>存储键值对，通过哈希函数计算索引。但这种设计存在两大缺陷：</p><ul><li><strong>空间浪费</strong>：若初始容量过大，数据稀疏时大量数组空间闲置；若初始容量过小，数据增多时频繁扩容（需重新哈希所有数据），效率低下。</li><li><strong>冲突频发</strong>：当数据量超过数组容量时，哈希碰撞概率激增，链表法（拉链法）虽能解决冲突，但链表过长会导致查询时间退化为O(n)。</li></ul><h3 id="1-2-动态数组-链表的组合优势"><a href="#1-2-动态数组-链表的组合优势" class="headerlink" title="1.2 动态数组+链表的组合优势"></a>1.2 动态数组+链表的组合优势</h3><p>动态哈希表通过「动态数组」和「链表」的组合，完美解决了上述问题：</p><ul><li><strong>动态扩容</strong>：当负载因子（键值对数量&#x2F;桶数量）超过阈值（如0.75）时，自动扩容（通常翻倍），保持哈希分布均匀，减少冲突。</li><li><strong>链表处理冲突</strong>：每个桶对应一个链表，冲突的键值对存储在同一链表中，插入、查询时遍历链表即可，无需移动其他数据。</li><li><strong>空间高效</strong>：桶的数量随数据量动态调整，避免固定数组的空间浪费。</li></ul><hr><h2 id="二、核心结构体解析：DynamicHashMap与KeyValueNode"><a href="#二、核心结构体解析：DynamicHashMap与KeyValueNode" class="headerlink" title="二、核心结构体解析：DynamicHashMap与KeyValueNode"></a>二、核心结构体解析：DynamicHashMap与KeyValueNode</h2><h3 id="2-1-KeyValueNode：链表节点"><a href="#2-1-KeyValueNode：链表节点" class="headerlink" title="2.1 KeyValueNode：链表节点"></a>2.1 KeyValueNode：链表节点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct node_s &#123;</span><br><span class="line">    KeyType key;          // 键（字符串指针）</span><br><span class="line">    ValueType val;        // 值（字符串指针）</span><br><span class="line">    struct node_s *next;  // 指向下一个节点的指针（解决冲突）</span><br><span class="line">&#125; KeyValueNode;</span><br></pre></td></tr></table></figure><ul><li><strong>key</strong>：存储键的字符串指针（如&quot;age&quot;）。</li><li><strong>val</strong>：存储值的字符串指针（如&quot;25&quot;）。</li><li><strong>next</strong>：链表指针，用于连接同一桶中冲突的其他键值对。</li></ul><h3 id="2-2-DynamicHashMap：哈希表主体"><a href="#2-2-DynamicHashMap：哈希表主体" class="headerlink" title="2.2 DynamicHashMap：哈希表主体"></a>2.2 DynamicHashMap：哈希表主体</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    KeyValueNode **buckets;  // 动态数组（存储链表头节点）</span><br><span class="line">    int size;                // 当前键值对数量</span><br><span class="line">    int capacity;            // 桶数组的当前容量（桶的数量）</span><br><span class="line">    uint32_t hash_seed;      // 哈希种子（用于生成随机哈希值，防碰撞）</span><br><span class="line">&#125; DynamicHashMap;</span><br></pre></td></tr></table></figure><ul><li><strong>buckets</strong>：动态数组，每个元素是一个链表头节点（<code>KeyValueNode*</code>）。桶的数量由<code>capacity</code>决定。</li><li><strong>size</strong>：当前存储的键值对总数，用于计算负载因子（<code>size/capacity</code>）。</li><li><strong>capacity</strong>：桶数组的容量（即最多有多少个桶）。初始通常设为16，扩容时翻倍。</li><li><strong>hash_seed</strong>：哈希函数的种子，通过<code>time(NULL)</code>随机生成，避免相同输入生成相同哈希值（防碰撞攻击）。</li></ul><hr><h2 id="三、关键函数实现逻辑：从创建到删除"><a href="#三、关键函数实现逻辑：从创建到删除" class="headerlink" title="三、关键函数实现逻辑：从创建到删除"></a>三、关键函数实现逻辑：从创建到删除</h2><h3 id="3-1-hashmap-create-：初始化动态哈希表"><a href="#3-1-hashmap-create-：初始化动态哈希表" class="headerlink" title="3.1 hashmap_create()：初始化动态哈希表"></a>3.1 hashmap_create()：初始化动态哈希表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DynamicHashMap *hashmap_create() &#123;</span><br><span class="line">    DynamicHashMap *map = (DynamicHashMap *)calloc(1, sizeof(DynamicHashMap));</span><br><span class="line">    if (map == NULL) &#123; perror(&quot;map create&quot;); exit(EXIT_FAILURE); &#125;</span><br><span class="line"></span><br><span class="line">    map-&gt;capacity = 16;         // 初始容量（固定为16）</span><br><span class="line">    map-&gt;size = 0;              // 初始无键值对</span><br><span class="line">    map-&gt;hash_seed = (uint32_t)time(NULL); // 随机哈希种子</span><br><span class="line"></span><br><span class="line">    // 初始化桶数组（动态分配内存，每个元素是链表头节点）</span><br><span class="line">    map-&gt;buckets = (KeyValueNode **)calloc(map-&gt;capacity, sizeof(KeyValueNode *));</span><br><span class="line">    if (!map-&gt;buckets) &#123; perror(&quot;map-&gt;buckets creat&quot;); free(map); exit(EXIT_FAILURE); &#125;</span><br><span class="line"></span><br><span class="line">    return map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键细节</strong>：</p><ul><li><strong>内存分配</strong>：使用<code>calloc</code>初始化<code>DynamicHashMap</code>和<code>buckets</code>数组，确保内存清零，避免野指针。</li><li><strong>初始容量</strong>：代码中固定为16，实际项目中可根据需求调整。</li><li><strong>哈希种子</strong>：通过<code>time(NULL)</code>生成随机种子，确保不同运行实例的哈希值分布不同，减少碰撞。</li></ul><h3 id="3-2-hashmap-put-：插入键值对（含扩容逻辑）"><a href="#3-2-hashmap-put-：插入键值对（含扩容逻辑）" class="headerlink" title="3.2 hashmap_put()：插入键值对（含扩容逻辑）"></a>3.2 hashmap_put()：插入键值对（含扩容逻辑）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">ValueType hashmap_put(DynamicHashMap *map, KeyType key, ValueType val) &#123;</span><br><span class="line">    if (!map || !key || !val) return NULL; // 参数校验</span><br><span class="line"></span><br><span class="line">    int index = hash_function(map, key); // 计算哈希值对应的桶索引</span><br><span class="line">    KeyValueNode *current = map-&gt;buckets[index]; // 获取桶的链表头</span><br><span class="line"></span><br><span class="line">    // 1. 查找是否已存在相同键</span><br><span class="line">    while (current) &#123;</span><br><span class="line">        if (strcmp(current-&gt;key, key) == 0) &#123;</span><br><span class="line">            // 键已存在：更新值（释放旧值，存储新值副本）</span><br><span class="line">            free(current-&gt;val);</span><br><span class="line">            current-&gt;val = strdupp(val); // strdupp是新实现的字符串复制函数（防内存泄漏）</span><br><span class="line">            return current-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next; // 遍历链表</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2. 键不存在：新建节点并插入链表头部</span><br><span class="line">    KeyValueNode *new_node = (KeyValueNode *)calloc(1, sizeof(KeyValueNode));</span><br><span class="line">    if (!new_node) return NULL; // 内存分配失败</span><br><span class="line"></span><br><span class="line">    new_node-&gt;key = strdupp(key);   // 复制键（防外部修改）</span><br><span class="line">    new_node-&gt;val = strdupp(val);   // 复制值（防外部修改）</span><br><span class="line">    new_node-&gt;next = map-&gt;buckets[index]; // 新节点插入链表头部</span><br><span class="line">    map-&gt;buckets[index] = new_node;       // 更新链表头</span><br><span class="line">    map-&gt;size++;                        // 键值对数量+1</span><br><span class="line"></span><br><span class="line">    // 3. 检查负载因子，触发扩容（负载因子&gt;0.75时扩容）</span><br><span class="line">    float load_factor = (float)map-&gt;size / map-&gt;capacity;</span><br><span class="line">    if (load_factor &gt; 0.75) &#123;</span><br><span class="line">        if (!hashmap_resize(map)) &#123;       // 扩容失败（如内存不足）</span><br><span class="line">            hashmap_remove(map, key);     // 回滚：删除刚插入的节点</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new_node-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键逻辑</strong>：</p><ul><li><strong>哈希冲突处理</strong>：通过链表存储同一桶中的冲突键值对，插入时遍历链表查找是否存在相同键。</li><li><strong>动态扩容</strong>：当负载因子超过0.75时，调用<code>hashmap_resize</code>将桶数量翻倍，重新哈希所有现有键值对，确保哈希分布均匀。</li><li><strong>内存管理</strong>：使用<code>strdupp</code>复制键和值（避免外部修改影响哈希表内部数据），插入失败时回滚删除节点，防止内存泄漏。</li></ul><h3 id="3-3-hashmap-get-：查询键值对"><a href="#3-3-hashmap-get-：查询键值对" class="headerlink" title="3.3 hashmap_get()：查询键值对"></a>3.3 hashmap_get()：查询键值对</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ValueType hashmap_get(DynamicHashMap *map, KeyType key) &#123;</span><br><span class="line">    if (!map || !key) &#123; printf(&quot;参数错误&quot;); return NULL; &#125;</span><br><span class="line"></span><br><span class="line">    int index = hash_function(map, key); // 计算桶索引</span><br><span class="line">    KeyValueNode *current = map-&gt;buckets[index]; // 获取链表头</span><br><span class="line"></span><br><span class="line">    // 遍历链表查找键</span><br><span class="line">    while (current) &#123;</span><br><span class="line">        if (strcmp(current-&gt;key, key) == 0) &#123;</span><br><span class="line">            return current-&gt;val; // 找到键，返回对应值</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next; // 未找到，继续遍历</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;键未找到&quot;); // 遍历完链表未找到</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键细节</strong>：</p><ul><li><strong>哈希定位</strong>：通过<code>hash_function</code>计算键的哈希值，取模得到桶索引（<code>index = hash % capacity</code>）。</li><li><strong>链表遍历</strong>：从桶的链表头开始遍历，逐个比较键，找到后返回对应值；遍历完链表未找到则返回<code>NULL</code>。</li></ul><h3 id="3-4-hashmap-remove-：删除键值对"><a href="#3-4-hashmap-remove-：删除键值对" class="headerlink" title="3.4 hashmap_remove()：删除键值对"></a>3.4 hashmap_remove()：删除键值对</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bool hashmap_remove(DynamicHashMap *map, KeyType key) &#123;</span><br><span class="line">    if (!map || !key) &#123; printf(&quot;参数错误&quot;); return false; &#125;</span><br><span class="line"></span><br><span class="line">    int index = hash_function(map, key); // 计算桶索引</span><br><span class="line">    KeyValueNode *prev = NULL;           // 记录前一个节点（用于修复链表）</span><br><span class="line">    KeyValueNode *current = map-&gt;buckets[index]; // 当前节点</span><br><span class="line"></span><br><span class="line">    // 遍历链表查找键</span><br><span class="line">    while (current) &#123;</span><br><span class="line">        if (strcmp(current-&gt;key, key) == 0) &#123;</span><br><span class="line">            // 找到键：删除节点</span><br><span class="line">            if (prev) &#123;</span><br><span class="line">                prev-&gt;next = current-&gt;next; // 前一个节点指向当前节点的下一个节点</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                map-&gt;buckets[index] = current-&gt;next; // 头节点删除（更新链表头）</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 释放内存</span><br><span class="line">            free(current-&gt;key);</span><br><span class="line">            free(current-&gt;val);</span><br><span class="line">            free(current);</span><br><span class="line">            map-&gt;size--; // 键值对数量-1</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = current;   // 记录前一个节点</span><br><span class="line">        current = current-&gt;next; // 移动到下一个节点</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false; // 未找到键</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键细节</strong>：</p><ul><li><strong>链表指针修复</strong>：删除节点时，若节点是链表头（<code>prev</code>为<code>NULL</code>），则直接更新桶的链表头为<code>current-&gt;next</code>；否则，将前一个节点的<code>next</code>指向当前节点的下一个节点，确保链表不断裂。</li><li><strong>内存释放</strong>：删除节点后，必须释放其<code>key</code>、<code>val</code>和节点本身的内存，防止内存泄漏。</li></ul><hr><h2 id="四、性能优化点：当前瓶颈与改进方向"><a href="#四、性能优化点：当前瓶颈与改进方向" class="headerlink" title="四、性能优化点：当前瓶颈与改进方向"></a>四、性能优化点：当前瓶颈与改进方向</h2><h3 id="4-1-当前实现的潜在瓶颈"><a href="#4-1-当前实现的潜在瓶颈" class="headerlink" title="4.1 当前实现的潜在瓶颈"></a>4.1 当前实现的潜在瓶颈</h3><ul><li><strong>链表过长导致查询变慢</strong>：当负载因子过高（如接近1）时，链表长度增加，查询时间退化为O(n)（最坏情况遍历整个链表）。</li><li><strong>哈希函数分布不均</strong>：若哈希函数设计不佳（如种子固定），可能导致键值对集中在少数桶中，加剧链表冲突。</li><li><strong>扩容开销</strong>：扩容时需要重新哈希所有现有键值对（时间复杂度O(n)），频繁扩容会影响性能。</li></ul><h3 id="4-2-优化方向"><a href="#4-2-优化方向" class="headerlink" title="4.2 优化方向"></a>4.2 优化方向</h3><ul><li><strong>动态调整扩容阈值</strong>：根据实际场景调整负载因子阈值（如0.75→0.8），平衡空间与时间效率。</li><li><strong>优化冲突结构</strong>：当链表长度超过阈值（如8）时，将链表转换为红黑树（时间复杂度O(log n)），提升长链表的查询效率（Java 8的HashMap即采用此策略）。</li><li><strong>哈希函数优化</strong>：使用更复杂的哈希函数（如MurmurHash），减少哈希碰撞概率，确保键值对均匀分布在各个桶中。</li><li><strong>惰性删除</strong>：对于删除操作，标记节点为“已删除”而非立即释放内存，减少频繁内存分配&#x2F;释放的开销（适用于高频删除场景）。</li></ul><hr><h2 id="五、使用示例：插入、查询、删除操作"><a href="#五、使用示例：插入、查询、删除操作" class="headerlink" title="五、使用示例：插入、查询、删除操作"></a>五、使用示例：插入、查询、删除操作</h2><h3 id="5-1-测试代码说明"><a href="#5-1-测试代码说明" class="headerlink" title="5.1 测试代码说明"></a>5.1 测试代码说明</h3><p>以下是用户提供的测试代码，演示了哈希表的完整生命周期：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    DynamicHashMap *map = hashmap_create(); // 创建哈希表</span><br><span class="line">    if (!map) &#123; /* 错误处理 */ &#125;</span><br><span class="line"></span><br><span class="line">    // 插入键值对</span><br><span class="line">    hashmap_put(map, &quot;name&quot;, &quot;Alice&quot;);    // 插入成功</span><br><span class="line">    hashmap_put(map, &quot;age&quot;, &quot;25&quot;);        // 插入成功</span><br><span class="line"></span><br><span class="line">    // 更新键值对</span><br><span class="line">    hashmap_put(map, &quot;name&quot;, &quot;Bob&quot;);      // 更新成功（原&quot;Alice&quot;被替换为&quot;Bob&quot;）</span><br><span class="line"></span><br><span class="line">    // 查询键值对</span><br><span class="line">    ValueType name = hashmap_get(map, &quot;name&quot;); // 返回&quot;Bob&quot;</span><br><span class="line">    ValueType age = hashmap_get(map, &quot;age&quot;);   // 返回&quot;25&quot;</span><br><span class="line"></span><br><span class="line">    // 删除键值对</span><br><span class="line">    hashmap_remove(map, &quot;age&quot;);           // 删除成功</span><br><span class="line">    hashmap_get(map, &quot;age&quot;);              // 返回NULL（键已删除）</span><br><span class="line"></span><br><span class="line">    hashmap_destroy(map);                 // 销毁哈希表（释放所有内存）</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-注意事项"><a href="#5-2-注意事项" class="headerlink" title="5.2 注意事项"></a>5.2 注意事项</h3><ul><li><strong>内存管理</strong>：插入时<code>strdupp</code>会复制键和值的内存，删除时需手动释放（哈希表内部已处理），避免外部重复释放。</li><li><strong>哈希种子选择</strong>：<code>hash_seed</code>使用<code>time(NULL)</code>随机生成，确保不同运行实例的哈希分布不同，防止恶意构造碰撞攻击。</li><li><strong>负载因子监控</strong>：插入时检查负载因子，触发扩容后需确保新桶数组的内存分配成功（否则回滚删除新插入的节点）。</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文手把手实现了基于「动态数组+链表」的C语言哈希表，详细解析了核心结构体设计、关键函数逻辑及性能优化方向。动态哈希表通过动态扩容和链表冲突解决，兼顾了空间效率与时间效率，是处理动态数据存储的理想选择。实际应用中，可根据需求进一步优化（如红黑树替代长链表），以应对更复杂的场景。</p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">头文件.h</button><button type="button" class="tab">main.c</button><button type="button" class="tab">函数.h</button></div><div class="tab-contents"><div class="tab-item-content active"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#ifndef DYNAMIC_HASHMAP_H</span><br><span class="line">#define DYNAMIC_HASHMAP_H</span><br><span class="line"></span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">typedef char *KeyType;</span><br><span class="line">typedef char *ValueType;</span><br><span class="line"></span><br><span class="line">typedef struct node_s &#123;</span><br><span class="line">    KeyType key;          // 键</span><br><span class="line">    ValueType val;        // 值</span><br><span class="line">    struct node_s *next;  // 链表指针</span><br><span class="line">&#125; KeyValueNode;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    KeyValueNode **buckets;  // 动态数组（哈希桶）</span><br><span class="line">    int size;                // 键值对数量</span><br><span class="line">    int capacity;            // 桶数组容量</span><br><span class="line">    uint32_t hash_seed;      // 哈希种子（防碰撞）</span><br><span class="line">&#125; DynamicHashMap;</span><br><span class="line"></span><br><span class="line">// 创建一个固定容量的哈希表</span><br><span class="line">DynamicHashMap *hashmap_create();</span><br><span class="line">// 销毁一个哈希表</span><br><span class="line">void hashmap_destroy(DynamicHashMap *map);</span><br><span class="line">// 插入一个键值对</span><br><span class="line">ValueType hashmap_put(DynamicHashMap *map, KeyType key, ValueType val);</span><br><span class="line">// 查询一个键值对</span><br><span class="line">ValueType hashmap_get(DynamicHashMap *map, KeyType key);</span><br><span class="line">// 删除某个键值对</span><br><span class="line">bool hashmap_remove(DynamicHashMap *map, KeyType key);</span><br><span class="line"></span><br><span class="line">#endif // DYNAMIC_HASHMAP_H</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;hash.h&quot;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建哈希表</span><br><span class="line">    DynamicHashMap *map = hashmap_create();</span><br><span class="line">    if (!map) &#123;</span><br><span class="line">        fprintf(stderr, &quot;Failed to create hashmap.\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 测试插入操作</span><br><span class="line">    printf(&quot;Testing hashmap_put...\n&quot;);</span><br><span class="line">    const char *key1 = &quot;name&quot;;</span><br><span class="line">    const char *val1 = &quot;Alice&quot;;</span><br><span class="line">    ValueType result1 = hashmap_put(map, (KeyType)key1, (ValueType)val1);</span><br><span class="line">    if (result1) &#123;</span><br><span class="line">        printf(&quot;Inserted key: %s, value: %s\n&quot;, key1, result1);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;Failed to insert key: %s\n&quot;, key1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const char *key2 = &quot;age&quot;;</span><br><span class="line">    const char *val2 = &quot;25&quot;;</span><br><span class="line">    ValueType result2 = hashmap_put(map, (KeyType)key2, (ValueType)val2);</span><br><span class="line">    if (result2) &#123;</span><br><span class="line">        printf(&quot;Inserted key: %s, value: %s\n&quot;, key2, result2);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;Failed to insert key: %s\n&quot;, key2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 测试更新操作</span><br><span class="line">    printf(&quot;\nTesting update...\n&quot;);</span><br><span class="line">    const char *new_val1 = &quot;Bob&quot;;</span><br><span class="line">    ValueType update_result = hashmap_put(map, (KeyType)key1, (ValueType)new_val1);</span><br><span class="line">    if (update_result) &#123;</span><br><span class="line">        printf(&quot;Updated key: %s, new value: %s\n&quot;, key1, update_result);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;Failed to update key: %s\n&quot;, key1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 测试查询操作</span><br><span class="line">    printf(&quot;\nTesting hashmap_get...\n&quot;);</span><br><span class="line">    ValueType get_result1 = hashmap_get(map, (KeyType)key1);</span><br><span class="line">    if (get_result1) &#123;</span><br><span class="line">        printf(&quot;Got key: %s, value: %s\n&quot;, key1, get_result1);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;Key %s not found.\n&quot;, key1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ValueType get_result2 = hashmap_get(map, (KeyType)key2);</span><br><span class="line">    if (get_result2) &#123;</span><br><span class="line">        printf(&quot;Got key: %s, value: %s\n&quot;, key2, get_result2);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;Key %s not found.\n&quot;, key2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 测试删除操作</span><br><span class="line">    printf(&quot;\nTesting hashmap_remove...\n&quot;);</span><br><span class="line">    bool remove_result = hashmap_remove(map, (KeyType)key2);</span><br><span class="line">    if (remove_result) &#123;</span><br><span class="line">        printf(&quot;Removed key: %s successfully.\n&quot;, key2);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;Failed to remove key: %s\n&quot;, key2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 再次查询已删除的键</span><br><span class="line">    ValueType get_after_remove = hashmap_get(map, (KeyType)key2);</span><br><span class="line">    if (get_after_remove) &#123;</span><br><span class="line">        printf(&quot;Got key: %s, value: %s\n&quot;, key2, get_after_remove);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;Key %s not found after removal (expected).\n&quot;, key2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 销毁哈希表</span><br><span class="line">    printf(&quot;\nDestroying hashmap...\n&quot;);</span><br><span class="line">    hashmap_destroy(map);</span><br><span class="line">    printf(&quot;Hashmap destroyed.\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;hash.h&quot;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">// 辅助哈希函数（BKDRHash变种）</span><br><span class="line">static uint32_t hash_function(DynamicHashMap *map, const char *key) &#123;</span><br><span class="line">    uint32_t hash = 0;</span><br><span class="line">    while (*key) &#123;</span><br><span class="line">        hash = hash * map-&gt;hash_seed + (uint8_t)(*key++);</span><br><span class="line">    &#125;</span><br><span class="line">    return hash % map-&gt;capacity;</span><br><span class="line">&#125;</span><br><span class="line">// 创建一个固定容量的哈希表</span><br><span class="line">DynamicHashMap *hashmap_create() &#123;</span><br><span class="line">    DynamicHashMap *map = (DynamicHashMap *)calloc(1, sizeof(DynamicHashMap));</span><br><span class="line">    if (map == NULL) &#123;</span><br><span class="line">        perror(&quot;map create&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    // 初始化参数</span><br><span class="line">    map-&gt;capacity = 16;         // 初始容量</span><br><span class="line">    map-&gt;size = 0;              // 初始键值对数量</span><br><span class="line">    uint32_t hash_seed = (uint32_t)time(NULL); //种子值随机，减少哈希冲突</span><br><span class="line">    map-&gt;buckets = (KeyValueNode **)calloc(map-&gt;capacity, sizeof(KeyValueNode *)); //给二重数组设置初始化桶</span><br><span class="line">    if (!map-&gt;buckets) &#123;</span><br><span class="line">        perror(&quot;map-&gt;buckets creat&quot;);</span><br><span class="line">        free(map);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    return map;</span><br><span class="line">&#125;</span><br><span class="line">// 销毁一个哈希表</span><br><span class="line">void hashmap_destroy(DynamicHashMap *map) &#123;</span><br><span class="line">    if (map == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=0;i&lt;map-&gt;capacity;i++) &#123;</span><br><span class="line">        KeyValueNode *p = map-&gt;buckets[i];</span><br><span class="line">        while (p != NULL) &#123;</span><br><span class="line">            KeyValueNode *next = p-&gt;next;</span><br><span class="line">            free(p-&gt;key);</span><br><span class="line">            free(p-&gt;val);</span><br><span class="line">            free(p);</span><br><span class="line">            p = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(map-&gt;buckets);  // 释放桶数组</span><br><span class="line">    free(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 扩容函数，更新桶容量，所以一个是capacity更新，一个是buckets更新</span><br><span class="line">static bool hashmap_resize(DynamicHashMap *map) &#123;</span><br><span class="line">    KeyValueNode **new_buckets = (KeyValueNode **)calloc((2 * map-&gt;capacity), sizeof(KeyValueNode *));</span><br><span class="line">    if (!new_buckets) &#123;</span><br><span class="line">        perror(&quot;new_buckets create&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //保存旧数据</span><br><span class="line">    KeyValueNode **old_buckets = map-&gt;buckets;</span><br><span class="line">    int old_capacity = map-&gt;capacity;</span><br><span class="line"></span><br><span class="line">    //更新哈希表参数</span><br><span class="line">    map-&gt;capacity *= 2;</span><br><span class="line">    map-&gt;buckets = new_buckets;</span><br><span class="line">    //更新节点</span><br><span class="line">    for (int i = 0; i &lt; old_capacity; i++) &#123;</span><br><span class="line">        KeyValueNode *current = old_buckets[i];</span><br><span class="line">        while (current) &#123;</span><br><span class="line">            KeyValueNode *next = current-&gt;next;</span><br><span class="line">            int index= hash_function(map, current-&gt;key);</span><br><span class="line"></span><br><span class="line">            current-&gt;next = map-&gt;buckets[index];</span><br><span class="line">            map-&gt;buckets[index] = current;  //此处看做指针可能更好理解</span><br><span class="line">            current = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(old_buckets);  // 释放旧桶数组</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">// 复制字符串 strdup被禁用</span><br><span class="line">static ValueType strdupp(const ValueType val) &#123;</span><br><span class="line">    size_t len = strlen(val) + 1;</span><br><span class="line">    ValueType p = (ValueType)malloc(len);</span><br><span class="line">    if (!p) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    if (strcpy_s(p, len, val) != 0) &#123;</span><br><span class="line">        free(p);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line">// 插入一个键值对</span><br><span class="line">ValueType hashmap_put(DynamicHashMap *map, KeyType key, ValueType val) &#123;</span><br><span class="line">    if (!map || !key || !val) return NULL; //保证输出没问题</span><br><span class="line">    int index = hash_function(map,key);</span><br><span class="line">    //查找现有键值，没有就新建，有就顺序插入</span><br><span class="line">    KeyValueNode *current = map-&gt;buckets[index];</span><br><span class="line">    while (current) &#123;</span><br><span class="line">        if (strcmp(current-&gt;key, key) == 0) &#123;</span><br><span class="line">            // 找到重复键，更新值</span><br><span class="line">            free(current-&gt;val);       // 释放旧值</span><br><span class="line">            current-&gt;val = strdupp(val); // 存储新值副本,此处需要新函数，让旧值更新</span><br><span class="line">            if (!current-&gt;val) return NULL; // 内存分配失败处理</span><br><span class="line">            return current-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    //没有这个值，那就新建</span><br><span class="line">    KeyValueNode *new_node = (KeyValueNode *)calloc(1,sizeof(KeyValueNode));</span><br><span class="line">    if (!new_node) return NULL;</span><br><span class="line">    new_node-&gt;key = strdupp(key);</span><br><span class="line">    new_node-&gt;val = strdupp(val);</span><br><span class="line">    if (!new_node-&gt;key || !new_node-&gt;val) &#123; // 内存分配失败处理</span><br><span class="line">        free(new_node-&gt;key);</span><br><span class="line">        free(new_node-&gt;val);</span><br><span class="line">        free(new_node);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    // 插入链表头部</span><br><span class="line">    new_node-&gt;next = map-&gt;buckets[index];</span><br><span class="line">    map-&gt;buckets[index] = new_node;</span><br><span class="line">    map-&gt;size++;</span><br><span class="line"></span><br><span class="line">    //检查负载因子</span><br><span class="line">    float load_factor = (float)map-&gt;size / map-&gt;capacity;</span><br><span class="line">    if (load_factor &gt; 0.75) &#123;</span><br><span class="line">        if (!hashmap_resize(map)) &#123;</span><br><span class="line">            // 扩容失败时删除刚插入的节点（可选）</span><br><span class="line">            hashmap_remove(map, key);</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new_node-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line">// 查询一个键值对，此处跟正常数组一样了</span><br><span class="line">ValueType hashmap_get(DynamicHashMap *map, KeyType key) &#123;</span><br><span class="line">    if (!map || !key) &#123;</span><br><span class="line">        printf(&quot;没有这个值&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int index = hash_function(map, key);</span><br><span class="line">    KeyValueNode *current = map-&gt;buckets[index];</span><br><span class="line">    while (current) &#123;</span><br><span class="line">        if (strcmp(current-&gt;key, key) == 0) &#123;</span><br><span class="line">            return current-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        current=current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;没有这个值&quot;);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line">// 删除某个键值对</span><br><span class="line">bool hashmap_remove(DynamicHashMap *map, KeyType key) &#123;</span><br><span class="line">    if (!map || !key) &#123;</span><br><span class="line">        printf(&quot;没有这个值&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int index = hash_function(map, key);</span><br><span class="line">    KeyValueNode *prev = NULL;</span><br><span class="line">    KeyValueNode *current = map-&gt;buckets[index];</span><br><span class="line">    while (current) &#123;</span><br><span class="line">        if (strcmp(current-&gt;key, key) == 0) &#123;</span><br><span class="line">            if (prev) &#123;</span><br><span class="line">                prev-&gt;next = current-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                map-&gt;buckets[index] = current-&gt;next;  // 头节点删除</span><br><span class="line">            &#125;</span><br><span class="line">            // 释放内存</span><br><span class="line">            free(current-&gt;key);</span><br><span class="line">            free(current-&gt;val);</span><br><span class="line">            free(current);</span><br><span class="line">            map-&gt;size--;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;  // 未找到</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> Data-Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 动态数组 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言文件流：从字符到二进制的三种高效实现</title>
      <link href="/posts/b63aa210/"/>
      <url>/posts/b63aa210/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/18.png" alt="C语言文件流：从字符到二进制的三种高效实现" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在C语言中，文件操作是处理数据存储与传输的核心能力。无论是文本文件还是二进制文件（如图片、视频），复制操作都是最常见的需求。但不同场景下，选择不同的复制方式会直接影响程序的性能与数据完整性。本文将结合三种经典复制实现（字符复制、按行复制、二进制复制），深入解析文件流的核心机制，并给出实战优化建议。</p><hr><h2 id="一、文件流基础：文本模式vs二进制模式"><a href="#一、文件流基础：文本模式vs二进制模式" class="headerlink" title="一、文件流基础：文本模式vs二进制模式"></a>一、文件流基础：文本模式vs二进制模式</h2><h3 id="1-1-文件打开模式的选择"><a href="#1-1-文件打开模式的选择" class="headerlink" title="1.1 文件打开模式的选择"></a>1.1 文件打开模式的选择</h3><p>C语言中，<code>fopen</code>函数的第二个参数（模式）决定了文件的读写方式。最常用的模式有：</p><ul><li><strong>文本模式（&quot;r&quot;&#x2F;&quot;w&quot;&#x2F;&quot;a&quot;）</strong>：以字符形式读写，自动处理换行符转换（如Windows的<code>\r </code>转Unix的<code> </code>）。</li><li><strong>二进制模式（&quot;rb&quot;&#x2F;&quot;wb&quot;&#x2F;&quot;ab&quot;）</strong>：以字节形式直接读写，不进行任何转换。</li></ul><h3 id="1-2-为什么复制二进制文件必须用二进制模式？"><a href="#1-2-为什么复制二进制文件必须用二进制模式？" class="headerlink" title="1.2 为什么复制二进制文件必须用二进制模式？"></a>1.2 为什么复制二进制文件必须用二进制模式？</h3><p>二进制文件（如图片、视频、可执行文件）的每个字节都有特定含义，<strong>任何格式转换都会破坏数据完整性</strong>。例如：</p><ul><li>文本模式下，<code>fgetc</code>会将<code>\r </code>（Windows换行符）转换为<code> </code>（Unix换行符），导致二进制文件内容被篡改。</li><li>二进制模式下，<code>fread</code>和<code>fwrite</code>直接按字节读写，完全保留原始数据。</li></ul><p><strong>结论</strong>：复制二进制文件（如图片、视频）时，必须使用二进制模式（&quot;rb&quot;&#x2F;&quot;wb&quot;）；复制文本文件时，可根据需求选择文本或二进制模式（文本模式更易读，二进制模式更安全）。</p><hr><h2 id="二、三种复制方式解析：从字符到二进制"><a href="#二、三种复制方式解析：从字符到二进制" class="headerlink" title="二、三种复制方式解析：从字符到二进制"></a>二、三种复制方式解析：从字符到二进制</h2><h3 id="2-1-copy-file-char：按字符复制（fgetc-fputc）"><a href="#2-1-copy-file-char：按字符复制（fgetc-fputc）" class="headerlink" title="2.1 copy_file_char：按字符复制（fgetc&#x2F;fputc）"></a>2.1 copy_file_char：按字符复制（fgetc&#x2F;fputc）</h3><h4 id="原理与适用场景"><a href="#原理与适用场景" class="headerlink" title="原理与适用场景"></a>原理与适用场景</h4><p><code>copy_file_char</code>通过<code>fgetc</code>（从源文件读取一个字符）和<code>fputc</code>（向目标文件写入一个字符）实现逐字符复制。其逻辑简单，适合<strong>小文件或文本文件</strong>（如配置文件、日志）。</p><h4 id="代码细节与潜在问题"><a href="#代码细节与潜在问题" class="headerlink" title="代码细节与潜在问题"></a>代码细节与潜在问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void copy_file_char(const char *src_file, const char *dest_file) &#123;</span><br><span class="line">    int ret;</span><br><span class="line">    FILE *src = fopen(src_file, &quot;r&quot;);   // 文本模式读取（可能转换换行符）</span><br><span class="line">    FILE *dst = fopen(dest_file, &quot;w&quot;);  // 文本模式写入（可能转换换行符）</span><br><span class="line">    if (!src || !dst) &#123; /* 错误处理 */ &#125;</span><br><span class="line"></span><br><span class="line">    while ((ret = fgetc(src)) != EOF) &#123; // 逐个字符读取</span><br><span class="line">        fputc(ret, dst);                // 逐个字符写入</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(src);</span><br><span class="line">    fclose(dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>优点</strong>：代码简单，易于理解；适合小文件（如几百KB的文本）。</li><li><strong>缺点</strong>：频繁调用<code>fgetc</code>和<code>fputc</code>会导致大量IO操作，性能低下（大文件复制时耗时显著增加）；文本模式下可能意外转换换行符（如跨平台复制）。</li></ul><hr><h3 id="2-2-copy-file-line：按行复制（fgets-fputs）"><a href="#2-2-copy-file-line：按行复制（fgets-fputs）" class="headerlink" title="2.2 copy_file_line：按行复制（fgets&#x2F;fputs）"></a>2.2 copy_file_line：按行复制（fgets&#x2F;fputs）</h3><h4 id="原理与适用场景-1"><a href="#原理与适用场景-1" class="headerlink" title="原理与适用场景"></a>原理与适用场景</h4><p><code>copy_file_line</code>通过<code>fgets</code>（读取一行，最多<code>Maxsize-1</code>字符）和<code>fputs</code>（写入一行）实现按行复制。其缓冲区<code>Maxsize</code>（示例中为1024）平衡了内存占用与IO效率，适合<strong>文本文件</strong>（需保留换行符）。</p><h4 id="代码细节与优化点"><a href="#代码细节与优化点" class="headerlink" title="代码细节与优化点"></a>代码细节与优化点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define Maxsize 1024</span><br><span class="line">void copy_file_line(const char *src_file, const char *dest_file) &#123;</span><br><span class="line">    char buf[Maxsize];</span><br><span class="line">    FILE *src = fopen(src_file, &quot;r&quot;);</span><br><span class="line">    FILE *dst = fopen(dest_file, &quot;w&quot;);</span><br><span class="line">    if (!src || !dst) &#123; /* 错误处理 */ &#125;</span><br><span class="line"></span><br><span class="line">    while (fgets(buf, Maxsize, src) != NULL) &#123; // 读取一行（最多Maxsize-1字符）</span><br><span class="line">        fputs(buf, dst);                       // 写入一行（保留换行符）</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(src);</span><br><span class="line">    fclose(dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>优点</strong>：通过缓冲区减少IO次数（每行一次IO），比逐字符复制快；保留换行符，适合文本文件。</li><li><strong>缺点</strong>：若行过长（超过<code>Maxsize</code>），<code>fgets</code>会截断数据；仍存在IO开销（每行一次读写）。</li></ul><hr><h3 id="2-3-binary-file-cpy：二进制复制（fread-fwrite）"><a href="#2-3-binary-file-cpy：二进制复制（fread-fwrite）" class="headerlink" title="2.3 binary_file_cpy：二进制复制（fread&#x2F;fwrite）"></a>2.3 binary_file_cpy：二进制复制（fread&#x2F;fwrite）</h3><h4 id="原理与核心设计"><a href="#原理与核心设计" class="headerlink" title="原理与核心设计"></a>原理与核心设计</h4><p><code>binary_file_cpy</code>通过<code>fread</code>（读取二进制数据块）和<code>fwrite</code>（写入二进制数据块）实现高效复制。其使用<strong>4KB缓冲区</strong>（示例中为<code>char buf[4096]</code>），平衡了IO次数与内存占用，适合<strong>二进制文件</strong>（如图片、视频）。</p><h4 id="代码细节与数据完整性保证"><a href="#代码细节与数据完整性保证" class="headerlink" title="代码细节与数据完整性保证"></a>代码细节与数据完整性保证</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void binary_file_cpy(const char *src_file, const char *dest_file) &#123;</span><br><span class="line">    char buf[4096];       // 4KB缓冲区（平衡IO效率与内存）</span><br><span class="line">    size_t read_size;     // 实际读取的字节数</span><br><span class="line">    FILE *src = fopen(src_file, &quot;rb&quot;);  // 二进制模式读取（无转换）</span><br><span class="line">    FILE *dst = fopen(dest_file, &quot;wb&quot;); // 二进制模式写入（无转换）</span><br><span class="line">    if (!src || !dst) &#123; /* 错误处理 */ &#125;</span><br><span class="line"></span><br><span class="line">    while ((read_size = fread(buf, 1, sizeof(buf), src)) &gt; 0) &#123; </span><br><span class="line">        // 写入实际读取的字节数（避免最后一次读取不足缓冲区大小时出错）</span><br><span class="line">        fwrite(buf, 1, read_size, dst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(src);</span><br><span class="line">    fclose(dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关键设计：<ul><li><strong>4KB缓冲区</strong>：选择4KB（4096字节）是经验值，兼顾内存占用（4KB对现代内存可忽略）与IO次数（减少磁盘寻道时间）。</li><li><strong>写入实际读取的字节数</strong>：<code>fread</code>返回实际读取的字节数（如最后一次读取可能不足4KB），<code>fwrite</code>需写入相同字节数，避免数据丢失或多写。</li></ul></li><li><strong>优点</strong>：IO次数少（每4KB一次），速度快；二进制模式保证数据完整性。</li><li><strong>缺点</strong>：无法保留文本文件的换行符（但对二进制文件无影响）。</li></ul><hr><h2 id="三、代码细节与优化：错误处理与性能对比"><a href="#三、代码细节与优化：错误处理与性能对比" class="headerlink" title="三、代码细节与优化：错误处理与性能对比"></a>三、代码细节与优化：错误处理与性能对比</h2><h3 id="3-1-错误处理：避免空指针崩溃"><a href="#3-1-错误处理：避免空指针崩溃" class="headerlink" title="3.1 错误处理：避免空指针崩溃"></a>3.1 错误处理：避免空指针崩溃</h3><p>文件操作中最常见的错误是<code>fopen</code>失败（如文件不存在、权限不足）。必须检查返回的<code>FILE*</code>是否为<code>NULL</code>，并关闭已打开的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 正确示例：检查fopen失败</span><br><span class="line">FILE *src = fopen(src_file, &quot;rb&quot;);</span><br><span class="line">if (!src) &#123;</span><br><span class="line">    perror(&quot;源文件打开失败&quot;); // 输出错误信息（如“权限不足”）</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FILE *dst = fopen(dest_file, &quot;wb&quot;);</span><br><span class="line">if (!dst) &#123;</span><br><span class="line">    perror(&quot;目标文件打开失败&quot;);</span><br><span class="line">    fclose(src);  // 关闭已打开的源文件，避免资源泄漏</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-性能对比：三种方法的耗时差异"><a href="#3-2-性能对比：三种方法的耗时差异" class="headerlink" title="3.2 性能对比：三种方法的耗时差异"></a>3.2 性能对比：三种方法的耗时差异</h3><p>通过测试大文件（如100MB）复制耗时，可验证三种方法的性能差异（实际结果因硬件而异）：</p><ul><li><strong>copy_file_char</strong>：最慢（频繁IO，约10秒）。</li><li><strong>copy_file_line</strong>：中等（每行一次IO，约2秒）。</li><li><strong>binary_file_cpy</strong>：最快（4KB缓冲区，约0.5秒）。</li></ul><p><strong>结论</strong>：二进制复制（<code>fread</code>&#x2F;<code>fwrite</code>）是最优选择，尤其适合大文件。</p><hr><h2 id="四、扩展思考：带进度条与超大型文件处理"><a href="#四、扩展思考：带进度条与超大型文件处理" class="headerlink" title="四、扩展思考：带进度条与超大型文件处理"></a>四、扩展思考：带进度条与超大型文件处理</h2><h3 id="4-1-带进度条的复制"><a href="#4-1-带进度条的复制" class="headerlink" title="4.1 带进度条的复制"></a>4.1 带进度条的复制</h3><p>要实现进度条，需计算已复制数据量与总数据量的比例。可通过<code>fseek</code>和<code>ftell</code>获取文件总大小（仅适用于可随机访问的文件）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 在binary_file_cpy中添加进度条</span><br><span class="line">void binary_file_cpy_with_progress(const char *src_file, const char *dest_file) &#123;</span><br><span class="line">    FILE *src = fopen(src_file, &quot;rb&quot;);</span><br><span class="line">    fseek(src, 0, SEEK_END);</span><br><span class="line">    long total_size = ftell(src); // 总字节数</span><br><span class="line">    fseek(src, 0, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    FILE *dst = fopen(dest_file, &quot;wb&quot;);</span><br><span class="line">    char buf[4096];</span><br><span class="line">    size_t read_size;</span><br><span class="line">    long copied = 0;</span><br><span class="line"></span><br><span class="line">    while ((read_size = fread(buf, 1, sizeof(buf), src)) &gt; 0) &#123;</span><br><span class="line">        fwrite(buf, 1, read_size, dst);</span><br><span class="line">        copied += read_size;</span><br><span class="line">        printf(&quot;\r进度: %.2f%%&quot;, (double)copied / total_size * 100);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n复制完成！\n&quot;);</span><br><span class="line">    fclose(src);</span><br><span class="line">    fclose(dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-超大型文件处理：分块读取-多线程"><a href="#4-2-超大型文件处理：分块读取-多线程" class="headerlink" title="4.2 超大型文件处理：分块读取+多线程"></a>4.2 超大型文件处理：分块读取+多线程</h3><p>对于超大型文件（如数GB），可采用<strong>分块读取+多线程</strong>提升速度：</p><ul><li><strong>分块读取</strong>：将文件划分为多个块（如每块1MB），并行读取不同块。</li><li><strong>多线程写入</strong>：每个线程负责写入一个块，最后合并。</li></ul><p>（注：多线程需处理线程同步与文件指针管理，复杂度较高，需谨慎实现。）</p><hr><h2 id="五、使用示例：复制图片-视频的二进制实现"><a href="#五、使用示例：复制图片-视频的二进制实现" class="headerlink" title="五、使用示例：复制图片&#x2F;视频的二进制实现"></a>五、使用示例：复制图片&#x2F;视频的二进制实现</h2><p>复制二进制文件（如图片）时，必须使用二进制模式，并确保缓冲区足够大以减少IO次数。以下是调用<code>binary_file_cpy</code>复制图片的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(void) &#123;</span><br><span class="line">    const char *src_img = &quot;photo.jpg&quot;;</span><br><span class="line">    const char *dest_img = &quot;photo_copy.jpg&quot;;</span><br><span class="line"></span><br><span class="line">    // 复制图片（二进制模式）</span><br><span class="line">    binary_file_cpy(src_img, dest_img);</span><br><span class="line"></span><br><span class="line">    printf(&quot;图片复制完成！&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>避免文本模式</strong>：若用文本模式（&quot;r&quot;&#x2F;&quot;w&quot;）复制图片，换行符转换会破坏二进制数据，导致图片无法打开。</li><li><strong>缓冲区大小</strong>：二进制复制建议使用4KB或更大的缓冲区（如8KB），平衡IO效率与内存占用。</li><li><strong>错误处理</strong>：必须检查<code>fopen</code>返回值，避免空指针操作；复制完成后检查<code>fclose</code>是否成功（可选）。</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细解析了C语言中三种文件流复制方式的原理与适用场景：</p><ul><li><strong>字符复制</strong>（<code>fgetc</code>&#x2F;<code>fputc</code>）：简单但低效，适合小文本文件。</li><li><strong>按行复制</strong>（<code>fgets</code>&#x2F;<code>fputs</code>）：平衡IO与内存，适合需保留换行符的文本文件。</li><li><strong>二进制复制</strong>（<code>fread</code>&#x2F;<code>fwrite</code>）：高效且安全，适合二进制文件（如图片、视频）。</li></ul><p>实际开发中，应根据文件类型（文本&#x2F;二进制）和大小（小&#x2F;大）选择合适的复制方式。对于大文件或性能敏感场景，推荐使用二进制复制，并可结合分块或多线程进一步优化。</p>]]></content>
      
      
      <categories>
          
          <category> C-Code </category>
          
          <category> Foundational Syntax and Core Concepts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 文件流 </tag>
            
            <tag> 二进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0到1实现C语言哈希表：底层原理与实战解析</title>
      <link href="/posts/95859935/"/>
      <url>/posts/95859935/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/13.png" alt="从0到1实现C语言哈希表：底层原理与实战解析" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在C语言的标准库中，没有像C++ <code>unordered_map</code>或Java <code>HashMap</code>这样现成的哈希表容器。当我们需要在C中实现高效的键值对存储时，手动实现一个哈希表是绕不开的选择。本文将以我近期实现的轻量级哈希表为例，从数据结构设计、核心逻辑解析到内存管理，带您深入理解哈希表的底层原理，并结合实际测试用例验证其正确性。</p><hr><h2 id="一、为什么需要自己实现哈希表？"><a href="#一、为什么需要自己实现哈希表？" class="headerlink" title="一、为什么需要自己实现哈希表？"></a>一、为什么需要自己实现哈希表？</h2><p>在开始代码解析前，先聊聊<strong>为什么选择手动实现哈希表</strong>：</p><ul><li><strong>场景适配</strong>：标准库未提供通用哈希表（C++的<code>unordered_map</code>依赖模板，无法直接用于纯C项目）。</li><li><strong>性能可控</strong>：手动实现可以针对具体场景优化（如自定义哈希函数、内存分配策略）。</li><li><strong>学习价值</strong>：理解哈希表的核心原理（哈希冲突、负载因子、动态扩容），是进阶C语言开发的必经之路。</li></ul><p>本文的哈希表实现定位为<strong>轻量级字符串键值对存储</strong>，适用于配置管理、缓存系统等需要快速查找的场景。</p><hr><h2 id="二、数据结构设计：从抽象到具体"><a href="#二、数据结构设计：从抽象到具体" class="headerlink" title="二、数据结构设计：从抽象到具体"></a>二、数据结构设计：从抽象到具体</h2><h3 id="2-1-哈希表的核心结构体：HashMap"><a href="#2-1-哈希表的核心结构体：HashMap" class="headerlink" title="2.1 哈希表的核心结构体：HashMap"></a>2.1 哈希表的核心结构体：<code>HashMap</code></h3><p>哈希表的本质是“数组+链表”的组合结构。我们通过一个数组（哈希桶）存储链表头节点，每个链表节点保存具体的键值对。以下是核心结构体的定义（<code>hash.h</code>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// hash.h</span><br><span class="line">typedef char *KeyType;   // 键类型：字符串指针</span><br><span class="line">typedef char *ValueType; // 值类型：字符串指针</span><br><span class="line"></span><br><span class="line">// 哈希桶节点（链表节点）</span><br><span class="line">typedef struct node_s &#123;</span><br><span class="line">    KeyType key;          // 键（字符串）</span><br><span class="line">    ValueType val;        // 值（字符串）</span><br><span class="line">    struct node_s *next;  // 下一个节点指针（解决哈希冲突）</span><br><span class="line">&#125; KeyValueNode;</span><br><span class="line"></span><br><span class="line">// 哈希表核心结构体</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    KeyValueNode *buckets[HASHMAP_CAPACITY];  // 哈希桶数组（固定容量10）</span><br><span class="line">    uint32_t hash_seed;                       // 哈希函数种子（随机化防碰撞攻击）</span><br><span class="line">&#125; HashMap;</span><br></pre></td></tr></table></figure><h4 id="关键设计点解析："><a href="#关键设计点解析：" class="headerlink" title="关键设计点解析："></a>关键设计点解析：</h4><ul><li><strong><code>buckets</code>数组</strong>：哈希表的“骨架”，每个元素是一个链表头节点。当不同键通过哈希函数映射到同一位置时，链表用于存储冲突的键值对（链地址法解决冲突）。</li><li><strong><code>hash_seed</code>种子</strong>：哈希函数的随机化参数。通过<code>time(NULL)</code>初始化，避免相同输入生成相同哈希值（防御哈希碰撞攻击）。</li></ul><hr><h3 id="2-2-辅助函数：strdup1"><a href="#2-2-辅助函数：strdup1" class="headerlink" title="2.2 辅助函数：strdup1"></a>2.2 辅助函数：<code>strdup1</code></h3><p>由于C语言中字符串是<code>char*</code>指针，直接赋值会导致浅拷贝（多个指针指向同一块内存）。因此，我们需要自定义字符串复制函数<code>strdup1</code>（<code>hash.c</code>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// hash.c</span><br><span class="line">char *strdup1(const char *s) &#123;</span><br><span class="line">    size_t len = strlen(s) + 1;  // +1 用于存储字符串结束符&#x27;\0&#x27;</span><br><span class="line">    char *p = (char *)malloc(len); </span><br><span class="line">    if (p) &#123;</span><br><span class="line">        memcpy(p, s, len);  // 深拷贝字符串内容</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作用</strong>：为键和值生成独立的副本，避免外部修改影响哈希表内部数据。</p><hr><h2 id="三、核心函数解析：从创建到销毁"><a href="#三、核心函数解析：从创建到销毁" class="headerlink" title="三、核心函数解析：从创建到销毁"></a>三、核心函数解析：从创建到销毁</h2><h3 id="3-1-创建哈希表：hashmap-create"><a href="#3-1-创建哈希表：hashmap-create" class="headerlink" title="3.1 创建哈希表：hashmap_create"></a>3.1 创建哈希表：<code>hashmap_create</code></h3><p>哈希表的创建需要初始化<code>buckets</code>数组和随机种子。以下是实现代码（<code>hash.c</code>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// hash.c</span><br><span class="line">HashMap *hashmap_create() &#123;</span><br><span class="line">    HashMap *map = (HashMap *)calloc(1, sizeof(HashMap));  // 分配哈希表内存</span><br><span class="line">    if (map == NULL) &#123;</span><br><span class="line">        printf(&quot;calloc failed in hashmap_create</span><br><span class="line">&quot;);  // 内存分配失败提示</span><br><span class="line">        exit(EXIT_FAILURE);  // 终止程序（避免后续操作崩溃）</span><br><span class="line">    &#125;</span><br><span class="line">    // 初始化哈希种子（基于当前时间戳，保证每次运行种子不同）</span><br><span class="line">    map-&gt;hash_seed = (uint32_t)time(NULL); </span><br><span class="line">    return map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键步骤</strong>：</p><ol><li>使用<code>calloc</code>分配哈希表内存（初始化为0），避免脏数据。</li><li>初始化<code>hash_seed</code>为当前时间戳，确保每次运行的哈希值随机化。</li></ol><p><strong>个人思考</strong>：为什么不直接用<code>rand()</code>初始化种子？因为<code>time(NULL)</code>的精度更高（秒级），而<code>rand()</code>的随机性依赖于种子，可能导致不同运行实例的哈希冲突率波动较大。</p><hr><h3 id="3-2-销毁哈希表：hashmap-destroy"><a href="#3-2-销毁哈希表：hashmap-destroy" class="headerlink" title="3.2 销毁哈希表：hashmap_destroy"></a>3.2 销毁哈希表：<code>hashmap_destroy</code></h3><p>销毁哈希表需要递归释放所有节点的内存，避免内存泄漏。实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// hash.c</span><br><span class="line">void hashmap_destroy(HashMap *map) &#123;</span><br><span class="line">    if (map == NULL) return;  // 空指针直接返回</span><br><span class="line"></span><br><span class="line">    // 遍历所有哈希桶</span><br><span class="line">    for (int i = 0; i &lt; HASHMAP_CAPACITY; i++) &#123;</span><br><span class="line">        KeyValueNode *current = map-&gt;buckets[i];  // 当前桶的头节点</span><br><span class="line">        while (current != NULL) &#123;                 // 遍历链表</span><br><span class="line">            KeyValueNode *next = current-&gt;next;   // 保存下一个节点指针</span><br><span class="line">            free(current-&gt;key);   // 释放键的内存</span><br><span class="line">            free(current-&gt;val);   // 释放值的内存</span><br><span class="line">            free(current);        // 释放节点本身的内存</span><br><span class="line">            current = next;       // 移动到下一个节点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(map);  // 释放哈希表本身的内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键细节</strong>：</p><ul><li><strong>链表遍历</strong>：通过<code>current</code>指针逐个释放链表节点，避免遗漏。</li><li><strong>内存释放顺序</strong>：先释放节点的键和值（深拷贝的内存），再释放节点本身，最后释放哈希表。</li></ul><p><strong>常见错误</strong>：若忘记释放<code>current-&gt;key</code>或<code>current-&gt;val</code>，会导致内存泄漏（尤其是在频繁插入删除的场景下）。</p><hr><h3 id="3-3-插入-更新键值对：hashmap-put"><a href="#3-3-插入-更新键值对：hashmap-put" class="headerlink" title="3.3 插入&#x2F;更新键值对：hashmap_put"></a>3.3 插入&#x2F;更新键值对：<code>hashmap_put</code></h3><p>插入操作是哈希表的核心功能，需要处理两种情况：键已存在（更新值）或键不存在（新建节点）。实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// hash.c</span><br><span class="line">ValueType hashmap_put(HashMap *map, KeyType key, ValueType val) &#123;</span><br><span class="line">    if (map == NULL || key == NULL || val == NULL) return NULL;  // 参数校验</span><br><span class="line"></span><br><span class="line">    // 1. 计算哈希值，确定桶的位置</span><br><span class="line">    uint32_t index = hash(key, map-&gt;hash_seed); </span><br><span class="line"></span><br><span class="line">    // 2. 遍历桶内链表，检查键是否已存在</span><br><span class="line">    KeyValueNode *current = map-&gt;buckets[index];</span><br><span class="line">    while (current != NULL) &#123;</span><br><span class="line">        if (strcmp(current-&gt;key, key) == 0) &#123;  // 键已存在</span><br><span class="line">            free(current-&gt;val);                 // 释放旧值内存</span><br><span class="line">            current-&gt;val = strdup1(val);         // 更新为新值（深拷贝）</span><br><span class="line">            return current-&gt;val;                 // 返回新值</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;  // 移动到下一个节点</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3. 键不存在，创建新节点并插入链表头部（头插法）</span><br><span class="line">    KeyValueNode *new_node = (KeyValueNode *)calloc(1, sizeof(KeyValueNode));</span><br><span class="line">    if (new_node == NULL) &#123;  // 内存分配失败处理</span><br><span class="line">        fprintf(stderr, &quot;Memory allocation failed in hashmap_put</span><br><span class="line">&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    new_node-&gt;key = strdup1(key);   // 深拷贝键</span><br><span class="line">    new_node-&gt;val = strdup1(val);   // 深拷贝值</span><br><span class="line">    new_node-&gt;next = map-&gt;buckets[index];  // 新节点指向原链表头</span><br><span class="line">    map-&gt;buckets[index] = new_node;        // 头插法更新链表头</span><br><span class="line"></span><br><span class="line">    return new_node-&gt;val;  // 返回新值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键逻辑解析</strong>：</p><ul><li><strong>哈希计算</strong>：通过<code>hash</code>函数将键转换为桶的索引（<code>0~9</code>）。</li><li><strong>冲突处理</strong>：若键已存在，更新对应节点的值（释放旧值内存，避免泄漏）；若不存在，通过头插法在链表头部插入新节点（时间复杂度O(1)平均情况）。</li></ul><p><strong>性能优化</strong>：头插法比尾插法更高效（无需遍历到链表尾部），但会导致链表节点顺序与插入顺序相反。对于哈希表来说，顺序无关紧要，因此头插法是更优选择。</p><hr><h3 id="3-4-查询键对应的值：hashmap-get"><a href="#3-4-查询键对应的值：hashmap-get" class="headerlink" title="3.4 查询键对应的值：hashmap_get"></a>3.4 查询键对应的值：<code>hashmap_get</code></h3><p>查询操作需要根据键计算哈希值，然后在对应桶的链表中查找目标键。实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// hash.c</span><br><span class="line">ValueType hashmap_get(HashMap *map, KeyType key) &#123;</span><br><span class="line">    if (map == NULL || key == NULL) return NULL;  // 参数校验</span><br><span class="line"></span><br><span class="line">    // 1. 计算哈希值，确定桶的位置</span><br><span class="line">    uint32_t index = hash(key, map-&gt;hash_seed); </span><br><span class="line"></span><br><span class="line">    // 2. 遍历桶内链表，查找目标键</span><br><span class="line">    KeyValueNode *current = map-&gt;buckets[index];</span><br><span class="line">    while (current != NULL) &#123;</span><br><span class="line">        if (strcmp(current-&gt;key, key) == 0) &#123;  // 找到目标键</span><br><span class="line">            return current-&gt;val;               // 返回对应值</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;  // 移动到下一个节点</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return NULL;  // 未找到键</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键细节</strong>：</p><ul><li><strong>参数校验</strong>：避免空指针导致的崩溃（如传入<code>NULL</code>键）。</li><li><strong>线性查找</strong>：链表的查找时间复杂度为O(n)，但哈希表通过哈希函数将n限制在桶的数量（<code>HASHMAP_CAPACITY=10</code>），因此平均时间复杂度仍为O(1)。</li></ul><p><strong>测试验证</strong>：在<code>main.c</code>中插入<code>&quot;name&quot;</code>和<code>&quot;age&quot;</code>后，查询<code>&quot;name&quot;</code>应返回<code>&quot;Alice&quot;</code>，查询<code>&quot;age&quot;</code>应返回<code>&quot;25&quot;</code>。</p><hr><h3 id="3-5-删除键值对：hashmap-remove"><a href="#3-5-删除键值对：hashmap-remove" class="headerlink" title="3.5 删除键值对：hashmap_remove"></a>3.5 删除键值对：<code>hashmap_remove</code></h3><p>删除操作需要找到目标键所在的节点，并从链表中移除该节点。实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// hash.c</span><br><span class="line">bool hashmap_remove(HashMap *map, KeyType key) &#123;</span><br><span class="line">    if (map == NULL || key == NULL) return false;  // 参数校验</span><br><span class="line"></span><br><span class="line">    // 1. 计算哈希值，确定桶的位置</span><br><span class="line">    uint32_t index = hash(key, map-&gt;hash_seed); </span><br><span class="line"></span><br><span class="line">    // 2. 遍历链表，查找目标键并删除</span><br><span class="line">    KeyValueNode *current = map-&gt;buckets[index];</span><br><span class="line">    KeyValueNode *prev = NULL;  // 记录前一个节点指针</span><br><span class="line"></span><br><span class="line">    while (current != NULL) &#123;</span><br><span class="line">        if (strcmp(current-&gt;key, key) == 0) &#123;  // 找到目标键</span><br><span class="line">            // 情况1：节点是链表头（prev为NULL）</span><br><span class="line">            if (prev == NULL) &#123;</span><br><span class="line">                map-&gt;buckets[index] = current-&gt;next;  // 头指针指向下一节点</span><br><span class="line">            &#125; </span><br><span class="line">            // 情况2：节点是链表中间或尾部（prev不为NULL）</span><br><span class="line">            else &#123;</span><br><span class="line">                prev-&gt;next = current-&gt;next;  // 前一个节点指向下一节点</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 释放节点内存</span><br><span class="line">            free(current-&gt;key);   // 释放键</span><br><span class="line">            free(current-&gt;val);   // 释放值</span><br><span class="line">            free(current);        // 释放节点本身</span><br><span class="line">            return true;          // 删除成功</span><br><span class="line">        &#125;</span><br><span class="line">        prev = current;       // 记录当前节点为前一个节点</span><br><span class="line">        current = current-&gt;next;  // 移动到下一个节点</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;  // 未找到键</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键逻辑解析</strong>：</p><ul><li><strong>头节点删除</strong>：若目标节点是链表头（<code>prev == NULL</code>），直接更新桶的头指针为<code>current-&gt;next</code>。</li><li><strong>中间&#x2F;尾部节点删除</strong>：若目标节点在链表中间或尾部，通过前一个节点<code>prev</code>的<code>next</code>指针跳过当前节点。</li></ul><p><strong>测试验证</strong>：删除<code>&quot;age&quot;</code>后，再次查询<code>&quot;age&quot;</code>应返回<code>NULL</code>，且<code>main.c</code>中的验证语句会输出<code>&#39;age&#39; not found after removal.</code>。</p><hr><h2 id="四、哈希函数设计：从原理到实现"><a href="#四、哈希函数设计：从原理到实现" class="headerlink" title="四、哈希函数设计：从原理到实现"></a>四、哈希函数设计：从原理到实现</h2><p>哈希函数的质量直接影响哈希表的性能（冲突率）。本文实现的哈希函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// hash.c</span><br><span class="line">static uint32_t hash(const char *key, uint32_t seed) &#123;</span><br><span class="line">    uint32_t hash_val = 0;</span><br><span class="line">    while (*key) &#123;  // 遍历字符串的每个字符</span><br><span class="line">        hash_val = (hash_val * 31) + (uint32_t)*key++;  // 经典多项式哈希</span><br><span class="line">    &#125;</span><br><span class="line">    return (hash_val ^ seed) % HASHMAP_CAPACITY;  // 结合种子值取模</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设计思想："><a href="#设计思想：" class="headerlink" title="设计思想："></a>设计思想：</h3><ul><li><strong>多项式哈希</strong>：<code>hash_val = hash_val * 31 + *key</code> 是经典的字符串哈希算法（31是质数，能有效减少冲突）。</li><li><strong>随机种子</strong>：通过<code>seed</code>（时间戳）对哈希值取异或，避免相同输入生成相同哈希值（防御碰撞攻击）。</li><li><strong>取模运算</strong>：将哈希值映射到<code>[0, HASHMAP_CAPACITY-1]</code>的范围，确定桶的位置。</li></ul><p><strong>潜在改进</strong>：若需要更高的性能，可以尝试其他哈希算法（如MurmurHash），但多项式哈希在字符串场景下已足够高效。</p><hr><h2 id="五、测试与验证：从理论到实践"><a href="#五、测试与验证：从理论到实践" class="headerlink" title="五、测试与验证：从理论到实践"></a>五、测试与验证：从理论到实践</h2><h3 id="5-1-测试用例说明（main-c）"><a href="#5-1-测试用例说明（main-c）" class="headerlink" title="5.1 测试用例说明（main.c）"></a>5.1 测试用例说明（<code>main.c</code>）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;hash.h&quot;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    HashMap *map = hashmap_create();  // 创建哈希表</span><br><span class="line">    if (map == NULL) return 1;        // 内存分配失败处理</span><br><span class="line"></span><br><span class="line">    // 插入键值对</span><br><span class="line">    hashmap_put(map, &quot;name&quot;, &quot;Alice&quot;);  // 插入字符串键值对</span><br><span class="line">    hashmap_put(map, &quot;age&quot;, &quot;25&quot;);</span><br><span class="line"></span><br><span class="line">    // 查询键值对</span><br><span class="line">    ValueType name = hashmap_get(map, &quot;name&quot;);  // 获取&quot;name&quot;对应的值</span><br><span class="line">    ValueType age = hashmap_get(map, &quot;age&quot;);</span><br><span class="line">    if (name) printf(&quot;Name: %s</span><br><span class="line">&quot;, name);         // 输出：Name: Alice</span><br><span class="line">    if (age)  printf(&quot;Age: %s</span><br><span class="line">&quot;, age);          // 输出：Age: 25</span><br><span class="line"></span><br><span class="line">    // 删除键值对</span><br><span class="line">    if (hashmap_remove(map, &quot;age&quot;)) &#123;</span><br><span class="line">        printf(&quot;&#x27;age&#x27; removed successfully.\n&quot;);  // 输出：&#x27;age&#x27; removed successfully.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 验证删除结果</span><br><span class="line">    age = hashmap_get(map, &quot;age&quot;);</span><br><span class="line">    if (age == NULL) &#123;</span><br><span class="line">        printf(&quot;&#x27;age&#x27; not found after removal.\n&quot;);  // 输出：&#x27;age&#x27; not found after removal.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hashmap_destroy(map);  // 销毁哈希表（释放所有内存）</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-预期输出"><a href="#5-2-预期输出" class="headerlink" title="5.2 预期输出"></a>5.2 预期输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name: Alice</span><br><span class="line">Age: 25</span><br><span class="line">&#x27;remove &#x27;age&#x27; successfully.</span><br><span class="line">&#x27;age&#x27; not found after removal.</span><br></pre></td></tr></table></figure><h3 id="5-3-验证结论"><a href="#5-3-验证结论" class="headerlink" title="5.3 验证结论"></a>5.3 验证结论</h3><p>通过测试用例可以看出：</p><ul><li>插入操作成功存储了键值对。</li><li>查询操作能正确返回已存储的值。</li><li>删除操作能正确移除键值对，且后续查询返回<code>NULL</code>。</li><li>销毁操作释放了所有内存，避免泄漏。</li></ul><hr><h2 id="六、个人思考与优化方向"><a href="#六、个人思考与优化方向" class="headerlink" title="六、个人思考与优化方向"></a>六、个人思考与优化方向</h2><h3 id="6-1-实现中的挑战"><a href="#6-1-实现中的挑战" class="headerlink" title="6.1 实现中的挑战"></a>6.1 实现中的挑战</h3><ul><li><strong>内存管理</strong>：在插入操作中，需要为键和值分配内存（<code>strdup1</code>），并在删除或销毁时释放。任何一步的内存泄漏都会导致程序不稳定。</li><li><strong>哈希冲突</strong>：虽然本实现使用链地址法解决了冲突，但当负载因子（元素数量&#x2F;桶数量）过高时，链表长度会增加，导致查询性能下降（退化为O(n)）。</li></ul><h3 id="6-2-优化方向"><a href="#6-2-优化方向" class="headerlink" title="6.2 优化方向"></a>6.2 优化方向</h3><ul><li><strong>动态扩容</strong>：当负载因子超过阈值（如0.7）时，自动扩容哈希桶数组（如翻倍），并重新哈希所有元素，降低冲突率。</li><li><strong>更优的哈希函数</strong>：替换为MurmurHash等更高效的哈希算法，减少冲突概率。</li><li><strong>线程安全</strong>：添加互斥锁（<code>pthread_mutex_t</code>），支持多线程环境下的并发操作。</li></ul><hr><h2 id="七、源码附录"><a href="#七、源码附录" class="headerlink" title="七、源码附录"></a>七、源码附录</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">hash.h</button><button type="button" class="tab">hash.c</button><button type="button" class="tab">main.c</button></div><div class="tab-contents"><div class="tab-item-content active"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#ifndef HASH_MAP_H</span><br><span class="line">#define HASH_MAP_H</span><br><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define HASHMAP_CAPACITY 10  // 哈希表容量固定为10</span><br><span class="line"></span><br><span class="line">typedef char *KeyType;   // 键类型：字符串指针</span><br><span class="line">typedef char *ValueType; // 值类型：字符串指针</span><br><span class="line"></span><br><span class="line">// 哈希桶节点（链表节点）</span><br><span class="line">typedef struct node_s &#123;</span><br><span class="line">    KeyType key;          // 键（字符串）</span><br><span class="line">    ValueType val;        // 值（字符串）</span><br><span class="line">    struct node_s *next;  // 下一个节点指针</span><br><span class="line">&#125; KeyValueNode;</span><br><span class="line"></span><br><span class="line">// 哈希表核心结构体</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    KeyValueNode *buckets[HASHMAP_CAPACITY];  // 哈希桶数组</span><br><span class="line">    uint32_t hash_seed;                       // 哈希种子（随机化）</span><br><span class="line">&#125; HashMap;</span><br><span class="line"></span><br><span class="line">// 创建哈希表</span><br><span class="line">HashMap *hashmap_create();</span><br><span class="line">// 销毁哈希表</span><br><span class="line">void hashmap_destroy(HashMap *map);</span><br><span class="line">// 插入/更新键值对</span><br><span class="line">ValueType hashmap_put(HashMap *map, KeyType key, ValueType val);</span><br><span class="line">// 查询键对应的值</span><br><span class="line">ValueType hashmap_get(HashMap *map, KeyType key);</span><br><span class="line">// 删除键值对</span><br><span class="line">bool hashmap_remove(HashMap *map, KeyType key);</span><br><span class="line"></span><br><span class="line">#endif // HASH_MAP_H</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;hash.h&quot;</span><br><span class="line"></span><br><span class="line">// 深拷贝字符串（避免外部修改影响哈希表）,C中strdup函数已经弃用，所以重命名一个</span><br><span class="line">char *strdup1(const char *s) &#123;</span><br><span class="line">    size_t len = strlen(s) + 1;</span><br><span class="line">    char *p = (char *)malloc(len);</span><br><span class="line">    if (p) memcpy(p, s, len);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建哈希表</span><br><span class="line">HashMap *hashmap_create() &#123;</span><br><span class="line">    HashMap *map = (HashMap *)calloc(1, sizeof(HashMap));</span><br><span class="line">    if (!map) &#123;</span><br><span class="line">        printf(&quot;calloc failed in hashmap_create</span><br><span class="line">&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    map-&gt;hash_seed = (uint32_t)time(NULL);  // 初始化随机种子</span><br><span class="line">    return map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 销毁哈希表（释放所有内存）</span><br><span class="line">void hashmap_destroy(HashMap *map) &#123;</span><br><span class="line">    if (!map) return;</span><br><span class="line">    for (int i = 0; i &lt; HASHMAP_CAPACITY; i++) &#123;</span><br><span class="line">        KeyValueNode *current = map-&gt;buckets[i];</span><br><span class="line">        while (current) &#123;</span><br><span class="line">            KeyValueNode *next = current-&gt;next;</span><br><span class="line">            free(current-&gt;key);   // 释放键</span><br><span class="line">            free(current-&gt;val);   // 释放值</span><br><span class="line">            free(current);        // 释放节点</span><br><span class="line">            current = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(map);  // 释放哈希表本身</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 哈希函数（多项式滚动哈希+随机种子）</span><br><span class="line">static uint32_t hash(const char *key, uint32_t seed) &#123;</span><br><span class="line">    uint32_t hash_val = 0;</span><br><span class="line">    while (*key) &#123;</span><br><span class="line">        hash_val = (hash_val * 31) + (uint32_t)*key++;  // 31是经典质数基数</span><br><span class="line">    &#125;</span><br><span class="line">    return (hash_val ^ seed) % HASHMAP_CAPACITY;  // 结合种子取模</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 插入/更新键值对</span><br><span class="line">ValueType hashmap_put(HashMap *map, KeyType key, ValueType val) &#123;</span><br><span class="line">    if (!map || !key || !val) return NULL;  // 参数校验</span><br><span class="line"></span><br><span class="line">    uint32_t index = hash(key, map-&gt;hash_seed);  // 计算哈希值</span><br><span class="line"></span><br><span class="line">    // 查找键是否已存在（更新值）</span><br><span class="line">    KeyValueNode *current = map-&gt;buckets[index];</span><br><span class="line">    while (current) &#123;</span><br><span class="line">        if (strcmp(current-&gt;key, key) == 0) &#123;</span><br><span class="line">            free(current-&gt;val);         // 释放旧值</span><br><span class="line">            current-&gt;val = strdup1(val); // 更新为新值（深拷贝）</span><br><span class="line">            return current-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 键不存在，创建新节点（头插法）</span><br><span class="line">    KeyValueNode *new_node = (KeyValueNode *)calloc(1, sizeof(KeyValueNode));</span><br><span class="line">    if (!new_node) &#123;</span><br><span class="line">        fprintf(stderr, &quot;Memory allocation failed in hashmap_put</span><br><span class="line">&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    new_node-&gt;key = strdup1(key);   // 深拷贝键</span><br><span class="line">    new_node-&gt;val = strdup1(val);   // 深拷贝值</span><br><span class="line">    new_node-&gt;next = map-&gt;buckets[index];  // 头插法链接链表</span><br><span class="line">    map-&gt;buckets[index] = new_node;</span><br><span class="line"></span><br><span class="line">    return new_node-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查询键对应的值</span><br><span class="line">ValueType hashmap_get(HashMap *map, KeyType key) &#123;</span><br><span class="line">    if (!map || !key) return NULL;  // 参数校验</span><br><span class="line"></span><br><span class="line">    uint32_t index = hash(key, map-&gt;hash_seed);  // 计算哈希值</span><br><span class="line"></span><br><span class="line">    // 遍历链表查找键</span><br><span class="line">    KeyValueNode *current = map-&gt;buckets[index];</span><br><span class="line">    while (current) &#123;</span><br><span class="line">        if (strcmp(current-&gt;key, key) == 0) &#123;</span><br><span class="line">            return current-&gt;val;  // 找到返回值</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;  // 未找到返回NULL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除键值对</span><br><span class="line">bool hashmap_remove(HashMap *map, KeyType key) &#123;</span><br><span class="line">    if (!map || !key) return false;  // 参数校验</span><br><span class="line"></span><br><span class="line">    uint32_t index = hash(key, map-&gt;hash_seed);  // 计算哈希值</span><br><span class="line"></span><br><span class="line">    KeyValueNode *current = map-&gt;buckets[index];</span><br><span class="line">    KeyValueNode *prev = NULL;</span><br><span class="line"></span><br><span class="line">    while (current) &#123;</span><br><span class="line">        if (strcmp(current-&gt;key, key) == 0) &#123;  // 找到目标键</span><br><span class="line">            // 处理链表链接</span><br><span class="line">            if (prev) &#123;</span><br><span class="line">                prev-&gt;next = current-&gt;next;  // 中间/尾部节点</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                map-&gt;buckets[index] = current-&gt;next;  // 头节点</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 释放内存</span><br><span class="line">            free(current-&gt;key);   // 释放键</span><br><span class="line">            free(current-&gt;val);   // 释放值</span><br><span class="line">            free(current);        // 释放节点</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = current;       // 记录前一个节点</span><br><span class="line">        current = current-&gt;next;  // 移动到下一个节点</span><br><span class="line">    &#125;</span><br><span class="line">    return false;  // 未找到键</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;hash.h&quot;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    HashMap *map = hashmap_create();</span><br><span class="line">    if (!map) return 1;</span><br><span class="line"></span><br><span class="line">    // 插入键值对</span><br><span class="line">    hashmap_put(map, &quot;name&quot;, &quot;Alice&quot;);</span><br><span class="line">    hashmap_put(map, &quot;age&quot;, &quot;25&quot;);</span><br><span class="line"></span><br><span class="line">    // 查询并打印</span><br><span class="line">    ValueType name = hashmap_get(map, &quot;name&quot;);</span><br><span class="line">    ValueType age = hashmap_get(map, &quot;age&quot;);</span><br><span class="line">    if (name) printf(&quot;Name: %s\n&quot;, name);</span><br><span class="line">    if (age)  printf(&quot;Age: %s\n&quot;, age);</span><br><span class="line"></span><br><span class="line">    // 删除键并验证</span><br><span class="line">    if (hashmap_remove(map, &quot;age&quot;)) &#123;</span><br><span class="line">        printf(&quot;&#x27;age&#x27; removed successfully.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    age = hashmap_get(map, &quot;age&quot;);</span><br><span class="line">    if (!age) &#123;</span><br><span class="line">        printf(&quot;&#x27;age&#x27; not found after removal.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hashmap_destroy(map);  // 释放所有内存</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> Data-Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 函数 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从基础到进阶：常见排序算法的C语言实现与深度解析</title>
      <link href="/posts/a444b428/"/>
      <url>/posts/a444b428/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/14.png" alt="从基础到进阶：常见排序算法的C语言实现与深度解析" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>排序算法是计算机科学中最基础且重要的算法之一，广泛应用于数据库查询、日志处理、数据统计等场景。理解不同排序算法的核心思想、时间复杂度及适用场景，不仅能帮助我们写出更高效的代码，还能在实际工程中根据需求选择最优方案。</p><p>本文将以C语言实现为切入点，深入解析<strong>插入排序、希尔排序、归并排序、快速排序（双向优化）、堆排序</strong>五大经典算法，结合代码逐行分析其底层逻辑，并通过测试用例验证正确性。文末附完整可运行源码。</p><hr><h2 id="一、插入排序：从“摸牌”到有序"><a href="#一、插入排序：从“摸牌”到有序" class="headerlink" title="一、插入排序：从“摸牌”到有序"></a>一、插入排序：从“摸牌”到有序</h2><h3 id="1-1-算法思想"><a href="#1-1-算法思想" class="headerlink" title="1.1 算法思想"></a>1.1 算法思想</h3><p>插入排序的核心思想是<strong>将未排序元素逐个插入到已排序序列的正确位置</strong>，类似于整理扑克牌的过程：初始时左手为空（已排序序列），每次从桌面（未排序序列）取一张牌，插入左手已有牌中的正确位置。</p><h3 id="1-2-代码实现与解析"><a href="#1-2-代码实现与解析" class="headerlink" title="1.2 代码实现与解析"></a>1.2 代码实现与解析</h3><p>插入排序代码如下（已修正注释格式）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void insertion_sort(int arr[], int len) &#123;</span><br><span class="line">    for (int i = 1; i &lt; len; i++) &#123;         // 从第2个元素开始（索引1）</span><br><span class="line">        if (arr[i] &lt; arr[i - 1]) &#123;          // 若当前元素小于前一个（需插入）</span><br><span class="line">            for (int j = i - 1; j &gt;= 0; j--) &#123; // 从i-1向前遍历已排序序列</span><br><span class="line">                if (arr[i] &lt; arr[j]) &#123;        // 找到插入位置（arr[j] &gt; arr[i]）</span><br><span class="line">                    SWAP(arr, i, j);          // 交换i和j位置的元素</span><br><span class="line">                    i = j;                    // 继续向前检查（i更新为j）</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;                    // 找到正确位置，退出循环</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        print_arr(arr, len);                  // 打印每轮排序结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键细节</strong>：</p><ul><li><strong>外层循环</strong>：<code>i</code>从1开始，代表当前待插入的元素位置（已排序序列长度为<code>i</code>）。</li><li><strong>内层循环</strong>：<code>j</code>从<code>i-1</code>向前遍历，比较<code>arr[i]</code>与<code>arr[j]</code>，若<code>arr[i]</code>更小则交换，直到找到合适位置。</li><li><strong>优化点</strong>：通过“向后移动”而非“逐个交换”减少赋值次数（示例代码中实际用了交换，可进一步优化为移动后插入）。</li></ul><h3 id="1-3-复杂度分析"><a href="#1-3-复杂度分析" class="headerlink" title="1.3 复杂度分析"></a>1.3 复杂度分析</h3><ul><li><strong>时间复杂度</strong>：最好情况（已排序）O(n)，最坏情况（逆序）O(n²)。</li><li><strong>空间复杂度</strong>：O(1)（原地排序）。</li><li><strong>稳定性</strong>：稳定（相等元素的相对顺序不变）。</li></ul><hr><h2 id="二、希尔排序：插入排序的“分组优化”"><a href="#二、希尔排序：插入排序的“分组优化”" class="headerlink" title="二、希尔排序：插入排序的“分组优化”"></a>二、希尔排序：插入排序的“分组优化”</h2><h3 id="2-1-算法思想"><a href="#2-1-算法思想" class="headerlink" title="2.1 算法思想"></a>2.1 算法思想</h3><p>希尔排序是插入排序的改进版，通过<strong>将数组分成多个子序列（间隔为<code>gap</code>）</strong>，对每个子序列进行插入排序，逐步缩小<code>gap</code>直至为1（此时退化为普通插入排序）。由于初始<code>gap</code>较大，可大幅减少逆序对，提升效率。</p><h3 id="2-2-代码实现与解析"><a href="#2-2-代码实现与解析" class="headerlink" title="2.2 代码实现与解析"></a>2.2 代码实现与解析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void shell_sort(int arr[], int n) &#123;</span><br><span class="line">    int gap = n &gt;&gt; 1;  // 初始间隔为数组长度的一半（n/2）</span><br><span class="line">    while (gap &gt; 0) &#123;  // 间隔递减至0时结束</span><br><span class="line">        for (int i = gap; i &lt; n; i += gap) &#123;  // 遍历每个子序列的起始位置</span><br><span class="line">            if (arr[i] &lt; arr[i - gap]) &#123;       // 若当前元素小于同子序列前一个元素</span><br><span class="line">                for (int j = i - gap; j &gt;= 0; j -= gap) &#123;  // 向前遍历子序列</span><br><span class="line">                    if (arr[i] &lt; arr[j]) &#123;     // 找到插入位置</span><br><span class="line">                        SWAP(arr, i, j);       // 交换元素</span><br><span class="line">                        i = j;                 // 继续向前检查</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        break;                 // 找到正确位置，退出循环</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        print_arr(arr, n);  // 打印每轮排序结果</span><br><span class="line">        gap = gap &gt;&gt; 1;     // 间隔减半（n/4, n/8...）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键细节</strong>：</p><ul><li><strong>间隔序列</strong>：示例中使用<code>gap = n/2 → n/4 → ... → 1</code>，这是最经典的间隔序列，但存在优化空间（如Hibbard序列）。</li><li><strong>子序列划分</strong>：每个子序列由间隔<code>gap</code>的元素组成（如<code>gap=2</code>时，子序列为<code>arr[0], arr[2], arr[4]...</code>和<code>arr[1], arr[3], arr[5]...</code>）。</li></ul><h3 id="2-3-复杂度分析"><a href="#2-3-复杂度分析" class="headerlink" title="2.3 复杂度分析"></a>2.3 复杂度分析</h3><ul><li><strong>时间复杂度</strong>：取决于间隔序列，经典序列下平均O(n¹·³)，最坏O(n²)。</li><li><strong>空间复杂度</strong>：O(1)（原地排序）。</li><li><strong>稳定性</strong>：不稳定（不同子序列的元素可能交换顺序）。</li></ul><hr><h2 id="三、归并排序：分治思想的典范"><a href="#三、归并排序：分治思想的典范" class="headerlink" title="三、归并排序：分治思想的典范"></a>三、归并排序：分治思想的典范</h2><h3 id="3-1-算法思想"><a href="#3-1-算法思想" class="headerlink" title="3.1 算法思想"></a>3.1 算法思想</h3><p>归并排序基于**分治（Divide and Conquer）**策略，核心步骤为：</p><ol><li><strong>分割（Divide）</strong>：将数组递归划分为两半，直到子数组长度为1（天然有序）。</li><li><strong>合并（Merge）</strong>：合并两个有序子数组为一个有序数组，通过临时数组暂存结果，避免覆盖原数据。</li></ol><h3 id="3-2-代码实现与解析"><a href="#3-2-代码实现与解析" class="headerlink" title="3.2 代码实现与解析"></a>3.2 代码实现与解析</h3><p>用户提供的归并排序代码（含临时数组优化）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 合并两个有序子数组 [left, mid] 和 [mid+1, right]</span><br><span class="line">void merge(int arr[], int left, int mid, int right, int *tmp) &#123;</span><br><span class="line">    int i = left, j = mid + 1, k = left;  // 左子数组、右子数组、临时数组指针</span><br><span class="line">    // 合并左右子数组到临时数组（直到其中一个遍历完毕）</span><br><span class="line">    while (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        if (arr[i] &lt;= arr[j]) tmp[k++] = arr[i++];  // 左更小，优先放入</span><br><span class="line">        else tmp[k++] = arr[j++];                   // 右更小，优先放入</span><br><span class="line">    &#125;</span><br><span class="line">    // 处理左子数组剩余元素</span><br><span class="line">    while (i &lt;= mid) tmp[k++] = arr[i++];</span><br><span class="line">    // 处理右子数组剩余元素</span><br><span class="line">    while (j &lt;= right) tmp[k++] = arr[j++];</span><br><span class="line">    // 临时数组内容复制回原数组</span><br><span class="line">    for (i = left; i &lt;= right; i++) arr[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 分治递归函数</span><br><span class="line">void divide_merge(int arr[], int left, int right, int *tmp) &#123;</span><br><span class="line">    if (left &gt;= right) return;  // 递归终止（子数组长度≤1）</span><br><span class="line">    int mid = left + (right - left) / 2;  // 计算中点（防溢出）</span><br><span class="line">    divide_merge(arr, left, mid, tmp);      // 排序左半部分</span><br><span class="line">    divide_merge(arr, mid + 1, right, tmp); // 排序右半部分</span><br><span class="line">    merge(arr, left, mid, right, tmp);      // 合并左右有序子数组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 归并排序入口函数</span><br><span class="line">void merge_sort(int arr[], int len) &#123;</span><br><span class="line">    int *tmp = (int *)calloc(len, sizeof(int));  // 分配临时数组</span><br><span class="line">    if (!tmp) &#123; printf(&quot;Memory allocation failed!</span><br><span class="line">&quot;); return; &#125;</span><br><span class="line">    divide_merge(arr, 0, len - 1, tmp);  // 分治排序</span><br><span class="line">    free(tmp);                           // 释放临时数组</span><br><span class="line">    print_arr(arr, len);                 // 输出最终结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键细节</strong>：</p><ul><li><strong>临时数组</strong>：用于暂存合并结果，避免直接覆盖原数组导致数据丢失。</li><li><strong>中点计算</strong>：<code>mid = left + (right - left)/2</code> 避免<code>left + right</code>可能溢出。</li><li><strong>稳定性</strong>：合并时若左右元素相等（<code>arr[i] &lt;= arr[j]</code>），优先选择左子数组元素，保证稳定性。</li></ul><h3 id="3-3-复杂度分析"><a href="#3-3-复杂度分析" class="headerlink" title="3.3 复杂度分析"></a>3.3 复杂度分析</h3><ul><li><strong>时间复杂度</strong>：始终O(n log n)（分割O(log n)层，每层合并O(n)）。</li><li><strong>空间复杂度</strong>：O(n)（需要额外临时数组）。</li><li><strong>稳定性</strong>：稳定（相等元素顺序不变）。</li></ul><hr><h2 id="四、快速排序：分治的“高效王者”"><a href="#四、快速排序：分治的“高效王者”" class="headerlink" title="四、快速排序：分治的“高效王者”"></a>四、快速排序：分治的“高效王者”</h2><h3 id="4-1-算法思想"><a href="#4-1-算法思想" class="headerlink" title="4.1 算法思想"></a>4.1 算法思想</h3><p>快速排序同样基于分治策略，核心步骤为：</p><ol><li><strong>选择基准（Pivot）</strong>：从数组中选取一个元素作为基准值。</li><li><strong>分区（Partition）</strong>：将数组分为两部分，左边元素≤基准，右边元素≥基准。</li><li><strong>递归排序</strong>：对左右子数组递归执行上述步骤。</li></ol><h3 id="4-2-代码实现与解析（单向分区-vs-双向分区）"><a href="#4-2-代码实现与解析（单向分区-vs-双向分区）" class="headerlink" title="4.2 代码实现与解析（单向分区 vs 双向分区）"></a>4.2 代码实现与解析（单向分区 vs 双向分区）</h3><h4 id="4-2-1-单向分区（Lomuto分区）"><a href="#4-2-1-单向分区（Lomuto分区）" class="headerlink" title="4.2.1 单向分区（Lomuto分区）"></a>4.2.1 单向分区（Lomuto分区）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void quick_sort_one_way(int arr[], int low, int high) &#123;</span><br><span class="line">    if (low &gt;= high) return;  // 递归终止</span><br><span class="line">    int pivot = arr[high];    // 选择最后一个元素作为基准</span><br><span class="line">    int i = low - 1;          // 记录小于基准的右边界</span><br><span class="line">    // 遍历数组，将小于基准的元素移到左边</span><br><span class="line">    for (int j = low; j &lt; high; j++) &#123;</span><br><span class="line">        if (arr[j] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            SWAP(arr, i, j);  // 交换i和j位置元素</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将基准放到正确位置（i+1）</span><br><span class="line">    SWAP(arr, i + 1, high);</span><br><span class="line">    // 递归排序左右子数组</span><br><span class="line">    quick_sort_one_way(arr, low, i);      // 左半部分（≤基准）</span><br><span class="line">    quick_sort_one_way(arr, i + 2, high); // 右半部分（≥基准）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键细节</strong>：</p><ul><li><strong>基准选择</strong>：示例选择最后一个元素，可能导致最坏情况（如已排序数组）时间复杂度退化为O(n²)。</li><li><strong>分区逻辑</strong>：通过<code>i</code>记录小于基准的右边界，遍历结束后将基准交换到<code>i+1</code>位置，此时左边全≤基准，右边全≥基准。</li></ul><h4 id="4-2-2-双向分区（Hoare分区，优化版）"><a href="#4-2-2-双向分区（Hoare分区，优化版）" class="headerlink" title="4.2.2 双向分区（Hoare分区，优化版）"></a>4.2.2 双向分区（Hoare分区，优化版）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void quick_sort_two_way(int arr[], int low, int high) &#123;</span><br><span class="line">    if (low &gt;= high) return;</span><br><span class="line">    int pivot = arr[(low + high) / 2];  // 选择中间元素作为基准（防极端情况）</span><br><span class="line">    int left = low - 1, right = high + 1; // 左右指针（初始在边界外）</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        // 左指针右移，找≥基准的元素</span><br><span class="line">        do &#123; left++; &#125; while (arr[left] &lt; pivot);</span><br><span class="line">        // 右指针左移，找≤基准的元素</span><br><span class="line">        do &#123; right--; &#125; while (arr[right] &gt; pivot);</span><br><span class="line">        // 指针相遇或交叉，结束分区</span><br><span class="line">        if (left &gt;= right) break;</span><br><span class="line">        SWAP(arr, left, right);  // 交换左右元素</span><br><span class="line">    &#125;</span><br><span class="line">    // 递归排序左右子数组（right为分区点）</span><br><span class="line">    quick_sort_two_way(arr, low, right);</span><br><span class="line">    quick_sort_two_way(arr, right + 1, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化点</strong>：</p><ul><li><strong>基准选择</strong>：中间元素避免已排序数组的最坏情况。</li><li><strong>双向扫描</strong>：左右指针同时移动，减少不必要的比较，提升效率。</li></ul><h3 id="4-3-复杂度分析"><a href="#4-3-复杂度分析" class="headerlink" title="4.3 复杂度分析"></a>4.3 复杂度分析</h3><ul><li><strong>时间复杂度</strong>：平均O(n log n)，最坏O(n²)（可通过随机选择基准避免）。</li><li><strong>空间复杂度</strong>：O(log n)（递归栈空间）。</li><li><strong>稳定性</strong>：不稳定（分区时可能交换相等元素顺序）。</li></ul><hr><h2 id="五、堆排序：利用堆结构的原地排序"><a href="#五、堆排序：利用堆结构的原地排序" class="headerlink" title="五、堆排序：利用堆结构的原地排序"></a>五、堆排序：利用堆结构的原地排序</h2><h3 id="5-1-算法思想"><a href="#5-1-算法思想" class="headerlink" title="5.1 算法思想"></a>5.1 算法思想</h3><p>堆排序基于**堆（Heap）**数据结构（本文为大根堆），核心步骤为：</p><ol><li><strong>构建堆</strong>：将数组转换为大根堆（父节点≥子节点）。</li><li><strong>交换堆顶</strong>：将堆顶元素（最大值）与堆尾元素交换，堆大小减1。</li><li><strong>调整堆</strong>：对新的堆顶元素进行“堆化（Heapify）”，恢复大根堆性质。</li><li><strong>重复步骤2-3</strong>：直到堆大小为1，此时数组完全有序。</li></ol><h3 id="5-2-代码实现与解析"><a href="#5-2-代码实现与解析" class="headerlink" title="5.2 代码实现与解析"></a>5.2 代码实现与解析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 堆化函数（大根堆）</span><br><span class="line">void heapify(int arr[], int root, int tree_size) &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        int left = 2 * root + 1;   // 左子节点索引</span><br><span class="line">        int right = 2 * root + 2;  // 右子节点索引</span><br><span class="line">        int largest = root;        // 记录最大节点索引（初始为根）</span><br><span class="line"></span><br><span class="line">        // 比较左子节点（若存在且更大）</span><br><span class="line">        if (left &lt; tree_size &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line">        // 比较右子节点（若存在且更大）</span><br><span class="line">        if (right &lt; tree_size &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line">        // 若最大节点不是根，交换并继续堆化</span><br><span class="line">        if (largest != root) &#123;</span><br><span class="line">            SWAP(arr, root, largest);</span><br><span class="line">            root = largest;  // 继续检查子树</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            break;  // 已满足大根堆性质，退出循环</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void heap_sort(int arr[], int len) &#123;</span><br><span class="line">    // 步骤1：构建大根堆（从最后一个非叶子节点开始）</span><br><span class="line">    for (int i = len / 2 - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        heapify(arr, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">    // 步骤2：交换堆顶与堆尾，调整堆</span><br><span class="line">    for (int i = len - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        SWAP(arr, 0, i);        // 交换堆顶（最大值）与堆尾</span><br><span class="line">        heapify(arr, 0, i);     // 调整堆（大小减1）</span><br><span class="line">    &#125;</span><br><span class="line">    print_arr(arr, len);  // 输出排序结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键细节</strong>：</p><ul><li><strong>堆的构建</strong>：从最后一个非叶子节点（索引<code>len/2 - 1</code>）开始向前遍历，确保每个子树都是大根堆。</li><li><strong>堆化过程</strong>：通过循环比较根与子节点，将最大值“下沉”到正确位置，保证堆性质。</li></ul><h3 id="5-3-复杂度分析"><a href="#5-3-复杂度分析" class="headerlink" title="5.3 复杂度分析"></a>5.3 复杂度分析</h3><ul><li><strong>时间复杂度</strong>：始终O(n log n)（构建堆O(n)，调整堆O(n log n)）。</li><li><strong>空间复杂度</strong>：O(1)（原地排序）。</li><li><strong>稳定性</strong>：不稳定（堆调整可能破坏相等元素顺序）。</li></ul><hr><h2 id="六、测试验证与结果对比"><a href="#六、测试验证与结果对比" class="headerlink" title="六、测试验证与结果对比"></a>六、测试验证与结果对比</h2><h3 id="6-1-测试用例"><a href="#6-1-测试用例" class="headerlink" title="6.1 测试用例"></a>6.1 测试用例</h3><p>使用主函数测试各排序算法（修正后主函数）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main(void) &#123;</span><br><span class="line">    int arr_insert[] = &#123;1, 21, 45, 231, 99, 2, 18, 7, 4, 9&#125;;</span><br><span class="line">    int len = sizeof(arr_insert) / sizeof(arr_insert[0]);</span><br><span class="line">    printf(&quot;插入排序前: &quot;);</span><br><span class="line">    print_arr(arr_insert, len);</span><br><span class="line">    insertion_sort(arr_insert, len);</span><br><span class="line">    printf(&quot;插入排序后: &quot;);</span><br><span class="line">    print_arr(arr_insert, len);</span><br><span class="line"></span><br><span class="line">    // 类似地添加希尔、归并、快速、堆排序的测试代码...</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-预期输出"><a href="#6-2-预期输出" class="headerlink" title="6.2 预期输出"></a>6.2 预期输出</h3><p>插入排序每轮输出逐步接近有序，最终结果为<code>[1, 2, 4, 7, 9, 18, 21, 45, 99, 231]</code>。其他排序算法最终均应输出有序数组。</p><hr><h2 id="七、总结与选择建议"><a href="#七、总结与选择建议" class="headerlink" title="七、总结与选择建议"></a>七、总结与选择建议</h2><table><thead><tr><th>算法</th><th>时间复杂度（平均）</th><th>时间复杂度（最坏）</th><th>空间复杂度</th><th>稳定性</th><th>适用场景</th></tr></thead><tbody><tr><td>插入排序</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td><td>小规模&#x2F;基本有序数据</td></tr><tr><td>希尔排序</td><td>O(n¹·³)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td><td>中等规模数据（优于插入排序）</td></tr><tr><td>归并排序</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n)</td><td>稳定</td><td>大规模数据&#x2F;需稳定性</td></tr><tr><td>快速排序</td><td>O(n log n)</td><td>O(n²)</td><td>O(log n)</td><td>不稳定</td><td>大规模数据（内存敏感）</td></tr><tr><td>堆排序</td><td>O(n log n)</td><td>O(n log n)</td><td>O(1)</td><td>不稳定</td><td>大规模数据（内存严格受限）</td></tr></tbody></table><p><strong>个人建议</strong>：</p><ul><li>日常开发中，优先使用语言标准库的排序函数（如C的<code>qsort</code>），其内部已优化。</li><li>学习排序算法的核心是理解其思想（如分治、堆性质），而非死记硬背代码。</li><li>面试中常考快速排序的分区逻辑、归并排序的空间优化，需重点掌握。</li></ul><hr><h2 id="源码附录（完整可运行）"><a href="#源码附录（完整可运行）" class="headerlink" title="源码附录（完整可运行）"></a>源码附录（完整可运行）</h2><h3 id="sort-h"><a href="#sort-h" class="headerlink" title="sort.h"></a>sort.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SORT_H</span><br><span class="line">#define SORT_H</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">#define ARR_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))</span><br><span class="line">#define SWAP(a, b) do &#123; typeof(a) _temp = (a); (a) = (b); (b) = _temp; &#125; while(0)</span><br><span class="line"></span><br><span class="line">void print_arr(int arr[], int len);</span><br><span class="line">void insertion_sort(int arr[], int len);</span><br><span class="line">void shell_sort(int arr[], int n);</span><br><span class="line">void merge_sort(int arr[], int len);</span><br><span class="line">void quick_sort_one_way(int arr[], int low, int high);</span><br><span class="line">void quick_sort_two_way(int arr[], int low, int high);</span><br><span class="line">void heap_sort(int arr[], int len);</span><br><span class="line"></span><br><span class="line">#endif // SORT_H</span><br></pre></td></tr></table></figure><h3 id="sort-c"><a href="#sort-c" class="headerlink" title="sort.c"></a>sort.c</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;sort.h&quot;</span><br><span class="line"></span><br><span class="line">// 打印数组</span><br><span class="line">void print_arr(int arr[], int len) &#123;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 插入排序</span><br><span class="line">void insertion_sort(int arr[], int len) &#123;</span><br><span class="line">    for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">        if (arr[i] &lt; arr[i - 1]) &#123;</span><br><span class="line">            for (int j = i - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">                if (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">                    SWAP(arr[i], arr[j]);</span><br><span class="line">                    i = j;  // 继续向前检查</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;  // 找到正确位置</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        print_arr(arr, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 希尔排序</span><br><span class="line">void shell_sort(int arr[], int n) &#123;</span><br><span class="line">    int gap = n &gt;&gt; 1;</span><br><span class="line">    while (gap &gt; 0) &#123;</span><br><span class="line">        for (int i = gap; i &lt; n; i += gap) &#123;</span><br><span class="line">            if (arr[i] &lt; arr[i - gap]) &#123;</span><br><span class="line">                for (int j = i - gap; j &gt;= 0; j -= gap) &#123;</span><br><span class="line">                    if (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">                        SWAP(arr[i], arr[j]);</span><br><span class="line">                        i = j;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        print_arr(arr, n);</span><br><span class="line">        gap &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 合并两个有序子数组</span><br><span class="line">void merge(int arr[], int left, int mid, int right, int *tmp) &#123;</span><br><span class="line">    int i = left, j = mid + 1, k = left;</span><br><span class="line">    while (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        if (arr[i] &lt;= arr[j]) tmp[k++] = arr[i++];</span><br><span class="line">        else tmp[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (i &lt;= mid) tmp[k++] = arr[i++];</span><br><span class="line">    while (j &lt;= right) tmp[k++] = arr[j++];</span><br><span class="line">    for (i = left; i &lt;= right; i++) arr[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 分治递归函数</span><br><span class="line">void divide_merge(int arr[], int left, int right, int *tmp) &#123;</span><br><span class="line">    if (left &gt;= right) return;</span><br><span class="line">    int mid = left + (right - left) / 2;</span><br><span class="line">    divide_merge(arr, left, mid, tmp);</span><br><span class="line">    divide_merge(arr, mid + 1, right, tmp);</span><br><span class="line">    merge(arr, left, mid, right, tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 归并排序入口</span><br><span class="line">void merge_sort(int arr[], int len) &#123;</span><br><span class="line">    int *tmp = (int *)calloc(len, sizeof(int));</span><br><span class="line">    if (!tmp) &#123;</span><br><span class="line">        printf(&quot;Memory allocation failed!</span><br><span class="line">&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    divide_merge(arr, 0, len - 1, tmp);</span><br><span class="line">    free(tmp);</span><br><span class="line">    print_arr(arr, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 单向分区快速排序</span><br><span class="line">void quick_sort_one_way(int arr[], int low, int high) &#123;</span><br><span class="line">    if (low &gt;= high) return;</span><br><span class="line">    int pivot = arr[high];</span><br><span class="line">    int i = low - 1;</span><br><span class="line">    for (int j = low; j &lt; high; j++) &#123;</span><br><span class="line">        if (arr[j] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            SWAP(arr[i], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SWAP(arr[i + 1], arr[high]);</span><br><span class="line">    quick_sort_one_way(arr, low, i);</span><br><span class="line">    quick_sort_one_way(arr, i + 2, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 双向分区快速排序</span><br><span class="line">void quick_sort_two_way(int arr[], int low, int high) &#123;</span><br><span class="line">    if (low &gt;= high) return;</span><br><span class="line">    int pivot = arr[(low + high) / 2];</span><br><span class="line">    int left = low - 1, right = high + 1;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        do &#123; left++; &#125; while (arr[left] &lt; pivot);</span><br><span class="line">        do &#123; right--; &#125; while (arr[right] &gt; pivot);</span><br><span class="line">        if (left &gt;= right) break;</span><br><span class="line">        SWAP(arr[left], arr[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort_two_way(arr, low, right);</span><br><span class="line">    quick_sort_two_way(arr, right + 1, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 大根堆调整</span><br><span class="line">void heapify(int arr[], int root, int tree_size) &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        int left = 2 * root + 1, right = 2 * root + 2;</span><br><span class="line">        int largest = root;</span><br><span class="line">        if (left &lt; tree_size &amp;&amp; arr[left] &gt; arr[largest]) largest = left;</span><br><span class="line">        if (right &lt; tree_size &amp;&amp; arr[right] &gt; arr[largest]) largest = right;</span><br><span class="line">        if (largest != root) &#123;</span><br><span class="line">            SWAP(arr[root], arr[largest]);</span><br><span class="line">            root = largest;</span><br><span class="line">        &#125; else break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 堆排序入口</span><br><span class="line">void heap_sort(int arr[], int len) &#123;</span><br><span class="line">    for (int i = len / 2 - 1; i &gt;= 0; i--) heapify(arr, i, len);</span><br><span class="line">    for (int i = len - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        SWAP(arr[0], arr[i]);</span><br><span class="line">        heapify(arr, 0, i);</span><br><span class="line">    &#125;</span><br><span class="line">    print_arr(arr, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    int arr_insert[] = &#123;1, 21, 45, 231, 99, 2, 18, 7, 4, 9&#125;;</span><br><span class="line">    int len = ARR_SIZE(arr_insert);</span><br><span class="line">    printf(&quot;=== 插入排序 ===</span><br><span class="line">原数组: &quot;);</span><br><span class="line">    print_arr(arr_insert, len);</span><br><span class="line">    insertion_sort(arr_insert, len);</span><br><span class="line">    printf(&quot;最终结果: &quot;);</span><br><span class="line">    print_arr(arr_insert, len);</span><br><span class="line"></span><br><span class="line">    // 可添加其他排序的测试代码...</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>注</strong>：实际使用时，需将<code>sort.h</code>和<code>sort.c</code>编译链接后运行。</p>]]></content>
      
      
      <categories>
          
          <category> Data-Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 希尔排序 </tag>
            
            <tag> 插入排序 </tag>
            
            <tag> 归并排序 </tag>
            
            <tag> 快速排序 </tag>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leecode 0001.two sum</title>
      <link href="/posts/83dcefb7/"/>
      <url>/posts/83dcefb7/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/12.png" alt="Leecode 0001.two sum" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a><a href="https://leetcode.com/problems/two-sum/">1. Two Sum</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p><p>Example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>在数组中找到两个数，它们的和等于给定的目标值 <code>target</code>，并返回这两个数在数组中的下标。要求每个元素只能使用一次，且保证有且仅有一个解。</p><hr><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="方法一：双层循环（暴力枚举）"><a href="#方法一：双层循环（暴力枚举）" class="headerlink" title="方法一：双层循环（暴力枚举）"></a>方法一：双层循环（暴力枚举）</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>通过双重循环遍历数组中的每一对元素，检查它们的和是否等于目标值 <code>target</code>。外层循环控制第一个元素的索引 <code>i</code>，内层循环控制第二个元素的索引 <code>j</code>（<code>j &gt; i</code> 以避免重复使用同一元素）。</p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度</strong>：O(n²)，其中 <code>n</code> 是数组的长度。最坏情况下需要遍历所有可能的元素对。</li><li><strong>空间复杂度</strong>：O(1)，仅使用常数额外空间。</li></ul><hr><h3 id="方法二：哈希表（优化查找）"><a href="#方法二：哈希表（优化查找）" class="headerlink" title="方法二：哈希表（优化查找）"></a>方法二：哈希表（优化查找）</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>利用哈希表（字典）存储已遍历元素的值及其下标。对于当前遍历的元素 <code>nums[i]</code>，计算需要的补数 <code>complement = target - nums[i]</code>，并检查补数是否已存在于哈希表中：</p><ul><li>若存在，则返回哈希表中补数的下标和当前元素的下标 <code>i</code>。</li><li>若不存在，则将当前元素的值和下标存入哈希表，继续遍历。</li></ul><p>这种方法通过空间换时间，将查找补数的时间复杂度从 O(n) 降为 O(1)。</p><h1 id="1-Two-Sum-1"><a href="#1-Two-Sum-1" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>  给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>  你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能重复使用。</p><p>  你可以按任意顺序返回答案。</p><p><strong>示例：</strong></p><p>  plaintext</p><p>  复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2, 7, 11, 15], target = 9</span><br><span class="line">输出：[0, 1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><hr><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>  在数组中找到两个数，它们的和等于给定的目标值 <code>target</code>，并返回这两个数在数组中的下标。要求每个元素只能使用一次，且保证有且仅有一个解。</p><hr><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="方法一：双层循环（暴力枚举）-1"><a href="#方法一：双层循环（暴力枚举）-1" class="headerlink" title="方法一：双层循环（暴力枚举）"></a>方法一：双层循环（暴力枚举）</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>  通过双重循环遍历数组中的每一对元素，检查它们的和是否等于目标值 <code>target</code>。外层循环控制第一个元素的索引 <code>i</code>，内层循环控制第二个元素的索引 <code>j</code>（<code>j &gt; i</code> 以避免重复使用同一元素）。</p><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度</strong>：O(n²)，其中 <code>n</code> 是数组的长度。最坏情况下需要遍历所有可能的元素对。</li><li><strong>空间复杂度</strong>：O(1)，仅使用常数额外空间。</li></ul><hr><h3 id="方法二：哈希表（优化查找）-1"><a href="#方法二：哈希表（优化查找）-1" class="headerlink" title="方法二：哈希表（优化查找）"></a>方法二：哈希表（优化查找）</h3><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>  利用哈希表（字典）存储已遍历元素的值及其下标。对于当前遍历的元素 <code>nums[i]</code>，计算需要的补数 <code>complement = target - nums[i]</code>，并检查补数是否已存在于哈希表中：</p><ul><li>若存在，则返回哈希表中补数的下标和当前元素的下标 <code>i</code>。</li><li>若不存在，则将当前元素的值和下标存入哈希表，继续遍历。</li></ul><p>  这种方法通过空间换时间，将查找补数的时间复杂度从 O(n) 降为 O(1)。</p><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度</strong>：O(n)，仅需遍历数组一次。</li><li><strong>空间复杂度</strong>：O(n)，最坏情况下需要存储所有元素到哈希表中。</li></ul><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">双层循环</button><button type="button" class="tab">Hash表</button><button type="button" class="tab">标准答案</button><button type="button" class="tab">C使用哈希函数</button></div><div class="tab-contents"><div class="tab-item-content active"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">// 使用结果数组替代全局变量，提高可维护性</span><br><span class="line">void find_two(int arr[], int target, int len, int *result) &#123;</span><br><span class="line">    result[0] = -1; // 初始化为-1表示未找到</span><br><span class="line">    result[1] = -1;</span><br><span class="line">    int found = 0; // 标记是否找到目标数对</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; len &amp;&amp; !found; i++) &#123;</span><br><span class="line">        // 优化：若当前元素已大于target，无需继续（因数组元素非负）</span><br><span class="line">        if (arr[i] &gt; target) continue;</span><br><span class="line">    </span><br><span class="line">        for (int j = i + 1; j &lt; len &amp;&amp; !found; j++) &#123;</span><br><span class="line">            // 优化：若当前元素已大于target，无需继续</span><br><span class="line">            if (arr[j] &gt; target) continue;</span><br><span class="line">    </span><br><span class="line">            // 找到和为target的两个数</span><br><span class="line">            if (arr[i] + arr[j] == target) &#123;</span><br><span class="line">                result[0] = i;</span><br><span class="line">                result[1] = j;</span><br><span class="line">                found = 1; // 标记已找到，触发循环终止</span><br><span class="line">                break;   // 退出内层循环</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    int num[100] = &#123; 0 &#125;;</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    int len = rand() % 100 + 1; // 数组长度至少为1（避免无效遍历）</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        num[i] = rand() % 100; // 元素范围0-99（非负）</span><br><span class="line">    &#125;</span><br><span class="line">    int target = rand() % 100; // 目标值范围0-99</span><br><span class="line">    int result[2];             // 存储结果下标</span><br><span class="line"></span><br><span class="line">    find_two(num, target, len, result);</span><br><span class="line">    </span><br><span class="line">    // 输出数组元素（仅输出有效部分）</span><br><span class="line">    printf(&quot;数组元素（前%d个）：\n&quot;, len);</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        if(i%15==0)</span><br><span class="line">            printf(&quot;\n&quot;);</span><br><span class="line">        printf(&quot;%d\t&quot;, num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n目标和为%d\n&quot;, target);</span><br><span class="line">    </span><br><span class="line">    if (result[0] == -1 || result[1] == -1) &#123;</span><br><span class="line">        printf(&quot;没找到两个数的和等于%d\n&quot;, target);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;找到两个数，下标分别为%d和%d，对应的值为%d和%d，和为%d\n&quot;,</span><br><span class="line">            result[0], result[1], num[result[0]], num[result[1]], target);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">void find_two(int arr[], int target, int len, int *result) &#123;</span><br><span class="line">    if (len &lt; 2) &#123; // 数组长度不足2，直接返回-1,-1</span><br><span class="line">        result[0] = -1;</span><br><span class="line">        result[1] = -1;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int hash_map[100]; // 哈希表记录值对应的下标，初始化为-1（未出现）</span><br><span class="line">    for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">        hash_map[i] = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        int complement = target - arr[i];</span><br><span class="line">        // 检查补数是否在有效范围（0-99）且已出现过</span><br><span class="line">        if (complement &gt;= 0 &amp;&amp; complement &lt; 100 &amp;&amp; hash_map[complement] != -1) &#123;</span><br><span class="line">            result[0] = hash_map[complement]; // 补数的下标</span><br><span class="line">            result[1] = i;                    // 当前元素的下标</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 记录当前元素的下标（覆盖之前的，确保找到最近的或任意一个解）</span><br><span class="line">        if (arr[i] &gt;= 0 &amp;&amp; arr[i] &lt; 100) &#123; // 确保元素在哈希表范围内</span><br><span class="line">            hash_map[arr[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 未找到符合条件的数对</span><br><span class="line">    result[0] = -1;</span><br><span class="line">    result[1] = -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    int num[100] = &#123; 0 &#125;;</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    int len = rand() % 100 + 1; // 数组长度至少为1（避免len=0时死循环）</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        num[i] = rand() % 100; // 元素范围0-99</span><br><span class="line">    &#125;</span><br><span class="line">    int target = rand() % 100; // 目标值范围0-99</span><br><span class="line">    int result[2] = &#123; -1, -1 &#125;;</span><br><span class="line"></span><br><span class="line">    find_two(num, target, len, result);</span><br><span class="line">    </span><br><span class="line">    // 输出数组元素（仅输出有效部分）</span><br><span class="line">    printf(&quot;数组元素（前%d个）：\n&quot;, len);</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        printf(&quot;%d\t&quot;, num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n目标和为%d\n&quot;, target);</span><br><span class="line">    </span><br><span class="line">    if (result[0] == -1 || result[1] == -1) &#123;</span><br><span class="line">        printf(&quot;没找到两个数的和等于%d\n&quot;, target);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;找到两个数，下标分别为%d和%d，对应的值为%d和%d，和为%d\n&quot;,</span><br><span class="line">            result[0], result[1], num[result[0]], num[result[1]], target);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int* twoSum(int* nums, int numsSize, int target, int* returnSize) &#123;</span><br><span class="line">    for (int i = 0; i &lt; numsSize; i++) &#123;</span><br><span class="line">        for (int j = i + 1; j &lt; numsSize; j++) &#123;</span><br><span class="line">            if (nums[j] == target - nums[i]) &#123;</span><br><span class="line">                int* result = malloc(sizeof(int) * 2);</span><br><span class="line">                result[0] = i;</span><br><span class="line">                result[1] = j;</span><br><span class="line">                *returnSize = 2;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Return an empty array if no solution is found</span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    return malloc(sizeof(int) * 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">// 定义哈希表节点结构体（键：元素值，值：下标）</span><br><span class="line">typedef struct HashNode &#123;</span><br><span class="line">    int key;        // 数组元素的值</span><br><span class="line">    int value;      // 元素的下标</span><br><span class="line">    struct HashNode* next; // 链表指针（处理哈希冲突）</span><br><span class="line">&#125; HashNode;</span><br><span class="line"></span><br><span class="line">// 定义哈希表结构体（桶数组+大小）</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    HashNode** buckets; // 桶数组（每个元素是链表头）</span><br><span class="line">    int size;           // 桶的数量（哈希表大小）</span><br><span class="line">&#125; HashTable;</span><br><span class="line"></span><br><span class="line">// 哈希函数：将key映射到桶的索引（处理负数）</span><br><span class="line">static int hashFunction(HashTable* table, int key) &#123;</span><br><span class="line">    int hash = key % table-&gt;size;</span><br><span class="line">    return hash &lt; 0 ? hash + table-&gt;size : hash; // 确保索引非负</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建哈希表（初始化桶数组）</span><br><span class="line">HashTable* hashTableCreate(int size) &#123;</span><br><span class="line">    HashTable* table = (HashTable*)malloc(sizeof(HashTable));</span><br><span class="line">    table-&gt;size = size;</span><br><span class="line">    table-&gt;buckets = (HashNode**)calloc(size, sizeof(HashNode*)); // 初始化为NULL</span><br><span class="line">    return table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在哈希表中查找key对应的value（不存在返回-1）</span><br><span class="line">static int hashFind(HashTable* table, int key) &#123;</span><br><span class="line">    int index = hashFunction(table, key);</span><br><span class="line">    HashNode* current = table-&gt;buckets[index];</span><br><span class="line">    while (current != NULL) &#123;</span><br><span class="line">        if (current-&gt;key == key) &#123;</span><br><span class="line">            return current-&gt;value; // 找到键，返回下标</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1; // 未找到</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 向哈希表中插入key-value对（头插法）</span><br><span class="line">static void hashInsert(HashTable* table, int key, int value) &#123;</span><br><span class="line">    int index = hashFunction(table, key);</span><br><span class="line">    // 创建新节点并插入链表头部</span><br><span class="line">    HashNode* newNode = (HashNode*)malloc(sizeof(HashNode));</span><br><span class="line">    newNode-&gt;key = key;</span><br><span class="line">    newNode-&gt;value = value;</span><br><span class="line">    newNode-&gt;next = table-&gt;buckets[index]; // 头插法覆盖旧值（本题中无需担心）</span><br><span class="line">    table-&gt;buckets[index] = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放哈希表所有内存（避免泄漏）</span><br><span class="line">static void hashTableFree(HashTable* table) &#123;</span><br><span class="line">    for (int i = 0; i &lt; table-&gt;size; i++) &#123;</span><br><span class="line">        HashNode* current = table-&gt;buckets[i];</span><br><span class="line">        while (current != NULL) &#123;</span><br><span class="line">            HashNode* temp = current;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">            free(temp); // 释放链表节点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(table-&gt;buckets); // 释放桶数组</span><br><span class="line">    free(table);          // 释放哈希表结构体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 两数之和主函数（C语言实现）</span><br><span class="line">int* twoSum(int* nums, int numsSize, int target, int* returnSize) &#123;</span><br><span class="line">    *returnSize = 0; // 初始化返回数组长度为0</span><br><span class="line">    if (numsSize &lt; 2) &#123; // 数组长度不足2，直接返回NULL</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建哈希表（选择较大的质数10007减少冲突）</span><br><span class="line">    HashTable* hashTable = hashTableCreate(10007);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; numsSize; i++) &#123;</span><br><span class="line">        int complement = target - nums[i]; // 计算补数：target - 当前元素值</span><br><span class="line"></span><br><span class="line">        // 查找补数是否存在于哈希表中</span><br><span class="line">        int complementIndex = hashFind(hashTable, complement);</span><br><span class="line">        if (complementIndex != -1) &#123;</span><br><span class="line">            // 找到符合条件的数对，分配结果数组并返回</span><br><span class="line">            int* result = (int*)malloc(2 * sizeof(int));</span><br><span class="line">            result[0] = complementIndex;</span><br><span class="line">            result[1] = i;</span><br><span class="line">            *returnSize = 2;</span><br><span class="line"></span><br><span class="line">            // 释放哈希表内存</span><br><span class="line">            hashTableFree(hashTable);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 未找到补数，将当前元素插入哈希表</span><br><span class="line">        hashInsert(hashTable, nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历结束未找到符合条件的数对，释放哈希表内存</span><br><span class="line">    hashTableFree(hashTable);</span><br><span class="line">    return NULL; // 返回NULL表示未找到（调用者需检查returnSize）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>本文案例是通过随机生成数组内容来检查函数，实际刷题时写出函数即可，不需要全部写出。</p>]]></content>
      
      
      <categories>
          
          <category> C-Code </category>
          
          <category> Data Structures and Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 程序 </tag>
            
            <tag> 函数 </tag>
            
            <tag> leecode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言单链表操作详解（含二级指针深度解析）</title>
      <link href="/posts/379ff51b/"/>
      <url>/posts/379ff51b/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/11.png" alt="二级指针的使用" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>本文档详细解析一段C语言单链表操作的代码，涵盖<strong>头插法插入节点</strong>、<strong>尾插法插入节点</strong>、<strong>修改头节点值</strong>和<strong>打印链表</strong>四大核心功能。重点讲解二级指针在链表操作中的作用，帮助理解动态内存管理与指针操作的核心逻辑。</p><hr><h1 id="二、前置知识：二级指针的本质"><a href="#二、前置知识：二级指针的本质" class="headerlink" title="二、前置知识：二级指针的本质"></a>二、前置知识：二级指针的本质</h1><h2 id="2-1-什么是二级指针？"><a href="#2-1-什么是二级指针？" class="headerlink" title="2.1 什么是二级指针？"></a>2.1 什么是二级指针？</h2><ul><li><strong>一级指针</strong>（<code>Node *head</code>）：存储某个节点的内存地址（指向节点）。</li><li><strong>二级指针</strong>（<code>Node **head</code>）：存储一级指针的内存地址（指向“指向节点的指针”）。</li></ul><h2 id="2-2-为什么链表操作需要二级指针？"><a href="#2-2-为什么链表操作需要二级指针？" class="headerlink" title="2.2 为什么链表操作需要二级指针？"></a>2.2 为什么链表操作需要二级指针？</h2><p>在C语言中，函数参数传递是<strong>值传递</strong>。若链表头指针（<code>head</code>）通过一级指针传递，函数内部对<code>head</code>的修改（如让它指向新节点）只会影响函数的局部副本，外部头指针不会改变。</p><p><strong>示例对比</strong>：</p><ul><li><strong>错误写法（一级指针）</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void insert_head(Node *head, ElementType new_val) &#123; </span><br><span class="line">    Node *new_node = calloc(1, sizeof(Node));</span><br><span class="line">    new_node-&gt;next = head;</span><br><span class="line">    head = new_node;  // 仅修改函数内的局部指针，外部head不受影响！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  调用后外部<code>head</code>仍为<code>NULL</code>，无法实现头插。</p><ul><li><strong>正确写法（二级指针）</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void insert_head(Node **head, ElementType new_val) &#123; </span><br><span class="line">    Node *new_node = calloc(1, sizeof(Node));</span><br><span class="line">    new_node-&gt;next = *head;  // *head 是外部head的当前值（原头节点地址）</span><br><span class="line">    *head = new_node;        // 修改外部head的指向（让它指向新节点）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  调用后外部<code>head</code>会正确指向新节点。</p><p><strong>结论</strong>：二级指针是链表操作的“钥匙”，用于在函数内部修改外部头指针的指向。</p><hr><h1 id="三、完整代码解析"><a href="#三、完整代码解析" class="headerlink" title="三、完整代码解析"></a>三、完整代码解析</h1><h2 id="3-1-代码结构概览"><a href="#3-1-代码结构概览" class="headerlink" title="3.1 代码结构概览"></a>3.1 代码结构概览</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS  // 禁用编译器安全警告</span><br><span class="line">#include &lt;stdio.h&gt;               // 输入输出函数</span><br><span class="line">#include &lt;stdlib.h&gt;              // 内存分配函数</span><br><span class="line">#include &lt;string.h&gt;              // 字符串函数（未直接使用）</span><br><span class="line"></span><br><span class="line">typedef int ElementType;         // 定义链表数据类型为int（可替换）</span><br><span class="line">typedef struct node &#123;            // 链表节点结构体</span><br><span class="line">    ElementType data;            // 数据域：存储节点值</span><br><span class="line">    struct node *next;           // 指针域：指向下一个节点</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">// 头插法插入新节点</span><br><span class="line">void insert_head_null(Node **head, ElementType new_val);</span><br><span class="line">// 修改头节点值（或初始化）</span><br><span class="line">void modify_first_node(Node **head, ElementType new_val);</span><br><span class="line">// 尾插法插入新节点</span><br><span class="line">void insert_tail(Node **head, ElementType new_val);</span><br><span class="line">// 打印链表内容</span><br><span class="line">void print_list(Node *head);</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    Node *head = NULL;  // 初始化空链表</span><br><span class="line">    // 测试各功能...</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-2-核心函数逐行解析"><a href="#3-2-核心函数逐行解析" class="headerlink" title="3.2 核心函数逐行解析"></a>3.2 核心函数逐行解析</h2><h3 id="3-2-1-insert-head-null：头插法插入新节点"><a href="#3-2-1-insert-head-null：头插法插入新节点" class="headerlink" title="3.2.1 insert_head_null：头插法插入新节点"></a>3.2.1 <code>insert_head_null</code>：头插法插入新节点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void insert_head_null(Node **head, ElementType new_val) &#123;</span><br><span class="line">    Node *new_node = calloc(1, sizeof(Node));  // 分配内存并初始化为0</span><br><span class="line">    if (new_node == NULL) &#123;                    // 检查内存分配是否成功</span><br><span class="line">        printf(&quot;calloc failed in insert_head_null\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    new_node-&gt;data = new_val;                  // 设置新节点的数据</span><br><span class="line">    new_node-&gt;next = *head;                    // 新节点的next指向原头节点（*head是外部head的当前值）</span><br><span class="line">    *head = new_node;                          // 修改外部head的指向（让它指向新节点，完成头插）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>功能</strong>：在链表头部插入一个新节点。<br> ​<strong>​实现逻辑​</strong>​：</p><ol><li>用<code>calloc</code>分配新节点内存（<code>calloc</code>会初始化内存为0，避免脏数据）。</li><li>新节点的<code>next</code>指向当前头节点（<code>*head</code>，即外部头指针指向的原头节点）。</li><li>通过<code>*head = new_node</code>修改外部头指针的指向，使其指向新节点（头插的核心操作）。<br> ​<strong>​时间复杂度​</strong>​：O(1)（仅需常数时间完成操作）。</li></ol><p><strong>示例</strong>：</p><ul><li>初始链表：<code>head -&gt; NULL</code>（外部<code>head</code>为<code>NULL</code>）。</li><li>调用<code>insert_head_null(&amp;head, 7)</code>后：<br> <code>new_node</code>的<code>next</code>指向<code>*head</code>（即<code>NULL</code>），然后<code>*head</code>指向<code>new_node</code> → 链表变为<code>7 -&gt; NULL</code>。</li></ul><hr><h3 id="3-2-2-modify-first-node：修改头节点值（或初始化头节点）"><a href="#3-2-2-modify-first-node：修改头节点值（或初始化头节点）" class="headerlink" title="3.2.2 modify_first_node：修改头节点值（或初始化头节点）"></a>3.2.2 <code>modify_first_node</code>：修改头节点值（或初始化头节点）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void modify_first_node(Node **head, ElementType new_val) &#123;</span><br><span class="line">    if (*head == NULL) &#123;  // 链表为空时（头指针为NULL）</span><br><span class="line">        Node *new_node = (Node *)calloc(1, sizeof(Node));  // 创建新节点</span><br><span class="line">        if (new_node == NULL) &#123;</span><br><span class="line">            printf(&quot;calloc failed in modify_first_node\n&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        new_node-&gt;data = new_val;  // 新节点数据设为new_val</span><br><span class="line">        *head = new_node;          // 头指针指向新节点（初始化头节点）</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    (*head)-&gt;data = new_val;  // 链表非空时，直接修改头节点数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>功能</strong>：</p><ul><li>若链表为空（头指针为<code>NULL</code>），则创建一个新节点作为头节点，并设置其值。</li><li>若链表非空，直接修改头节点的数据值。</li></ul><p><strong>关键场景</strong>：处理链表初始化或强制覆盖头节点值的场景。</p><p><strong>示例</strong>：</p><ul><li>初始链表为空（<code>head=NULL</code>），调用<code>modify_first_node(&amp;head, 8)</code>后：<br> 创建新节点<code>new_node</code>，<code>*head</code>指向<code>new_node</code> → 链表变为<code>8 -&gt; NULL</code>。</li><li>若链表已有头节点<code>8 -&gt; NULL</code>，调用后头节点值变为<code>new_val</code>（如<code>888</code>）。</li></ul><hr><h3 id="3-2-3-insert-tail：尾插法插入新节点（修正后）"><a href="#3-2-3-insert-tail：尾插法插入新节点（修正后）" class="headerlink" title="3.2.3 insert_tail：尾插法插入新节点（修正后）"></a>3.2.3 <code>insert_tail</code>：尾插法插入新节点（修正后）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void insert_tail(Node **head, ElementType new_val) &#123;</span><br><span class="line">    Node *new_node = (Node *)calloc(1, sizeof(Node));  // 分配内存</span><br><span class="line">    if (new_node == NULL) &#123;</span><br><span class="line">        printf(&quot;calloc failed in insert_tail\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    new_node-&gt;data = new_val;       // 设置新节点数据</span><br><span class="line">    new_node-&gt;next = NULL;          // 尾节点的next必须为NULL（关键！）</span><br><span class="line"></span><br><span class="line">    if (*head == NULL) &#123;            // 链表为空时（头指针为NULL）</span><br><span class="line">        *head = new_node;           // 头指针直接指向新节点（唯一节点）</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 链表非空时，遍历到最后一个节点</span><br><span class="line">    Node *p = *head;                // p指向当前节点，初始为头节点</span><br><span class="line">    while (p-&gt;next != NULL) &#123;       // 循环直到p的下一个节点是NULL（即找到尾节点）</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = new_node;             // 尾节点的next指向新节点（完成尾插）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>功能</strong>：在链表尾部插入一个新节点。<br> ​<strong>​实现逻辑​</strong>​：</p><ol><li>新节点的<code>next</code>必须设为<code>NULL</code>（尾节点的特征，避免指向随机内存）。</li><li>若链表为空，头指针直接指向新节点；否则遍历到链表末尾（<code>p-&gt;next == NULL</code>），将末尾节点的<code>next</code>指向新节点。<br> ​<strong>​时间复杂度​</strong>​：O(n)（最坏情况下需遍历整个链表）。</li></ol><p><strong>示例</strong>：</p><ul><li>原链表为<code>888 -&gt; 77 -&gt; 7 -&gt; 8 -&gt; NULL</code>，插入<code>6</code>后：<br> 遍历到尾节点<code>8</code>（<code>p-&gt;next == NULL</code>），将<code>p-&gt;next</code>设为<code>new_node</code> → 链表变为<code>888 -&gt; 77 -&gt; 7 -&gt; 8 -&gt; 6 -&gt; NULL</code>。</li></ul><hr><h3 id="3-2-4-print-list：打印链表内容"><a href="#3-2-4-print-list：打印链表内容" class="headerlink" title="3.2.4 print_list：打印链表内容"></a>3.2.4 <code>print_list</code>：打印链表内容</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void print_list(Node *head) &#123;</span><br><span class="line">    if (head == NULL) &#123;  // 处理空链表</span><br><span class="line">        printf(&quot;链表为空\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *p = head;      // p为遍历指针，初始指向头节点</span><br><span class="line">    while (p != NULL) &#123;  // 循环直到p为NULL（遍历完所有节点）</span><br><span class="line">        printf(&quot;%d -&gt; &quot;, p-&gt;data);  // 打印当前节点数据</span><br><span class="line">        p = p-&gt;next;    // p移动到下一个节点</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;NULL\n&quot;);     // 打印链表结束标志</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>功能</strong>：按顺序打印链表的所有节点值，末尾显示<code>NULL</code>表示链表结束。<br> ​<strong>​关键细节​</strong>​：</p><ul><li>若链表为空（<code>head == NULL</code>），打印提示信息。</li><li>遍历指针<code>p</code>从<code>head</code>开始，逐个访问<code>next</code>，直到<code>p</code>为<code>NULL</code>（链表末尾）。</li></ul><p><strong>示例输出</strong>：<br> 若链表为<code>888 -&gt; 77 -&gt; 7 -&gt; 8 -&gt; 6 -&gt; NULL</code>，打印结果为：<br> <code>888 -&gt; 77 -&gt; 7 -&gt; 8 -&gt; 6 -&gt; NULL</code></p><hr><h2 id="四、main函数测试逻辑详解"><a href="#四、main函数测试逻辑详解" class="headerlink" title="四、main函数测试逻辑详解"></a>四、<code>main</code>函数测试逻辑详解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int main(void) &#123;</span><br><span class="line">    Node *head = NULL;  // 初始化空链表（头指针为NULL）</span><br><span class="line"></span><br><span class="line">    // 测试头插法+修改头节点</span><br><span class="line">    insert_head_null(&amp;head, 7);    // 插入7 → 链表：7 -&gt; NULL（*head指向新节点7）</span><br><span class="line">    modify_first_node(&amp;head, 8);   // 修改头节点为8 → 链表：8 -&gt; NULL（*head指向新节点8）</span><br><span class="line">    insert_head_null(&amp;head, 7);    // 头插7 → 链表：7 -&gt; 8 -&gt; NULL（新节点7的next指向原头节点8）</span><br><span class="line">    insert_head_null(&amp;head, 77);   // 头插77 → 链表：77 -&gt; 7 -&gt; 8 -&gt; NULL（新节点77的next指向原头节点7）</span><br><span class="line">    modify_first_node(&amp;head, 888); // 修改头节点为888 → 链表：888 -&gt; 77 -&gt; 7 -&gt; 8 -&gt; NULL（*head指向新节点888）</span><br><span class="line">    </span><br><span class="line">    // 测试尾插法</span><br><span class="line">    insert_tail(&amp;head, 6);         // 尾插6 → 链表：888 -&gt; 77 -&gt; 7 -&gt; 8 -&gt; 6 -&gt; NULL（找到尾节点8，其next指向6）</span><br><span class="line">    </span><br><span class="line">    // 打印最终链表</span><br><span class="line">    print_list(head);              // 输出：888 -&gt; 77 -&gt; 7 -&gt; 8 -&gt; 6 -&gt; NULL</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行流程</strong>：</p><ol><li>初始化空链表（<code>head=NULL</code>）。</li><li><code>insert_head_null(&amp;head, 7)</code>：创建节点7，<code>new_node-&gt;next = *head</code>（即<code>NULL</code>），<code>*head = new_node</code> → 链表：<code>7 -&gt; NULL</code>。</li><li><code>modify_first_node(&amp;head, 8)</code>：链表非空，直接修改头节点数据为8 → 链表：<code>8 -&gt; NULL</code>。</li><li><code>insert_head_null(&amp;head, 7)</code>：创建节点7，<code>new_node-&gt;next = *head</code>（即<code>8</code>的地址），<code>*head = new_node</code> → 链表：<code>7 -&gt; 8 -&gt; NULL</code>。</li><li><code>insert_head_null(&amp;head, 77)</code>：创建节点77，<code>new_node-&gt;next = *head</code>（即<code>7</code>的地址），<code>*head = new_node</code> → 链表：<code>77 -&gt; 7 -&gt; 8 -&gt; NULL</code>。</li><li><code>modify_first_node(&amp;head, 888)</code>：链表非空，直接修改头节点数据为888 → 链表：<code>888 -&gt; 77 -&gt; 7 -&gt; 8 -&gt; NULL</code>。</li><li><code>insert_tail(&amp;head, 6)</code>：创建节点6，<code>new_node-&gt;next = NULL</code>；遍历到尾节点8（<code>p-&gt;next == NULL</code>），<code>p-&gt;next = new_node</code> → 链表：<code>888 -&gt; 77 -&gt; 7 -&gt; 8 -&gt; 6 -&gt; NULL</code>。</li><li><code>print_list(head)</code>：遍历打印所有节点，输出最终结果。</li></ol><hr><h1 id="五、核心注意事项"><a href="#五、核心注意事项" class="headerlink" title="五、核心注意事项"></a>五、核心注意事项</h1><h2 id="5-1-二级指针的本质：修改外部指针的指向"><a href="#5-1-二级指针的本质：修改外部指针的指向" class="headerlink" title="5.1 二级指针的本质：修改外部指针的指向"></a>5.1 二级指针的本质：修改外部指针的指向</h2><ul><li>头指针（<code>head</code>）是外部变量，函数参数用二级指针（<code>Node **head</code>）是为了通过<code>*head</code>直接修改它的指向。</li><li>若不用二级指针，函数内部只能修改指针的副本，外部头指针不会改变（如一级指针的错误写法）。</li></ul><h2 id="5-2-内存分配的安全性"><a href="#5-2-内存分配的安全性" class="headerlink" title="5.2 内存分配的安全性"></a>5.2 内存分配的安全性</h2><ul><li>所有<code>calloc</code>调用后必须检查返回值是否为<code>NULL</code>（内存不足时会返回<code>NULL</code>），否则访问<code>new_node-&gt;data</code>会导致崩溃。</li></ul><h2 id="5-3-尾节点的next必须为NULL"><a href="#5-3-尾节点的next必须为NULL" class="headerlink" title="5.3 尾节点的next必须为NULL"></a>5.3 尾节点的<code>next</code>必须为<code>NULL</code></h2><ul><li>尾插法中，新节点的<code>next</code>必须显式设为<code>NULL</code>，否则可能保留原内存中的随机值（导致链表断裂或访问非法内存）。</li></ul><h2 id="5-4-空链表的边界条件"><a href="#5-4-空链表的边界条件" class="headerlink" title="5.4 空链表的边界条件"></a>5.4 空链表的边界条件</h2><ul><li>所有操作（头插、尾插、修改头节点）都需要先检查链表是否为空（<code>head == NULL</code>），避免访问空指针（如<code>*head-&gt;data</code>会导致崩溃）。</li></ul><hr><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p>本代码通过<strong>头插法</strong>、<strong>尾插法</strong>和<strong>修改头节点</strong>操作，演示了单链表的基本创建和修改过程，并通过<code>print_list</code>函数验证结果。核心目标是理解：</p><ul><li>链表的动态内存管理（<code>calloc</code>分配节点）。</li><li>二级指针的作用（修改外部头指针的指向）。</li><li>边界条件处理（空链表、尾节点）。</li></ul><h1 id="完整源代码："><a href="#完整源代码：" class="headerlink" title="完整源代码："></a>完整源代码：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS  // 禁用编译器安全警告（如scanf的不安全提示）</span><br><span class="line">#include &lt;stdio.h&gt;               // 输入输出函数（如printf）</span><br><span class="line">#include &lt;stdlib.h&gt;              // 内存分配函数（如calloc）</span><br><span class="line"></span><br><span class="line">typedef int ElementType;         // 定义链表存储的数据类型为int（可替换为其他类型）</span><br><span class="line"></span><br><span class="line">// 链表节点结构体定义</span><br><span class="line">typedef struct node &#123;</span><br><span class="line">    ElementType data;            // 数据域：存储节点值</span><br><span class="line">    struct node *next;           // 指针域：指向下一个节点的指针</span><br><span class="line">&#125; Node;                          // 结构体别名（简化后续代码）</span><br><span class="line"></span><br><span class="line">// 头插法插入新节点（修正后）</span><br><span class="line">void insert_head_null(Node **head, ElementType new_val) &#123;</span><br><span class="line">    Node *new_node = calloc(1, sizeof(Node));  // 分配内存并初始化为0</span><br><span class="line">    if (new_node == NULL) &#123;                    // 检查内存分配是否成功</span><br><span class="line">        printf(&quot;calloc failed in insert_head_null\n&quot;);</span><br><span class="line">            return;</span><br><span class="line">    &#125;</span><br><span class="line">    new_node-&gt;data = new_val;                  // 设置新节点的数据</span><br><span class="line">    new_node-&gt;next = *head;                    // 新节点的next指向原头节点（*head是外部head的当前值）</span><br><span class="line">    *head = new_node;                          // 修改外部head的指向（让它指向新节点，完成头插）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改头节点值（或初始化头节点）</span><br><span class="line">void modify_first_node(Node **head, ElementType new_val) &#123;</span><br><span class="line">    if (*head == NULL) &#123;  // 链表为空时（头指针为NULL）</span><br><span class="line">        Node *new_node = (Node *)calloc(1, sizeof(Node));  // 创建新节点</span><br><span class="line">        if (new_node == NULL) &#123;</span><br><span class="line">            printf(&quot;calloc failed in modify_first_node\n&quot;);</span><br><span class="line">                return;</span><br><span class="line">        &#125;</span><br><span class="line">        new_node-&gt;data = new_val;  // 新节点数据设为new_val</span><br><span class="line">        *head = new_node;          // 头指针指向新节点（初始化头节点）</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    (*head)-&gt;data = new_val;  // 链表非空时，直接修改头节点数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 尾插法插入新节点（修正后）</span><br><span class="line">void insert_tail(Node **head, ElementType new_val) &#123;</span><br><span class="line">    Node *new_node = (Node *)calloc(1, sizeof(Node));  // 分配内存</span><br><span class="line">    if (new_node == NULL) &#123;</span><br><span class="line">        printf(&quot;calloc failed in insert_tail\n&quot;);</span><br><span class="line">            return;</span><br><span class="line">    &#125;</span><br><span class="line">    new_node-&gt;data = new_val;       // 设置新节点数据</span><br><span class="line">    new_node-&gt;next = NULL;          // 尾节点的next必须为NULL（关键！）</span><br><span class="line"></span><br><span class="line">    if (*head == NULL) &#123;            // 链表为空时（头指针为NULL）</span><br><span class="line">        *head = new_node;           // 头指针直接指向新节点（唯一节点）</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 链表非空时，遍历到最后一个节点</span><br><span class="line">    Node *p = *head;                // p指向当前节点，初始为头节点</span><br><span class="line">    while (p-&gt;next != NULL) &#123;       // 循环直到p的下一个节点是NULL（即找到尾节点）</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = new_node;             // 尾节点的next指向新节点（完成尾插）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印链表内容</span><br><span class="line">void print_list(Node *head) &#123;</span><br><span class="line">    if (head == NULL) &#123;  // 处理空链表</span><br><span class="line">        printf(&quot;链表为空\n&quot;);</span><br><span class="line">            return;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *p = head;      // p为遍历指针，初始指向头节点</span><br><span class="line">    while (p != NULL) &#123;  // 循环直到p为NULL（遍历完所有节点）</span><br><span class="line">        printf(&quot;%d -&gt; &quot;, p-&gt;data);  // 打印当前节点数据</span><br><span class="line">        p = p-&gt;next;    // p移动到下一个节点</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;NULL\n&quot;);     // 打印链表结束标志</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    Node *head = NULL;  // 初始化空链表（头指针为NULL）</span><br><span class="line"></span><br><span class="line">    // 测试头插法+修改头节点</span><br><span class="line">    insert_head_null(&amp;head, 7);    // 插入7 → 链表：7 -&gt; NULL</span><br><span class="line">    modify_first_node(&amp;head, 8);   // 修改头节点为8 → 链表：8 -&gt; NULL</span><br><span class="line">    insert_head_null(&amp;head, 7);    // 头插7 → 链表：7 -&gt; 8 -&gt; NULL</span><br><span class="line">    insert_head_null(&amp;head, 77);   // 头插77 → 链表：77 -&gt; 7 -&gt; 8 -&gt; NULL</span><br><span class="line">    modify_first_node(&amp;head, 888); // 修改头节点为888 → 链表：888 -&gt; 77 -&gt; 7 -&gt; 8 -&gt; NULL</span><br><span class="line"></span><br><span class="line">    // 测试尾插法</span><br><span class="line">    insert_tail(&amp;head, 6);         // 尾插6 → 链表：888 -&gt; 77 -&gt; 7 -&gt; 8 -&gt; 6 -&gt; NULL</span><br><span class="line"></span><br><span class="line">    // 打印最终链表</span><br><span class="line">    print_list(head);              // 输出：888 -&gt; 77 -&gt; 7 -&gt; 8 -&gt; 6 -&gt; NULL</span><br><span class="line"></span><br><span class="line">    // 释放链表内存（可选，但建议添加）</span><br><span class="line">    Node *p = head;</span><br><span class="line">    while (p != NULL) &#123;</span><br><span class="line">        Node *temp = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        free(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    head = NULL;  // 避免野指针</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><ul><li>内存释放​​：主函数末尾添加了链表内存释放逻辑（可选但推荐），避免内存泄漏。</li><li>二级指针​​：所有修改头指针的操作（头插、修改头节点）均使用二级指针Node **head，确保外部头指针的指向被正确修改。</li><li>边界处理​​：所有函数均检查了空链表（head &#x3D;&#x3D; NULL）和内存分配失败（calloc &#x3D;&#x3D; NULL）的边界条件，保证鲁棒性。此</li><li>代码可直接编译运行，输出结果为：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">888 -&gt; 77 -&gt; 7 -&gt; 8 -&gt; 6 -&gt; NULL</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C-Code </category>
          
          <category> Foundational Syntax and Core Concepts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 程序 </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言数组与指针深度解析</title>
      <link href="/posts/87231a26/"/>
      <url>/posts/87231a26/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/10.png" alt="C语言数组与指针深度解析" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><h1 id="引言：为什么需要理解数组与指针的差异？"><a href="#引言：为什么需要理解数组与指针的差异？" class="headerlink" title="引言：为什么需要理解数组与指针的差异？"></a>引言：为什么需要理解数组与指针的差异？</h1><p>在C语言中，数组和指针是最基础且容易混淆的概念。尤其是<code>*p[]</code>（指针数组）和<code>(*p)[]</code>（数组的数组）的语法差异，涉及类型优先级、内存布局和操作方式的本质区别。本文通过具体代码示例，结合<code>fruits1</code>（二维数组）和<code>fruits2</code>（指针数组）的对比，深入解析两者的核心差异，并探讨实际开发中的应用场景。</p><hr><h1 id="核心概念：-p-与-p-的类型优先级"><a href="#核心概念：-p-与-p-的类型优先级" class="headerlink" title="核心概念：*p[]与(*p)[]的类型优先级"></a>核心概念：<code>*p[]</code>与<code>(*p)[]</code>的类型优先级</h1><p>C语言中，运算符优先级决定了表达式的解析顺序。其中，<code>[]</code>（下标运算符）的优先级高于<code>*</code>（解引用运算符）。因此：</p><ul><li><code>*p[]</code>会被解析为<code>*(p[])</code>，即<strong>数组的指针</strong>（指针数组）：数组的每个元素是指针；</li><li><code>(*p)[]</code>会被解析为<code>(*p)[]</code>，即<strong>数组的数组</strong>（二维数组）：数组的每个元素是另一个数组。</li></ul><p>用户代码中的<code>fruits1</code>和<code>fruits2</code>正是这两种类型的典型代表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char fruits1[][10] = &#123; &quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot; &#125;;  // 二维数组（数组的数组）</span><br><span class="line">char *fruits2[] = &#123; &quot;apple&quot;,&quot;banana&quot;,&quot;cherry&quot; &#125;;       // 指针数组（数组的指针）</span><br></pre></td></tr></table></figure><hr><h1 id="代码逐行解析：从定义到操作的完整流程"><a href="#代码逐行解析：从定义到操作的完整流程" class="headerlink" title="代码逐行解析：从定义到操作的完整流程"></a>代码逐行解析：从定义到操作的完整流程</h1><h2 id="1-数据定义：二维数组-vs-指针数组"><a href="#1-数据定义：二维数组-vs-指针数组" class="headerlink" title="1. 数据定义：二维数组 vs 指针数组"></a>1. 数据定义：二维数组 vs 指针数组</h2><h3 id="fruits1：二维数组（数组的数组）"><a href="#fruits1：二维数组（数组的数组）" class="headerlink" title="fruits1：二维数组（数组的数组）"></a><code>fruits1</code>：二维数组（数组的数组）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char fruits1[][10] = &#123; &quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot; &#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>类型</strong>：<code>char [3][10]</code>（3个元素，每个元素是<code>char [10]</code>的数组）；</li><li><strong>内存布局</strong>：所有字符串连续存储在内存中，形成一个3×10的二维数组（实际存储为<code>&#39;a&#39;,&#39;p&#39;,&#39;p&#39;,&#39;l&#39;,&#39;e&#39;,&#39;\0&#39;,...</code>）；</li><li><strong>特点</strong>：数组名<code>fruits1</code>是常量指针，指向第一个子数组的起始地址（<code>&amp;fruits1[0]</code>）；<code>fruits1[i]</code>是第<code>i</code>个子数组的起始地址（<code>&amp;fruits1[i][0]</code>）。</li></ul><h3 id="fruits2：指针数组（数组的指针）"><a href="#fruits2：指针数组（数组的指针）" class="headerlink" title="fruits2：指针数组（数组的指针）"></a><code>fruits2</code>：指针数组（数组的指针）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *fruits2[] = &#123; &quot;apple&quot;,&quot;banana&quot;,&quot;cherry&quot; &#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>类型</strong>：<code>char *[3]</code>（3个元素，每个元素是<code>char *</code>指针）；</li><li><strong>内存布局</strong>：数组本身存储3个指针（每个指针指向一个字符串字面量的地址）；</li><li><strong>特点</strong>：数组名<code>fruits2</code>是常量指针，指向第一个指针的起始地址（<code>&amp;fruits2[0]</code>）；<code>fruits2[i]</code>是第<code>i</code>个指针的地址（存储字符串字面量的首地址）。</li></ul><hr><h2 id="2-Num-arr函数：打印数组内容与长度"><a href="#2-Num-arr函数：打印数组内容与长度" class="headerlink" title="2. Num_arr函数：打印数组内容与长度"></a>2. <code>Num_arr</code>函数：打印数组内容与长度</h2><p>函数通过<code>sizeof</code>计算数组长度，并遍历打印每个字符串及其长度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void Num_arr() &#123;</span><br><span class="line">    // 打印fruits1（二维数组）</span><br><span class="line">    printf(&quot;Fruits1:</span><br><span class="line">&quot;);</span><br><span class="line">    for (int i = 0; i &lt; (sizeof(fruits1) / sizeof(fruits1[0])); i++) &#123;</span><br><span class="line">        printf(&quot;第%d个字符串是:%s, 字符串长度是:%zu\n&quot;, (i + 1), fruits1[i], strlen(fruits1[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 打印fruits2（指针数组）</span><br><span class="line">    printf(&quot;\nFruits2:\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; sizeof(fruits2) / sizeof(fruits2[0]); ++i) &#123;</span><br><span class="line">        printf(&quot;第%d个字符串是:%s, 字符串长度是:%zu\n&quot;, (i + 1), fruits2[i], strlen(fruits2[i]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键细节</strong>：</p><ul><li><code>sizeof(fruits1) / sizeof(fruits1[0])</code>：计算二维数组的行数（<code>3</code>），因为<code>sizeof(fruits1)</code>是整个二维数组的大小（<code>3×10=30</code>字节），<code>sizeof(fruits1[0])</code>是单个子数组的大小（<code>10</code>字节）；</li><li><code>sizeof(fruits2) / sizeof(fruits2[0])</code>：计算指针数组的元素个数（<code>3</code>），因为<code>sizeof(fruits2)</code>是指针数组的大小（<code>3×8=24</code>字节，假设64位系统），<code>sizeof(fruits2[0])</code>是单个指针的大小（<code>8</code>字节）。</li></ul><hr><h2 id="3-Change函数：修改数组元素的差异"><a href="#3-Change函数：修改数组元素的差异" class="headerlink" title="3. Change函数：修改数组元素的差异"></a>3. <code>Change</code>函数：修改数组元素的差异</h2><p>函数演示了对两种数组的修改操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Change() &#123;</span><br><span class="line">    // fruits1[0] = &quot;orange&quot;;  错误：数组名是常量指针，不可重新赋值</span><br><span class="line">    fruits2[0] = &quot;orange&quot;;    // 正确：指针数组的元素是指针，可重新指向新字符串</span><br><span class="line">    strcpy(fruits1[0], &quot;orange&quot;);  // 正确：修改二维数组的内容（非数组名）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>核心区别</strong>：</p><ul><li><strong><code>fruits1[0]</code></strong>：是二维数组的子数组名（<code>char [10]</code>类型），本质是常量指针（指向子数组的起始地址），无法通过<code>=</code>重新赋值；</li><li><strong><code>fruits2[0]</code></strong>：是指针数组的元素（<code>char *</code>类型），是普通指针变量，可以通过<code>=</code>重新指向其他字符串；</li><li><strong><code>strcpy(fruits1[0], &quot;orange&quot;)</code></strong>：通过<code>strcpy</code>修改二维数组的内容（覆盖原字符串），这是允许的，因为数组名指向的内存区域是可写的。</li></ul><hr><h2 id="4-Chang-banana函数：修改字符的细节"><a href="#4-Chang-banana函数：修改字符的细节" class="headerlink" title="4. Chang_banana函数：修改字符的细节"></a>4. <code>Chang_banana</code>函数：修改字符的细节</h2><p>函数演示了对字符串中单个字符的修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void Chang_banana() &#123;</span><br><span class="line">    fruits1[1][0] = &#x27;B&#x27;;  // 正确：修改二维数组的字符（非字符串字面量）</span><br><span class="line">    fruits2[1] = &quot;Banana&quot;; // 正确：修改指针数组的指向（原字符串未被修改）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ul><li><strong><code>fruits1[1][0] = &#39;B&#39;</code></strong>：<code>fruits1</code>的子数组存储的是字符串<code>&quot;banana&quot;</code>（可写内存），因此可以直接修改第一个字符为<code>&#39;B&#39;</code>（结果为<code>&quot;Banana&quot;</code>）；</li><li><strong><code>fruits2[1] = &quot;Banana&quot;</code></strong>：<code>fruits2[1]</code>原指向字符串字面量<code>&quot;banana&quot;</code>（只读内存），但通过指针重新指向<code>&quot;Banana&quot;</code>（新的可写内存），原<code>&quot;banana&quot;</code>未被修改（若尝试修改<code>&quot;banana&quot;</code>的内容会导致未定义行为）。</li></ul><hr><h2 id="5-主函数：指针数组的灵活操作"><a href="#5-主函数：指针数组的灵活操作" class="headerlink" title="5. 主函数：指针数组的灵活操作"></a>5. 主函数：指针数组的灵活操作</h2><p>主函数定义了另一个指针数组<code>fruits3</code>，并演示了对其的修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main(void) &#123;</span><br><span class="line">    char apple[] = &quot;apple&quot;;   // 栈上的字符数组（可写）</span><br><span class="line">    char banana[] = &quot;banana&quot;; // 栈上的字符数组（可写）</span><br><span class="line">    char cherry[] = &quot;cherry&quot;; // 栈上的字符数组（可写）</span><br><span class="line">    char *fruits3[] = &#123; apple, banana, cherry &#125;; // 指针数组指向栈上的数组</span><br><span class="line"></span><br><span class="line">    fruits3[0] = &quot;orange&quot;;    // 正确：指针重新指向新的字符串（堆或只读区）</span><br><span class="line">    fruits3[1][0] = &#x27;B&#x27;;      // 正确：修改栈上数组的字符（`banana`变为&quot;Banana&quot;）</span><br><span class="line"></span><br><span class="line">    Chang_banana();           // 调用函数修改`fruits1`和`fruits2`</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键场景</strong>：</p><ul><li><code>fruits3</code>是指针数组，元素指向栈上的字符数组（<code>apple</code>、<code>banana</code>、<code>cherry</code>）；</li><li><code>fruits3[0] = &quot;orange&quot;</code>：指针重新指向字符串字面量<code>&quot;orange&quot;</code>（通常存储在只读区）；</li><li><code>fruits3[1][0] = &#39;B&#39;</code>：修改栈上<code>banana</code>数组的第一个字符（<code>&quot;banana&quot;</code>变为<code>&quot;Banana&quot;</code>）。</li></ul><hr><h1 id="内存布局对比：二维数组-vs-指针数组"><a href="#内存布局对比：二维数组-vs-指针数组" class="headerlink" title="内存布局对比：二维数组 vs 指针数组"></a>内存布局对比：二维数组 vs 指针数组</h1><table><thead><tr><th><strong>特性</strong></th><th><strong>二维数组（<code>fruits1</code>）</strong></th><th><strong>指针数组（<code>fruits2</code>）</strong></th></tr></thead><tbody><tr><td><strong>类型</strong></td><td><code>char [3][10]</code>（数组的数组）</td><td><code>char *[3]</code>（数组的指针）</td></tr><tr><td><strong>内存存储</strong></td><td>连续存储（所有字符在一个连续内存块中）</td><td>非连续存储（数组存储指针，指针指向分散的内存）</td></tr><tr><td><strong>修改数组名</strong></td><td>不允许（数组名是常量指针）</td><td>允许（数组名是常量指针，但元素是指针变量）</td></tr><tr><td><strong>修改元素内容</strong></td><td>允许（通过下标修改字符）</td><td>允许（通过指针修改指向的内容或重新指向）</td></tr><tr><td><strong>字符串字面量存储</strong></td><td>存储在数组内存中（可写）</td><td>存储在只读区（不可直接修改内容）</td></tr></tbody></table><hr><h1 id="潜在问题与最佳实践"><a href="#潜在问题与最佳实践" class="headerlink" title="潜在问题与最佳实践"></a>潜在问题与最佳实践</h1><h2 id="问题1：指针数组指向无效内存"><a href="#问题1：指针数组指向无效内存" class="headerlink" title="问题1：指针数组指向无效内存"></a>问题1：指针数组指向无效内存</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *fruits2[] = &#123; &quot;apple&quot;, &quot;banana&quot;, NULL &#125;;  // 最后一个元素为NULL</span><br><span class="line">fruits2[2][0] = &#x27;C&#x27;;  // 崩溃！NULL指针无指向的内存</span><br></pre></td></tr></table></figure><p><strong>原因</strong>：指针数组的元素可能指向<code>NULL</code>或其他无效地址，直接解引用会导致崩溃。<br> ​<strong>​解决方案​</strong>​：操作指针数组前，需检查指针是否为<code>NULL</code>。</p><h2 id="问题2：二维数组越界访问"><a href="#问题2：二维数组越界访问" class="headerlink" title="问题2：二维数组越界访问"></a>问题2：二维数组越界访问</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%s&quot;, fruits1[3]);  // 越界访问！`fruits1`只有3个元素（索引0-2）</span><br></pre></td></tr></table></figure><p><strong>原因</strong>：二维数组的索引范围是<code>0</code>到<code>行数-1</code>，越界访问会导致未定义行为。<br> ​<strong>​解决方案​</strong>​：访问前检查索引是否在有效范围内（<code>0 ≤ i &lt; 行数</code>）。</p><hr><h1 id="总结：数组与指针的核心差异"><a href="#总结：数组与指针的核心差异" class="headerlink" title="总结：数组与指针的核心差异"></a>总结：数组与指针的核心差异</h1><p>通过本文的解析，我们掌握了：</p><ul><li><strong><code>\*p[]</code>（指针数组）</strong>：数组的元素是指针，存储的是内存地址，可灵活指向不同的内存区域；</li><li><strong><code>(\*p)[]</code>（二维数组）</strong>：数组的元素是另一个数组，内存连续存储，适合处理固定大小的字符串集合；</li><li><strong>操作差异</strong>：指针数组可重新指向新内存，二维数组可直接修改内容（需确保内存可写）；</li><li><strong>内存布局</strong>：指针数组非连续存储，二维数组连续存储，各有适用场景（如动态扩展用指针数组，固定数据用二维数组）。</li></ul><p>这些知识是C语言进阶的核心，熟练掌握后可更高效地处理字符串操作、内存管理和复杂数据结构（如链表、哈希表）。</p><hr><h1 id="完整源代码：C语言数组与指针深度解析（-p-vs-p-）"><a href="#完整源代码：C语言数组与指针深度解析（-p-vs-p-）" class="headerlink" title="完整源代码：C语言数组与指针深度解析（*p[] vs (*p)[]）"></a>完整源代码：C语言数组与指针深度解析（<code>*p[]</code> vs <code>(*p)[]</code>）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* 核心目标：对比二维数组（(*p)[]）与指针数组（*p[]）的类型差异与操作限制</span><br><span class="line">* 关键结论：</span><br><span class="line">*   - []优先级高于*，因此*p[]是数组的指针（指针数组），(*p)[]是数组的数组（二维数组）</span><br><span class="line">*   - 二维数组名是常量指针（不可重新赋值），但可通过下标修改元素内容（需内存可写）</span><br><span class="line">*   - 指针数组的元素是指针变量（可重新赋值指向新内存），但指向的内容是否可写取决于目标内存</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 二维数组（数组的数组）：连续内存存储，每个子数组固定大小</span><br><span class="line">char fruits1[][10] = &#123; &quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot; &#125;;  // 3个元素，每个元素是char[10]</span><br><span class="line"></span><br><span class="line">// 指针数组（数组的指针）：存储指针的数组，指针指向独立内存</span><br><span class="line">char *fruits2[] = &#123; &quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot; &#125;;      // 3个元素，每个元素是char*</span><br><span class="line"></span><br><span class="line">// 指针数组指向栈上的字符数组（可写内存）</span><br><span class="line">char apple_stack[] = &quot;apple&quot;;   // 栈上的字符数组（可写）</span><br><span class="line">char banana_stack[] = &quot;banana&quot;; // 栈上的字符数组（可写）</span><br><span class="line">char cherry_stack[] = &quot;cherry&quot;; // 栈上的字符数组（可写）</span><br><span class="line">char *fruits3[] = &#123; apple_stack, banana_stack, cherry_stack &#125;; // 指针数组指向栈数组</span><br><span class="line"></span><br><span class="line">// 函数1：打印数组内容与长度（验证内存布局与可访问性）</span><br><span class="line">void print_arrays() &#123;</span><br><span class="line">    printf(&quot;===== 打印二维数组 fruits1 =====\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; sizeof(fruits1) / sizeof(fruits1[0]); i++) &#123;</span><br><span class="line">        printf(&quot;fruits1[%d]: %s（长度：%zu，内存地址：%p）\n&quot;,</span><br><span class="line">               i, fruits1[i], strlen(fruits1[i]), (void*)fruits1[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n===== 打印指针数组 fruits2 =====\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; sizeof(fruits2) / sizeof(fruits2[0]); i++) &#123;</span><br><span class="line">        printf(&quot;fruits2[%d]: %s（长度：%zu，指针地址：%p，指向内存：%p）\n&quot;,</span><br><span class="line">               i, fruits2[i], strlen(fruits2[i]), (void*)&amp;fruits2[i], (void*)fruits2[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n===== 打印指针数组 fruits3（指向栈数组） =====\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; sizeof(fruits3) / sizeof(fruits3[0]); i++) &#123;</span><br><span class="line">        printf(&quot;fruits3[%d]: %s（长度：%zu，指针地址：%p，指向内存：%p）\n&quot;,</span><br><span class="line">               i, fruits3[i], strlen(fruits3[i]), (void*)&amp;fruits3[i], (void*)fruits3[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数2：修改数组元素（验证操作限制）</span><br><span class="line">void modify_arrays() &#123;</span><br><span class="line">    // 1. 尝试修改二维数组的&quot;数组名&quot;（非法操作）</span><br><span class="line">    // fruits1 = fruits2;  // 编译错误：数组名是常量指针，不可重新赋值</span><br><span class="line"></span><br><span class="line">    // 2. 修改二维数组的内容（通过下标，合法）</span><br><span class="line">    strcpy(fruits1[0], &quot;orange&quot;);  // 正确：覆盖二维数组的内存内容</span><br><span class="line">    fruits1[1][0] = &#x27;B&#x27;;           // 正确：修改二维数组的字符（原&quot;banana&quot;→&quot;Banana&quot;）</span><br><span class="line"></span><br><span class="line">    // 3. 修改指针数组的&quot;数组名&quot;（非法操作）</span><br><span class="line">    // fruits2 = fruits3;  // 错误：数组名是常量指针，不可重新赋值</span><br><span class="line">    // 修正：指针数组的元素是指针，应逐个修改元素指向</span><br><span class="line">    fruits2[0] = &quot;orange&quot;;  // 正确：修改指针数组的第0个元素指向新字符串</span><br><span class="line">    fruits2[1] = &quot;Banana&quot;;  // 正确：修改指针数组的第1个元素指向新字符串（原&quot;banana&quot;未被修改）</span><br><span class="line"></span><br><span class="line">    // 4. 修改指针数组指向的内容（取决于目标内存是否可写）</span><br><span class="line">    fruits3[1][0] = &#x27;b&#x27;;  // 正确：修改栈上的banana_stack数组（可写内存）</span><br><span class="line">    // fruits2[1][0] = &#x27;b&#x27;;  // 未定义行为！fruits2[1]指向字符串字面量（只读内存）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数3：验证指针数组与二维数组的本质区别</span><br><span class="line">void validate_differences() &#123;</span><br><span class="line">    // 二维数组的内存是连续的（所有字符在一个块中）</span><br><span class="line">    printf(&quot;\n===== 验证二维数组内存连续性 =====\n&quot;);</span><br><span class="line">    printf(&quot;fruits1[0]地址：%p，fruits1[0][0]地址：%p（偏移0）\n&quot;,</span><br><span class="line">           (void*)fruits1, (void*)&amp;fruits1[0][0]);</span><br><span class="line">    printf(&quot;fruits1[0]地址：%p，fruits1[0][9]地址：%p（偏移9）\n&quot;,</span><br><span class="line">           (void*)fruits1, (void*)&amp;fruits1[0][9]);</span><br><span class="line">    printf(&quot;fruits1[1]地址：%p（偏移10，与fruits1[0][9]+1一致）\n&quot;,</span><br><span class="line">           (void*)fruits1[1]);</span><br><span class="line"></span><br><span class="line">    // 指针数组的内存是非连续的（存储指针，指针指向分散内存）</span><br><span class="line">    printf(&quot;\n===== 验证指针数组内存非连续性 =====\n&quot;);</span><br><span class="line">    printf(&quot;fruits2[0]指针值：%p（指向字符串字面量）\n&quot;, (void*)fruits2[0]);</span><br><span class="line">    printf(&quot;fruits2[1]指针值：%p（指向字符串字面量）\n&quot;, (void*)fruits2[1]);</span><br><span class="line">    printf(&quot;fruits2[2]指针值：%p（指向字符串字面量）\n&quot;, (void*)fruits2[2]);</span><br><span class="line">    printf(&quot;fruits2数组本身的地址：%p，与指针值无关\n&quot;, (void*)fruits2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    // 初始化后直接打印</span><br><span class="line">    print_arrays();</span><br><span class="line"></span><br><span class="line">    // 修改数组元素并再次打印</span><br><span class="line">    modify_arrays();</span><br><span class="line">    printf(&quot;\n===== 修改后的数组状态 =====\n&quot;);</span><br><span class="line">    print_arrays();</span><br><span class="line"></span><br><span class="line">    // 验证内存布局差异</span><br><span class="line">    validate_differences();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;s</span><br></pre></td></tr></table></figure><hr><h1 id="代码说明与关键注释"><a href="#代码说明与关键注释" class="headerlink" title="代码说明与关键注释"></a>代码说明与关键注释</h1><h2 id="1-数据定义部分"><a href="#1-数据定义部分" class="headerlink" title="1. 数据定义部分"></a>1. 数据定义部分</h2><ul><li><strong><code>fruits1</code>（二维数组）</strong>：<code>char [3][10]</code>类型，3个元素，每个元素是固定大小（10字节）的字符数组。内存连续存储所有字符串，可直接通过下标修改内容（需确保内存可写）。</li><li><strong><code>fruits2</code>（指针数组）</strong>：<code>char *[3]</code>类型，3个元素是指针变量，初始指向字符串字面量（通常存储在只读区）。指针变量本身可重新赋值，但指向的内容是否可写取决于目标内存。</li><li><strong><code>fruits3</code>（指针数组指向栈数组）</strong>：指针数组的元素指向栈上的字符数组（<code>apple_stack</code>等），这些栈数组是可写的，因此可通过指针修改其内容。</li></ul><h2 id="2-print-arrays函数"><a href="#2-print-arrays函数" class="headerlink" title="2. print_arrays函数"></a>2. <code>print_arrays</code>函数</h2><ul><li>打印二维数组的每个子数组内容、长度和内存地址；</li><li>打印指针数组的每个元素（指针值）、指向内容的长度、指针自身地址和指向的内存地址；</li><li>打印指针数组指向栈数组的特殊情况（验证栈内存的可写性）。</li></ul><h2 id="3-modify-arrays函数"><a href="#3-modify-arrays函数" class="headerlink" title="3. modify_arrays函数"></a>3. <code>modify_arrays</code>函数</h2><ul><li><strong>二维数组修改</strong>：通过<code>strcpy</code>覆盖<code>fruits1[0]</code>的内容（合法，因二维数组内存可写）；通过下标修改<code>fruits1[1][0]</code>的字符（合法，因内存可写）。</li><li><strong>指针数组修改</strong>：直接修改指针数组元素的指向（如<code>fruits2[0] = &quot;orange&quot;</code>），但不可直接修改数组名（<code>fruits2 = ...</code>是错误的，因数组名是常量指针）。</li><li><strong>字符串字面量保护</strong>：尝试修改<code>fruits2[1][0]</code>会触发未定义行为（字符串字面量存储在只读区）。</li></ul><h2 id="4-validate-differences函数"><a href="#4-validate-differences函数" class="headerlink" title="4. validate_differences函数"></a>4. <code>validate_differences</code>函数</h2><ul><li><strong>二维数组内存连续性</strong>：验证二维数组的所有字符存储在连续内存中（<code>fruits1[1]</code>的地址等于<code>fruits1[0]</code>的地址+10字节）。</li><li><strong>指针数组内存非连续性</strong>：验证指针数组存储的是指针变量（地址连续），但指针指向的内存是分散的（字符串字面量存储在不同位置）。</li></ul><hr><h1 id="编译与运行结果示例"><a href="#编译与运行结果示例" class="headerlink" title="编译与运行结果示例"></a>编译与运行结果示例</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">===== 打印二维数组 fruits1 =====</span><br><span class="line">fruits1[0]: apple（长度：5，内存地址：0x7ffd...）</span><br><span class="line">fruits1[1]: banana（长度：6，内存地址：0x7ffd...）</span><br><span class="line">fruits1[2]: cherry（长度：6，内存地址：0x7ffd...）</span><br><span class="line"></span><br><span class="line">===== 打印指针数组 fruits2 =====</span><br><span class="line">fruits2[0]: apple（长度：5，指针地址：0x7ffd..., 指向内存：0x55f5...）</span><br><span class="line">fruits2[1]: banana（长度：6，指针地址：0x7ffd..., 指向内存：0x55f5...）</span><br><span class="line">fruits2[2]: cherry（长度：6，指针地址：0x7ffd..., 指向内存：0x55f5...）</span><br><span class="line"></span><br><span class="line">===== 打印指针数组 fruits3（指向栈数组） =====</span><br><span class="line">fruits3[0]: apple（长度：5，指针地址：0x7ffd..., 指向内存：0x7ffd...）</span><br><span class="line">fruits3[1]: banana（长度：6，指针地址：0x7ffd..., 指向内存：0x7ffd...）</span><br><span class="line">fruits3[2]: cherry（长度：6，指针地址：0x7ffd..., 指向内存：0x7ffd...）</span><br><span class="line"></span><br><span class="line">===== 修改后的数组状态 =====</span><br><span class="line">===== 打印二维数组 fruits1 =====</span><br><span class="line">fruits1[0]: orange（长度：6，内存地址：0x7ffd...）</span><br><span class="line">fruits1[1]: Banana（长度：6，内存地址：0x7ffd...）</span><br><span class="line">fruits1[2]: cherry（长度：6，内存地址：0x7ffd...）</span><br><span class="line"></span><br><span class="line">===== 打印指针数组 fruits2 =====</span><br><span class="line">fruits2[0]: orange（长度：6，指针地址：0x7ffd..., 指向内存：0x55f5...）</span><br><span class="line">fruits2[1]: Banana（长度：6，指针地址：0x7ffd..., 指向内存：0x7ffd...）</span><br><span class="line">fruits2[2]: cherry（长度：6，指针地址：0x7ffd..., 指向内存：0x55f5...）</span><br><span class="line"></span><br><span class="line">===== 打印指针数组 fruits3（指向栈数组） =====</span><br><span class="line">fruits3[0]: apple（长度：5，指针地址：0x7ffd..., 指向内存：0x7ffd...）</span><br><span class="line">fruits3[1]: banana（长度：6，指针地址：0x7ffd..., 指向内存：0x7ffd...）</span><br><span class="line">fruits3[2]: cherry（长度：6，指针地址：0x7ffd..., 指向内存：0x7ffd...）</span><br><span class="line"></span><br><span class="line">===== 验证二维数组内存连续性 =====</span><br><span class="line">fruits1[0]地址：0x7ffd..., fruits1[0][0]地址：0x7ffd...（偏移0）</span><br><span class="line">fruits1[0]地址：0x7ffd..., fruits1[0][9]地址：0x7ffd...（偏移9）</span><br><span class="line">fruits1[1]地址：0x7ffd...（偏移10，与fruits1[0][9]+1一致）</span><br><span class="line"></span><br><span class="line">===== 验证指针数组内存非连续性 =====</span><br><span class="line">fruits2[0]指针值：0x55f5...（指向字符串字面量）</span><br><span class="line">fruits2[1]指针值：0x55f5...（指向字符串字面量）</span><br><span class="line">fruits2[2]指针值：0x55f5...（指向字符串字面量）</span><br><span class="line">fruits2数组本身的地址：0x7ffd..., 与指针值无关</span><br></pre></td></tr></table></figure><hr><h1 id="核心结论总结"><a href="#核心结论总结" class="headerlink" title="核心结论总结"></a>核心结论总结</h1><table><thead><tr><th><strong>特性</strong></th><th><strong>二维数组（<code>fruits1</code>）</strong></th><th><strong>指针数组（<code>fruits2</code>）</strong></th></tr></thead><tbody><tr><td><strong>类型</strong></td><td><code>char [3][10]</code>（数组的数组）</td><td><code>char *[3]</code>（数组的指针）</td></tr><tr><td><strong>内存布局</strong></td><td>连续存储（所有字符在一个连续内存块中）</td><td>非连续存储（数组存储指针，指针指向分散的内存）</td></tr><tr><td><strong>修改数组名</strong></td><td>不允许（数组名是常量指针）</td><td>允许修改元素指向（数组名是常量指针，但元素是指针变量）</td></tr><tr><td><strong>修改元素内容</strong></td><td>允许（通过下标修改字符，需内存可写）</td><td>允许（通过指针修改指向的内容或重新指向）</td></tr><tr><td><strong>字符串字面量存储</strong></td><td>存储在数组内存中（可写）</td><td>存储在只读区（不可直接修改内容）</td></tr></tbody></table><p>通过运行和分析此代码，可直观理解<code>*p[]</code>（指针数组）与<code>(*p)[]</code>（二维数组）的本质差异，以及它们在实际开发中的应用场景（如动态扩展用指针数组，固定数据用二维数组）。</p>]]></content>
      
      
      <categories>
          
          <category> C-Code </category>
          
          <category> Foundational Syntax and Core Concepts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 指针 </tag>
            
            <tag> 内存布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现汉诺塔问题：从递归逻辑到代码解析</title>
      <link href="/posts/32b00d45/"/>
      <url>/posts/32b00d45/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/9.png" alt="C语言实现汉诺塔问题：从递归逻辑到代码解析" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><h1 id="引言：为什么需要学习汉诺塔？"><a href="#引言：为什么需要学习汉诺塔？" class="headerlink" title="引言：为什么需要学习汉诺塔？"></a>引言：为什么需要学习汉诺塔？</h1><p>汉诺塔（Hanoi Tower）是计算机科学中最经典的递归问题之一，由法国数学家爱德华·卢卡斯于1883年提出。它不仅是理解递归思想的绝佳案例，更是培养算法思维的基础。本文将通过C语言实现汉诺塔问题的递归解法，详细解析其核心逻辑，并探讨如何通过代码验证和优化提升程序的健壮性。</p><hr><h1 id="问题背景：汉诺塔的规则与目标"><a href="#问题背景：汉诺塔的规则与目标" class="headerlink" title="问题背景：汉诺塔的规则与目标"></a>问题背景：汉诺塔的规则与目标</h1><p>汉诺塔问题描述如下：<br> 假设有3根柱子（起始塔<code>A</code>、辅助塔<code>B</code>、目标塔<code>C</code>），初始时<code>A</code>塔上有<code>n</code>个盘子，按大小顺序从上到下叠放（大盘子在下，小盘子在上）。目标是将所有盘子从<code>A</code>塔移动到<code>C</code>塔，移动过程中需遵守以下规则：</p><ol><li>每次只能移动一个盘子；</li><li>大盘子不能直接放在小盘子上（即任何时刻，小盘子必须在大盘子之上）。</li></ol><p><strong>最少移动步数</strong>：对于<code>n</code>个盘子，最少需要<code>2^n - 1</code>步（数学归纳法可证）。</p><hr><h1 id="代码核心：递归解法的逻辑拆解"><a href="#代码核心：递归解法的逻辑拆解" class="headerlink" title="代码核心：递归解法的逻辑拆解"></a>代码核心：递归解法的逻辑拆解</h1><p>代码通过递归函数<code>move</code>实现了汉诺塔的移动步骤输出，并计算了最少步数。以下是代码的核心部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 递归函数：将n个盘子从start塔移动到target塔，sup为辅助塔</span><br><span class="line">void move(int n, char start, char sup, char target) &#123;</span><br><span class="line">    // 递归出口：仅1个盘子时，直接移动</span><br><span class="line">    if (n == 1) &#123;</span><br><span class="line">        printf(&quot;%c --&gt; %c\n&quot;, start, target);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 第一步：将n-1个盘子从start移动到sup（target作为辅助）</span><br><span class="line">    move(n - 1, start, target, sup);</span><br><span class="line"></span><br><span class="line">    // 第二步：将最大的盘子从start移动到target（直接打印）</span><br><span class="line">    printf(&quot;%c --&gt; %c\n&quot;, start, target);</span><br><span class="line"></span><br><span class="line">    // 第三步：将n-1个盘子从sup移动到target（start作为辅助）</span><br><span class="line">    move(n - 1, sup, start, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = 5;</span><br><span class="line">    long long steps = (1LL &lt;&lt; n) - 1;  // 计算最少步数：2^n - 1</span><br><span class="line">    printf(&quot;完成%d个盘子的汉诺塔问题，最少需要%lld步，全部移动轨迹如下：\n&quot;, n, steps);</span><br><span class="line"></span><br><span class="line">    move(n, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;);  // 调用递归函数输出移动步骤</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="代码逐行解析：递归逻辑的具象化"><a href="#代码逐行解析：递归逻辑的具象化" class="headerlink" title="代码逐行解析：递归逻辑的具象化"></a>代码逐行解析：递归逻辑的具象化</h1><h2 id="1-move函数的参数与递归出口"><a href="#1-move函数的参数与递归出口" class="headerlink" title="1. move函数的参数与递归出口"></a>1. <code>move</code>函数的参数与递归出口</h2><p>函数定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void move(int n, char start, char sup, char target)</span><br></pre></td></tr></table></figure><ul><li><code>n</code>：当前需要移动的盘子数量；</li><li><code>start</code>：起始塔（当前待移动的盘子所在塔）；</li><li><code>sup</code>：辅助塔（用于临时存放盘子）；</li><li><code>target</code>：目标塔（最终需要将盘子移动到的塔）。</li></ul><p><strong>递归出口</strong>（终止条件）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (n == 1) &#123;</span><br><span class="line">    printf(&quot;%c --&gt; %c\n&quot;, start, target);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>n=1</code>时，无需分解问题，直接将唯一的盘子从<code>start</code>塔移动到<code>target</code>塔，打印移动路径后返回。</p><h2 id="2-递归分解：三步移动策略"><a href="#2-递归分解：三步移动策略" class="headerlink" title="2. 递归分解：三步移动策略"></a>2. 递归分解：三步移动策略</h2><p>对于<code>n&gt;1</code>的情况，递归分解为三个步骤（以<code>n=3</code>为例）：</p><h3 id="第一步：将n-1个盘子从start移动到sup"><a href="#第一步：将n-1个盘子从start移动到sup" class="headerlink" title="第一步：将n-1个盘子从start移动到sup"></a>第一步：将<code>n-1</code>个盘子从<code>start</code>移动到<code>sup</code></h3><p>调用<code>move(n-1, start, target, sup)</code>，此时：</p><ul><li>新的起始塔是原<code>start</code>；</li><li>新的目标塔是原<code>sup</code>（因为需要将<code>n-1</code>个盘子暂时存放在这里）；</li><li>新的辅助塔是原<code>target</code>（用于辅助移动<code>n-1</code>个盘子）。</li></ul><p><strong>效果</strong>：<code>n-1</code>个盘子从<code>start</code>塔移动到<code>sup</code>塔，原<code>target</code>塔作为空闲辅助。</p><h3 id="第二步：将最大的盘子从start移动到target"><a href="#第二步：将最大的盘子从start移动到target" class="headerlink" title="第二步：将最大的盘子从start移动到target"></a>第二步：将最大的盘子从<code>start</code>移动到<code>target</code></h3><p>此时，<code>start</code>塔上只剩最大的盘子（因为<code>n-1</code>个盘子已被移走），直接将其移动到<code>target</code>塔，并打印路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%c --&gt; %c\n&quot;, start, target);</span><br></pre></td></tr></table></figure><p><strong>效果</strong>：最大的盘子到达目标塔<code>target</code>，<code>start</code>塔清空。</p><h3 id="第三步：将n-1个盘子从sup移动到target"><a href="#第三步：将n-1个盘子从sup移动到target" class="headerlink" title="第三步：将n-1个盘子从sup移动到target"></a>第三步：将<code>n-1</code>个盘子从<code>sup</code>移动到<code>target</code></h3><p>调用<code>move(n-1, sup, start, target)</code>，此时：</p><ul><li>新的起始塔是原<code>sup</code>（存放着<code>n-1</code>个盘子）；</li><li>新的目标塔是原<code>target</code>（已放置最大盘子，现在需要放置<code>n-1</code>个盘子）；</li><li>新的辅助塔是原<code>start</code>（已清空，用于辅助移动<code>n-1</code>个盘子）。</li></ul><p><strong>效果</strong>：<code>n-1</code>个盘子从<code>sup</code>塔移动到<code>target</code>塔，最终所有盘子到达目标塔。</p><hr><h1 id="主函数：参数设置与结果验证"><a href="#主函数：参数设置与结果验证" class="headerlink" title="主函数：参数设置与结果验证"></a>主函数：参数设置与结果验证</h1><h2 id="1-步数计算：2-n-1的数学依据"><a href="#1-步数计算：2-n-1的数学依据" class="headerlink" title="1. 步数计算：2^n - 1的数学依据"></a>1. 步数计算：<code>2^n - 1</code>的数学依据</h2><p>主函数中通过位运算计算总步数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long long steps = (1LL &lt;&lt; n) - 1;</span><br></pre></td></tr></table></figure><ul><li><code>1LL &lt;&lt; n</code>表示将1左移<code>n</code>位（等价于<code>2^n</code>）；</li><li>减1后得到<code>2^n - 1</code>，即汉诺塔问题的最少移动步数（数学归纳法可证：当<code>n=1</code>时，步数为1；假设<code>n=k</code>时步数为<code>2^k - 1</code>，则<code>n=k+1</code>时步数为<code>2*(2^k - 1) + 1 = 2^(k+1) - 1</code>）。</li></ul><h2 id="2-调用move函数输出移动轨迹"><a href="#2-调用move函数输出移动轨迹" class="headerlink" title="2. 调用move函数输出移动轨迹"></a>2. 调用<code>move</code>函数输出移动轨迹</h2><p>通过<code>move(n, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;)</code>启动递归，输出从<code>A</code>塔到<code>C</code>塔的完整移动路径。</p><hr><h1 id="测试与验证：不同n值的输出效果"><a href="#测试与验证：不同n值的输出效果" class="headerlink" title="测试与验证：不同n值的输出效果"></a>测试与验证：不同<code>n</code>值的输出效果</h1><h2 id="测试1：n-1（最小情况）"><a href="#测试1：n-1（最小情况）" class="headerlink" title="测试1：n=1（最小情况）"></a>测试1：<code>n=1</code>（最小情况）</h2><p><strong>输入</strong>：<code>n=1</code><br> ​<strong>​预期输出​</strong>​：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">完成1个盘子的汉诺塔问题，最少需要1步，全部移动轨迹如下：</span><br><span class="line">A --&gt; C</span><br></pre></td></tr></table></figure><h2 id="测试2：n-2（基础情况）"><a href="#测试2：n-2（基础情况）" class="headerlink" title="测试2：n=2（基础情况）"></a>测试2：<code>n=2</code>（基础情况）</h2><p><strong>递归过程</strong>：</p><ol><li>将1个盘子从<code>A</code>移动到<code>B</code>（<code>move(1, &#39;A&#39;, &#39;C&#39;, &#39;B&#39;)</code>）；</li><li>将最大的盘子从<code>A</code>移动到<code>C</code>（打印<code>A --&gt; C</code>）；</li><li>将1个盘子从<code>B</code>移动到<code>C</code>（<code>move(1, &#39;B&#39;, &#39;A&#39;, &#39;C&#39;)</code>）。</li></ol><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">完成2个盘子的汉诺塔问题，最少需要3步，全部移动轨迹如下：</span><br><span class="line">A --&gt; B</span><br><span class="line">A --&gt; C</span><br><span class="line">B --&gt; C</span><br></pre></td></tr></table></figure><h2 id="测试3：n-3（验证递归分解）"><a href="#测试3：n-3（验证递归分解）" class="headerlink" title="测试3：n=3（验证递归分解）"></a>测试3：<code>n=3</code>（验证递归分解）</h2><p><strong>输出</strong>（部分步骤）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">完成3个盘子的汉诺塔问题，最少需要7步，全部移动轨迹如下：</span><br><span class="line">A --&gt; CA --&gt; BC --&gt; BA --&gt; C</span><br><span class="line">B --&gt; AB --&gt; CA --&gt; C</span><br></pre></td></tr></table></figure><hr><h1 id="潜在问题与改进建议"><a href="#潜在问题与改进建议" class="headerlink" title="潜在问题与改进建议"></a>潜在问题与改进建议</h1><h2 id="问题1：未处理非法输入（如n≤0）"><a href="#问题1：未处理非法输入（如n≤0）" class="headerlink" title="问题1：未处理非法输入（如n≤0）"></a>问题1：未处理非法输入（如<code>n≤0</code>）</h2><p>当前代码中<code>n</code>固定为5，若用户输入<code>n=0</code>或负数，<code>steps</code>会计算为<code>0</code>或负数，导致逻辑错误。</p><p><strong>改进建议</strong>：读者复现的时候添加输入验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    printf(&quot;请输入盘子数量（n≥1）：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    if (n &lt; 1) &#123;</span><br><span class="line">        printf(&quot;错误：盘子数量必须大于0！\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 后续代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题2：递归深度过大导致栈溢出"><a href="#问题2：递归深度过大导致栈溢出" class="headerlink" title="问题2：递归深度过大导致栈溢出"></a>问题2：递归深度过大导致栈溢出</h2><p>当<code>n</code>很大时（如<code>n=20</code>），递归调用次数为<code>2^20 - 1 ≈ 100万次</code>，可能超出栈空间限制，导致程序崩溃。</p><p><strong>改进建议</strong>：读者复现的时候,对于大<code>n</code>，可改用迭代法（如基于栈的模拟递归），或增加编译器栈空间（如GCC的<code>-Wl,--stack=268435456</code>选项）。</p><h2 id="问题3：输出格式可优化"><a href="#问题3：输出格式可优化" class="headerlink" title="问题3：输出格式可优化"></a>问题3：输出格式可优化</h2><p>当前输出仅打印移动路径，未明确标注每一步的盘子编号（如“移动第3个盘子”）。</p><p><strong>改进建议</strong>：读者复现的时候,在<code>printf</code>中添加盘子编号（需跟踪当前移动的盘子大小）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 修改move函数，增加当前移动的盘子大小参数</span><br><span class="line">void move(int n, char start, char sup, char target, int disk) &#123;</span><br><span class="line">    if (n == 1) &#123;</span><br><span class="line">        printf(&quot;移动盘子%d：%c --&gt; %c\n&quot;, disk, start, target);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    move(n - 1, start, target, sup, n);  // 移动n-1个盘子（最大的盘子是n）</span><br><span class="line">    printf(&quot;移动盘子%d：%c --&gt; %c\n&quot;, n, start, target);  // 移动最大的盘子</span><br><span class="line">    move(n - 1, sup, start, target, n);  // 移动n-1个盘子</span><br><span class="line">&#125;</span><br><span class="line">// 调用时传入当前最大的盘子编号（初始为n）</span><br><span class="line">move(n, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, n);</span><br></pre></td></tr></table></figure><hr><h2 id="总结：汉诺塔问题的核心价值"><a href="#总结：汉诺塔问题的核心价值" class="headerlink" title="总结：汉诺塔问题的核心价值"></a>总结：汉诺塔问题的核心价值</h2><p>汉诺塔问题不仅是递归算法的经典案例，更是理解分治思想（将大问题分解为子问题）的绝佳载体。通过本文的解析，我们掌握了：</p><ul><li>递归解法的核心逻辑（三步分解策略）；</li><li>最少步数的数学推导（<code>2^n - 1</code>）；</li><li>代码的测试与验证方法；</li><li>常见问题的改进方向（输入验证、栈溢出、输出优化）。</li></ul><p>这些经验对学习其他递归算法（如快速排序、归并排序）具有重要参考价值。实际开发中，可根据需求扩展功能（如记录移动时间、可视化动画），进一步提升对算法的理解。</p>]]></content>
      
      
      <categories>
          
          <category> C-Code </category>
          
          <category> Data Structures and Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 汉诺塔 </tag>
            
            <tag> 递归算法 </tag>
            
            <tag> 经典问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言命令行参数处理</title>
      <link href="/posts/58515f71/"/>
      <url>/posts/58515f71/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/8.png" alt="C语言命令行参数处理" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><h1 id="引言：为什么需要处理命令行参数？"><a href="#引言：为什么需要处理命令行参数？" class="headerlink" title="引言：为什么需要处理命令行参数？"></a>引言：为什么需要处理命令行参数？</h1><p>在开发命令行工具时，我们经常需要通过参数传递输入数据或配置选项。例如，一个计算器工具可能需要接收两个数值作为输入，一个文本处理工具可能需要指定输入文件路径。C语言中，<code>main</code>函数的<code>argc</code>和<code>argv</code>参数是处理命令行输入的核心接口。本文将通过一个具体案例，详细解析如何从命令行参数中读取数据、进行数值计算，并输出结果。</p><hr><h1 id="核心功能：命令行参数的读取与处理"><a href="#核心功能：命令行参数的读取与处理" class="headerlink" title="核心功能：命令行参数的读取与处理"></a>核心功能：命令行参数的读取与处理</h1><p>用户提供的代码实现了以下核心功能：</p><ol><li><strong>读取命令行参数数量</strong>（<code>argc</code>）并打印；</li><li><strong>遍历所有命令行参数</strong>（<code>argv</code>）并打印每个参数的内容；</li><li><strong>从指定参数中解析数值</strong>（整数<code>num1</code>和浮点数<code>num2</code>）；</li><li><strong>计算两数之和</strong>并格式化输出结果；</li><li><strong>使用第四个参数作为结果的描述字符串</strong>。</li></ol><hr><h1 id="代码逐行解析：从参数获取到结果输出"><a href="#代码逐行解析：从参数获取到结果输出" class="headerlink" title="代码逐行解析：从参数获取到结果输出"></a>代码逐行解析：从参数获取到结果输出</h1><h2 id="1-main函数参数：argc与argv"><a href="#1-main函数参数：argc与argv" class="headerlink" title="1. main函数参数：argc与argv"></a>1. <code>main</code>函数参数：<code>argc</code>与<code>argv</code></h2><p>C语言中，<code>main</code>函数的标准形式为<code>int main(int argc, char *argv[])</code>，其中：</p><ul><li><code>argc</code>（Argument Count）：命令行参数的数量（包含程序名本身）；</li><li><code>argv</code>（Argument Vector）：指向参数数组的指针，<code>argv[0]</code>是程序名，<code>argv[1]</code>是第一个用户参数，依此类推。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[]) &#123; </span><br><span class="line">// argc=参数数量，argv=参数数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-打印参数数量与内容"><a href="#2-打印参数数量与内容" class="headerlink" title="2. 打印参数数量与内容"></a>2. 打印参数数量与内容</h2><p>代码首先打印参数数量<code>argc</code>，然后通过循环遍历<code>argv</code>数组，打印每个参数的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;argument count = %d\n&quot;, argc);  // 输出参数总数（含程序名）</span><br><span class="line">for (int i = 0; i &lt; argc; i++) &#123;</span><br><span class="line">    printf(&quot;argv[%d]：%s\n&quot;, i, argv[i]);  // 输出每个参数的索引和内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例输出</strong>（假设程序名为<code>calc</code>，输入参数为<code>5 3.14 结果</code>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">argument count = 4</span><br><span class="line">argv[0]：calc</span><br><span class="line">argv[1]：5</span><br><span class="line">argv[2]：3.14</span><br><span class="line">argv[3]：结果</span><br></pre></td></tr></table></figure><h2 id="3-解析数值参数：sscanf的使用"><a href="#3-解析数值参数：sscanf的使用" class="headerlink" title="3. 解析数值参数：sscanf的使用"></a>3. 解析数值参数：<code>sscanf</code>的使用</h2><p>代码使用<code>sscanf</code>从<code>argv[1]</code>和<code>argv[2]</code>中解析整数和浮点数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sscanf(argv[1], &quot;%d&quot;, &amp;num1);       // 从argv[1]读取整数到num1</span><br><span class="line">sscanf(argv[2], &quot;%lf&quot;, &amp;num2);      // 从argv[2]读取浮点数到num2</span><br></pre></td></tr></table></figure><p><strong>关键点</strong>：</p><ul><li><code>sscanf</code>的第一个参数是输入字符串（此处为命令行参数），第二个是格式控制符（<code>%d</code>匹配整数，<code>%lf</code>匹配双精度浮点数），第三个是存储结果的变量地址；</li><li>若参数格式不匹配（如<code>argv[1]</code>是字符串<code>&quot;abc&quot;</code>），<code>sscanf</code>会返回0（未成功读取），但代码未处理此错误，可能导致后续计算错误。</li></ul><h2 id="4-数值计算与结果输出"><a href="#4-数值计算与结果输出" class="headerlink" title="4. 数值计算与结果输出"></a>4. 数值计算与结果输出</h2><p>计算两数之和<code>num3</code>，并使用<code>printf</code>格式化输出结果，其中<code>argv[3]</code>作为结果的描述字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double num3 = num1 + num2;  // 计算和</span><br><span class="line">printf(&quot;结果字符串：%d + %.2f = %.2f %s</span><br><span class="line">&quot;, num1, num2, num3, argv[3]);  // 格式化输出</span><br></pre></td></tr></table></figure><p><strong>格式化说明</strong>：</p><ul><li><code>%d</code>：输出整数<code>num1</code>；</li><li><code>%.2f</code>：输出浮点数<code>num2</code>并保留2位小数；</li><li><code>%.2f</code>：输出和<code>num3</code>并保留2位小数；</li><li><code>%s</code>：输出描述字符串<code>argv[3]</code>。</li></ul><p><strong>示例输出</strong>（输入参数为<code>5 3.14 结果</code>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果字符串：5 + 3.14 = 8.14 结果</span><br></pre></td></tr></table></figure><hr><h1 id="测试与验证：不同输入场景的效果"><a href="#测试与验证：不同输入场景的效果" class="headerlink" title="测试与验证：不同输入场景的效果"></a>测试与验证：不同输入场景的效果</h1><h2 id="场景1：正确输入（4个参数）"><a href="#场景1：正确输入（4个参数）" class="headerlink" title="场景1：正确输入（4个参数）"></a>场景1：正确输入（4个参数）</h2><p><strong>输入命令</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./calc 10 2.5 示例结果</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">argument count = 4</span><br><span class="line">argv[0]：./calc</span><br><span class="line">argv[1]：10</span><br><span class="line">argv[2]：2.5</span><br><span class="line">argv[3]：示例结果</span><br><span class="line">结果字符串：10 + 2.50 = 12.50 示例结果</span><br></pre></td></tr></table></figure><h2 id="场景2：参数不足（仅3个参数）"><a href="#场景2：参数不足（仅3个参数）" class="headerlink" title="场景2：参数不足（仅3个参数）"></a>场景2：参数不足（仅3个参数）</h2><p><strong>输入命令</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./calc 10 2.5</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">argument count = 3</span><br><span class="line">argv[0]：./calc</span><br><span class="line">argv[1]：10</span><br><span class="line">argv[2]：2.5</span><br><span class="line">结果字符串：10 + 2.50 = 12.50 (null)  // argv[3]为NULL，输出空</span><br></pre></td></tr></table></figure><h2 id="场景3：参数格式错误（非数字参数）"><a href="#场景3：参数格式错误（非数字参数）" class="headerlink" title="场景3：参数格式错误（非数字参数）"></a>场景3：参数格式错误（非数字参数）</h2><p><strong>输入命令</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./calc abc 2.5 结果</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">argument count = 4</span><br><span class="line">argv[0]：./calc</span><br><span class="line">argv[1]：abc</span><br><span class="line">argv[2]：2.5</span><br><span class="line">argv[3]：结果</span><br><span class="line">结果字符串：0 + 2.50 = 2.50 结果  // num1未被正确解析为0（sscanf失败）</span><br></pre></td></tr></table></figure><hr><h1 id="潜在问题"><a href="#潜在问题" class="headerlink" title="潜在问题"></a>潜在问题</h1><h2 id="问题1：未检查参数数量"><a href="#问题1：未检查参数数量" class="headerlink" title="问题1：未检查参数数量"></a>问题1：未检查参数数量</h2><p>代码假设用户至少输入4个参数（<code>argv[0]</code>到<code>argv[3]</code>），但未验证<code>argc</code>是否≥4。若用户输入参数不足（如仅3个），<code>argv[3]</code>会是<code>NULL</code>，导致<code>printf</code>输出空字符串或崩溃。</p><p><strong>改进建议</strong>：读者复现的时候添加参数数量检查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (argc &lt; 4) &#123;</span><br><span class="line">    printf(&quot;错误：需要至少4个参数（程序名、整数、浮点数、结果描述）</span><br><span class="line">&quot;);</span><br><span class="line">    return 1;  // 异常退出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题2：未处理sscanf解析失败"><a href="#问题2：未处理sscanf解析失败" class="headerlink" title="问题2：未处理sscanf解析失败"></a>问题2：未处理<code>sscanf</code>解析失败</h3><p>若<code>argv[1]</code>或<code>argv[2]</code>的格式不符合要求（如<code>argv[1]</code>是字符串<code>&quot;abc&quot;</code>），<code>sscanf</code>会返回0，导致<code>num1</code>或<code>num2</code>未被正确赋值（保持初始值0），最终结果错误。</p><p><strong>改进建议</strong>：读者复现的时候检查<code>sscanf</code>的返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int ret1 = sscanf(argv[1], &quot;%d&quot;, &amp;num1);</span><br><span class="line">int ret2 = sscanf(argv[2], &quot;%lf&quot;, &amp;num2);</span><br><span class="line">if (ret1 != 1 || ret2 != 1) &#123;</span><br><span class="line">    printf(&quot;错误：参数格式不正确（整数或浮点数）\n&quot;);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题3：浮点数精度丢失"><a href="#问题3：浮点数精度丢失" class="headerlink" title="问题3：浮点数精度丢失"></a>问题3：浮点数精度丢失</h3><p><code>num2</code>是<code>double</code>类型（双精度浮点数），但<code>sscanf</code>使用<code>%lf</code>读取，而<code>printf</code>使用<code>%.2f</code>输出（单精度格式）。虽然结果可能正确，但严格来说，双精度浮点数应使用<code>%lf</code>格式符（尽管在大多数编译器中<code>%f</code>和<code>%lf</code>对<code>printf</code>是等价的）。</p><p><strong>改进建议</strong>：读者复现的时候统一使用<code>%lf</code>格式符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;结果字符串：%d + %.2lf = %.2lf %s\n&quot;, num1, num2, num3, argv[3]);</span><br></pre></td></tr></table></figure><hr><h1 id="总结：命令行参数处理的核心价值"><a href="#总结：命令行参数处理的核心价值" class="headerlink" title="总结：命令行参数处理的核心价值"></a>总结：命令行参数处理的核心价值</h1><p>命令行参数处理是C语言开发中连接用户输入与程序逻辑的关键环节。通过本文的解析，我们掌握了：</p><ul><li><code>argc</code>和<code>argv</code>的基本用法（参数数量与内容获取）；</li><li><code>sscanf</code>的格式化输入解析（从字符串读取数值）；</li><li>数值计算的格式化输出（控制精度与格式）；</li><li>常见错误处理（参数不足、格式错误）。</li></ul><p>这些技能是开发命令行工具（如计算器、文件处理器）的基础。实际开发中，建议结合错误处理逻辑，提升程序的健壮性；对于复杂参数（如选项参数<code>-h</code>、<code>-v</code>），可使用<code>getopt</code>库简化解析过程。</p><hr><h1 id="完整源代码"><a href="#完整源代码" class="headerlink" title="完整源代码"></a>完整源代码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">命令行操作，main函数传参，调试，看输出情况</span><br><span class="line">*/</span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    // 检查参数数量是否足够（至少4个参数：程序名、整数、浮点数、结果描述）</span><br><span class="line">    if (argc &lt; 4) &#123;</span><br><span class="line">        printf(&quot;错误：需要至少4个参数（格式：程序名 整数 浮点数 结果描述）\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int num1;</span><br><span class="line">    double num2;</span><br><span class="line"></span><br><span class="line">    // 解析整数参数（argv[1]）</span><br><span class="line">    int ret1 = sscanf(argv[1], &quot;%d&quot;, &amp;num1);</span><br><span class="line">    if (ret1 != 1) &#123;</span><br><span class="line">        printf(&quot;错误：第一个参数必须是整数（当前值：%s）\n&quot;, argv[1]);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 解析浮点数参数（argv[2]）</span><br><span class="line">    int ret2 = sscanf(argv[2], &quot;%lf&quot;, &amp;num2);</span><br><span class="line">    if (ret2 != 1) &#123;</span><br><span class="line">        printf(&quot;错误：第二个参数必须是浮点数（当前值：%s）\n&quot;, argv[2]);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 计算和</span><br><span class="line">    double num3 = num1 + num2;</span><br><span class="line"></span><br><span class="line">    // 格式化输出结果（使用argv[3]作为描述）</span><br><span class="line">    printf(&quot;结果字符串：%d + %.2lf = %.2lf %s\n&quot;, num1, num2, num3, argv[3]);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Operating-Systems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 命令行参数 </tag>
            
            <tag> 输入处理 </tag>
            
            <tag> 数值计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vector动态数组复现</title>
      <link href="/posts/18c2def7/"/>
      <url>/posts/18c2def7/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/7.png" alt="Vector动态数组复现" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><h1 id="引言：为什么需要动态数组？"><a href="#引言：为什么需要动态数组？" class="headerlink" title="引言：为什么需要动态数组？"></a>引言：为什么需要动态数组？</h1><p>在C语言中，静态数组的大小在编译时确定，无法根据运行时需求动态调整。当数据量不确定或需要频繁插入&#x2F;删除元素时，静态数组会暴露出明显缺陷：要么浪费内存（声明过大），要么溢出（声明过小）。动态数组（Vector）通过<strong>堆内存分配</strong>和<strong>自动扩容</strong>机制，完美解决了这一问题。它支持灵活的元素插入、删除，且内存使用更高效，是实现栈、队列等高级数据结构的基础。</p><hr><h1 id="核心结构：Vector的设计哲学"><a href="#核心结构：Vector的设计哲学" class="headerlink" title="核心结构：Vector的设计哲学"></a>核心结构：Vector的设计哲学</h1><h2 id="结构体定义：封装底层细节"><a href="#结构体定义：封装底层细节" class="headerlink" title="结构体定义：封装底层细节"></a>结构体定义：封装底层细节</h2><p>代码中的<code>Vector</code>结构体通过三个字段封装了动态数组的核心状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    ElemType *table;   // 指向堆空间的数组（存储实际元素）</span><br><span class="line">    int  size;         // 当前元素个数（逻辑长度）</span><br><span class="line">    int  capacity;     // 数组的最大容量（物理长度）</span><br><span class="line">&#125; Vector;</span><br></pre></td></tr></table></figure><ul><li><code>table</code>：指向堆内存的指针，存储实际的元素数据；</li><li><code>size</code>：当前已存储的元素数量（动态变化）；</li><li><code>capacity</code>：数组的总容量（静态限制，需扩容时调整）。</li></ul><h2 id="类型别名：提升可维护性"><a href="#类型别名：提升可维护性" class="headerlink" title="类型别名：提升可维护性"></a>类型别名：提升可维护性</h2><p>通过<code>typedef int ElemType</code>定义元素类型别名，未来若需修改元素类型（如改为<code>float</code>或自定义结构体），只需调整<code>ElemType</code>的定义即可，无需修改整个代码库。这种设计模拟了C++的泛型思想，提升了代码的可扩展性。</p><hr><h1 id="关键函数解析：从初始化到销毁"><a href="#关键函数解析：从初始化到销毁" class="headerlink" title="关键函数解析：从初始化到销毁"></a>关键函数解析：从初始化到销毁</h1><h2 id="1-create-Vector：初始化动态数组"><a href="#1-create-Vector：初始化动态数组" class="headerlink" title="1. create_Vector：初始化动态数组"></a>1. <code>create_Vector</code>：初始化动态数组</h2><p>初始化函数的核心是<strong>分配堆内存</strong>并设置初始状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Vector *create_Vector() &#123;</span><br><span class="line">    Vector *vec = (Vector *)malloc(sizeof(Vector));  // 分配结构体内存</span><br><span class="line">    if (vec == NULL) &#123; /* 内存分配失败处理 */ &#125;</span><br><span class="line"></span><br><span class="line">    vec-&gt;table = malloc(DEFAULT_CAPACITY * sizeof(ElemType));  // 分配元素存储空间</span><br><span class="line">    if (vec-&gt;table == NULL) &#123; /* 释放结构体并报错 */ &#125;</span><br><span class="line"></span><br><span class="line">    vec-&gt;size = 0;       // 初始无元素</span><br><span class="line">    vec-&gt;capacity = DEFAULT_CAPACITY;  // 初始容量为默认值（10）</span><br><span class="line">    return vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点</strong>：</p><ul><li>使用<code>malloc</code>分配结构体和元素存储空间，需检查返回值避免空指针；</li><li>初始容量<code>DEFAULT_CAPACITY</code>设为10，平衡了内存利用率和扩容频率；</li><li>返回指向<code>Vector</code>结构体的指针，后续操作通过该指针访问动态数组。</li></ul><h2 id="2-vector-destroy：释放内存"><a href="#2-vector-destroy：释放内存" class="headerlink" title="2. vector_destroy：释放内存"></a>2. <code>vector_destroy</code>：释放内存</h2><p>销毁函数负责<strong>释放堆内存</strong>，避免内存泄漏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void vector_destroy(Vector *v) &#123;</span><br><span class="line">    free(v-&gt;table);  // 先释放元素存储空间</span><br><span class="line">    free(v);         // 再释放结构体本身</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：必须按顺序释放（先<code>table</code>后<code>v</code>），否则会导致结构体指针失效，无法安全释放<code>table</code>。</p><h2 id="3-vector-resize：动态扩容"><a href="#3-vector-resize：动态扩容" class="headerlink" title="3. vector_resize：动态扩容"></a>3. <code>vector_resize</code>：动态扩容</h2><p>当元素数量达到容量时（<code>size == capacity</code>），需调用<code>vector_resize</code>扩容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void vector_resize(Vector *v) &#123;</span><br><span class="line">    ElemType *p2 = realloc(v-&gt;table, v-&gt;capacity * 2 * sizeof(ElemType));  // 扩容为2倍</span><br><span class="line">    if (p2 == NULL) &#123; /* 扩容失败处理 */ &#125;</span><br><span class="line">    v-&gt;table = p2;       // 更新指针</span><br><span class="line">    v-&gt;capacity *= 2;    // 容量翻倍</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设计思想</strong>：</p><ul><li>采用<strong>二倍递增</strong>策略（每次扩容为原容量的2倍），保证插入操作的均摊时间复杂度为O(1)；</li><li><code>realloc</code>会尝试在原内存位置扩展，若失败则分配新内存并复制数据，避免频繁内存分配的开销；</li><li><code>static</code>修饰符确保该函数仅在当前文件可见，隐藏实现细节（封装性）。</li></ul><hr><h1 id="核心操作：插入与打印"><a href="#核心操作：插入与打印" class="headerlink" title="核心操作：插入与打印"></a>核心操作：插入与打印</h1><h2 id="1-vector-push-back：尾部插入"><a href="#1-vector-push-back：尾部插入" class="headerlink" title="1. vector_push_back：尾部插入"></a>1. <code>vector_push_back</code>：尾部插入</h2><p>尾部插入是最常用的操作，直接在<code>size</code>位置添加元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void vector_push_back(Vector *v, ElemType element) &#123;</span><br><span class="line">    if (v-&gt;size == v-&gt;capacity) vector_resize(v);  // 扩容检查</span><br><span class="line">    v-&gt;table[v-&gt;size] = element;  // 在size位置写入元素</span><br><span class="line">    v-&gt;size++;                    // 元素数量+1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>时间复杂度O(1)（均摊，因扩容概率低）；</li><li>无需移动现有元素，效率最高。</li></ul><h2 id="2-vector-push-front：头部插入"><a href="#2-vector-push-front：头部插入" class="headerlink" title="2. vector_push_front：头部插入"></a>2. <code>vector_push_front</code>：头部插入</h2><p>头部插入需要将所有现有元素后移一位，为新元素腾出空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void vector_push_front(Vector *v, ElemType val) &#123;</span><br><span class="line">    if (v-&gt;size == v-&gt;capacity) vector_resize(v);  // 扩容检查</span><br><span class="line">    for (int i = v-&gt;size; i &gt; 0; i--) &#123;  // 元素后移</span><br><span class="line">        v-&gt;table[i] = v-&gt;table[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    v-&gt;table[0] = val;  // 在头部写入元素</span><br><span class="line">    v-&gt;size++;           // 元素数量+1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>时间复杂度O(n)（n为当前元素数量），因需移动所有元素；</li><li>适用于需要频繁在头部操作的场景（如队列的头部插入）。</li></ul><h2 id="3-vector-insert：中间插入"><a href="#3-vector-insert：中间插入" class="headerlink" title="3. vector_insert：中间插入"></a>3. <code>vector_insert</code>：中间插入</h2><p>中间插入需将指定位置后的元素后移，为新元素腾出空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void vector_insert(Vector *v, int idx, ElemType val) &#123;</span><br><span class="line">    if (v-&gt;size == v-&gt;capacity) vector_resize(v);  // 扩容检查</span><br><span class="line">    for (int i = v-&gt;size; i &gt; idx; i--) &#123;  // 元素后移（从idx到末尾）</span><br><span class="line">        v-&gt;table[i] = v-&gt;table[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    v-&gt;table[idx] = val;  // 在idx位置写入元素</span><br><span class="line">    v-&gt;size++;            // 元素数量+1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>时间复杂度O(n)（n为当前元素数量），因需移动<code>size - idx</code>个元素；</li><li><code>idx</code>需满足<code>0 ≤ idx ≤ size</code>（若<code>idx &gt; size</code>则越界，需额外检查）。</li></ul><h2 id="4-vector-print：遍历打印"><a href="#4-vector-print：遍历打印" class="headerlink" title="4. vector_print：遍历打印"></a>4. <code>vector_print</code>：遍历打印</h2><p>打印函数遍历<code>table</code>数组，输出所有有效元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void vector_print(Vector *v) &#123;</span><br><span class="line">    for (int i = 0; i &lt; v-&gt;size; i++) &#123;</span><br><span class="line">        printf(&quot;%d\t&quot;, v-&gt;table[i]);  // 输出元素值（假设ElemType为int）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>扩展</strong>：若<code>ElemType</code>为其他类型（如字符串），需修改打印逻辑（如使用<code>%s</code>格式符）。</p><hr><h1 id="主函数测试：验证功能正确性"><a href="#主函数测试：验证功能正确性" class="headerlink" title="主函数测试：验证功能正确性"></a>主函数测试：验证功能正确性</h1><p>用户提供的主函数测试了尾部插入、头部插入、中间插入和打印功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int main(void) &#123;</span><br><span class="line">    Vector *vec = create_Vector();</span><br><span class="line"></span><br><span class="line">    // 测试尾部插入（1-15）</span><br><span class="line">    printf(&quot;尾部插入 1-15...\n&quot;);</span><br><span class="line">    for (int i = 1; i &lt;= 15; i++) &#123;</span><br><span class="line">        vector_push_back(vec, i);</span><br><span class="line">    &#125;</span><br><span class="line">    vector_print(vec);</span><br><span class="line"></span><br><span class="line">    // 测试头部插入（0）</span><br><span class="line">    printf(&quot;\n头部插入element 0...\n&quot;);</span><br><span class="line">    vector_push_front(vec, 0);</span><br><span class="line">    vector_print(vec);</span><br><span class="line"></span><br><span class="line">    // 测试中间插入（100 at index 3）</span><br><span class="line">    printf(&quot;\n特定位置插入 100 at index 3...\n&quot;);</span><br><span class="line">    vector_insert(vec, 3, 100);</span><br><span class="line">    vector_print(vec);</span><br><span class="line"></span><br><span class="line">    vector_destroy(vec);  // 释放内存</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预期输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">尾部插入 1-5...</span><br><span class="line">1       2       3       4       5       ...       15</span><br><span class="line"></span><br><span class="line">头部插入element 0...</span><br><span class="line">0       1       2       3       4       ...       15</span><br><span class="line"></span><br><span class="line">特定位置插入 100 at index 3...</span><br><span class="line">0       1       2       100     3       4       ...       15</span><br></pre></td></tr></table></figure><hr><h1 id="潜在问题与改进建议"><a href="#潜在问题与改进建议" class="headerlink" title="潜在问题与改进建议"></a>潜在问题与改进建议</h1><h2 id="问题1：内存泄漏风险"><a href="#问题1：内存泄漏风险" class="headerlink" title="问题1：内存泄漏风险"></a>问题1：内存泄漏风险</h2><p>当前代码中，若<code>vector_destroy</code>未被调用（如程序异常退出），<code>table</code>和<code>v</code>的内存将无法释放。建议读者复现的时候：</p><ul><li>在主函数中使用<code>atexit</code>注册销毁函数，确保程序退出时自动释放；</li><li>或使用智能指针（需结合C++，但C语言可通过自定义管理逻辑模拟）。</li></ul><h2 id="问题2：错误处理不完善"><a href="#问题2：错误处理不完善" class="headerlink" title="问题2：错误处理不完善"></a>问题2：错误处理不完善</h2><p><code>create_Vector</code>和<code>vector_resize</code>中仅输出错误信息，未向上传递错误状态。建议读者复现的时候：</p><ul><li>修改函数返回值为<code>bool</code>或错误码（如<code>-1</code>表示失败）；</li><li>调用者根据返回值决定是否继续执行（如<code>if (!create_Vector()) &#123; /* 处理错误 */ &#125;</code>）。</li></ul><h2 id="问题3：插入操作的边界检查缺失"><a href="#问题3：插入操作的边界检查缺失" class="headerlink" title="问题3：插入操作的边界检查缺失"></a>问题3：插入操作的边界检查缺失</h2><p><code>vector_insert</code>未检查<code>idx</code>是否越界（如<code>idx &lt; 0</code>或<code>idx &gt; size</code>）。建议读者复现的时候添加边界检查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void vector_insert(Vector *v, int idx, ElemType val) &#123;</span><br><span class="line">    if (idx &lt; 0 || idx &gt; v-&gt;size) &#123;  // 允许idx等于size（插入到末尾）</span><br><span class="line">        printf(&quot;Invalid index: %d\n&quot;, idx);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题4：扩容策略可优化"><a href="#问题4：扩容策略可优化" class="headerlink" title="问题4：扩容策略可优化"></a>问题4：扩容策略可优化</h2><p>当前扩容策略为二倍递增，适用于大多数场景，但在元素数量较少时可能导致内存浪费。建议：</p><ul><li>对于小容量数组（如<code>size &lt; 100</code>），采用1.5倍扩容；</li><li>对于大容量数组，保持二倍扩容以降低内存碎片。</li></ul><hr><h1 id="总结：动态数组的价值与应用场景"><a href="#总结：动态数组的价值与应用场景" class="headerlink" title="总结：动态数组的价值与应用场景"></a>总结：动态数组的价值与应用场景</h1><p>动态数组（Vector）通过堆内存分配和自动扩容机制，提供了比静态数组更灵活的操作能力。它适用于以下场景：</p><ul><li>数据量不确定（如用户输入的动态数据）；</li><li>需要频繁在尾部&#x2F;头部&#x2F;中间插入元素（如日志记录、任务队列）；</li><li>对内存利用率要求较高（避免静态数组的空间浪费）。</li></ul><p>通过本文的解析，我们不仅掌握了Vector的核心实现逻辑，更理解了动态内存管理的关键细节（如<code>malloc</code>&#x2F;<code>realloc</code>&#x2F;<code>free</code>的使用）。在实际开发中，可根据需求扩展Vector的功能（如删除元素、查找元素、排序等），或结合其他数据结构（如链表）优化性能。</p><hr><h1 id="完整源代码"><a href="#完整源代码" class="headerlink" title="完整源代码"></a>完整源代码</h1><h2 id="头文件-Vector-h"><a href="#头文件-Vector-h" class="headerlink" title="头文件 Vector.h"></a>头文件 Vector.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#ifndef VECTOR_H</span><br><span class="line">#define VECTOR_H</span><br><span class="line">#define DEFAULT_CAPACITY 10</span><br><span class="line">typedef int ElemType;  // 元素类型别名，可修改为其他类型</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    ElemType *table;   // 存储元素的堆内存指针</span><br><span class="line">    int  size;         // 当前元素个数</span><br><span class="line">    int  capacity;     // 数组总容量</span><br><span class="line">&#125; Vector;</span><br><span class="line"></span><br><span class="line">// 函数声明</span><br><span class="line">Vector *create_Vector(void);</span><br><span class="line">void vector_destroy(Vector *v);</span><br><span class="line">void vector_push_back(Vector *v, ElemType val);</span><br><span class="line">void vector_push_front(Vector *v, ElemType val);</span><br><span class="line">void vector_insert(Vector *v, int idx, ElemType val);</span><br><span class="line">void vector_print(Vector *v);</span><br><span class="line"></span><br><span class="line">#endif // !VECTOR_H</span><br></pre></td></tr></table></figure><h2 id="源文件-main-c"><a href="#源文件-main-c" class="headerlink" title="源文件 main.c"></a>源文件 main.c</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;Vector.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">Vector *vec = create_Vector();</span><br><span class="line">// 测试尾部插入功能</span><br><span class="line">printf(&quot;尾部插入 1-5...\n&quot;);</span><br><span class="line">for (int i = 1; i &lt;= 15; i++) &#123;</span><br><span class="line">vector_push_back(vec, i);</span><br><span class="line">&#125;</span><br><span class="line">vector_print(vec);</span><br><span class="line">// 测试头部插入功能</span><br><span class="line">printf(&quot;\n头部插入element 0...\n&quot;);</span><br><span class="line">vector_push_front(vec, 0);</span><br><span class="line">vector_print(vec);</span><br><span class="line">// 测试中间插入功能</span><br><span class="line">printf(&quot;\n特定位置插入 100 at index 3...\n&quot;);</span><br><span class="line">vector_insert(vec, 3, 100);</span><br><span class="line">vector_print(vec);</span><br><span class="line">// 销毁Vector，释放内存</span><br><span class="line">vector_destroy(vec);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源文件-Vector-c"><a href="#源文件-Vector-c" class="headerlink" title="源文件 Vector.c"></a>源文件 Vector.c</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Vector.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line"></span><br><span class="line">// 在C语言中,static修饰函数表示此函数仅在当前文件内部生效</span><br><span class="line">static void vector_resize(Vector *v) &#123;</span><br><span class="line">ElemType *p2 = realloc(v-&gt;table, v-&gt;capacity * 2 * sizeof(ElemType));</span><br><span class="line">//用到这个函数就代表需要扩容了，考虑二倍递增（此处应该有一个阈值，超过后改变递增倍数）</span><br><span class="line">if (p2 == NULL)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;ralloc failed in vector_resize vec-&gt;table &quot;);</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line">//判断realloc是否成功</span><br><span class="line">v-&gt;table = p2;</span><br><span class="line">v-&gt;capacity *= 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 初始化一个Vector动态数组</span><br><span class="line">Vector *create_Vector() &#123;</span><br><span class="line">Vector *vec = (Vector *)malloc(sizeof(Vector));</span><br><span class="line">if (vec == NULL) &#123;</span><br><span class="line">printf(&quot;malloc failed in create_Vector&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//申请内存</span><br><span class="line">vec-&gt;table = malloc(DEFAULT_CAPACITY * sizeof(ElemType));//10*ElemType 大小尺寸的数组 DEFAULT_CAPACITY 宏定义</span><br><span class="line">if (vec-&gt;table == NULL)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;malloc failed in create_Vector vec-&gt;table &quot;);</span><br><span class="line">free(vec);</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line">vec-&gt;size = 0;       // 初始无元素</span><br><span class="line">vec-&gt;capacity = DEFAULT_CAPACITY;</span><br><span class="line">return vec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 销毁一个Vector动态数组，释放内存。这实际上模拟了C++的析构函数</span><br><span class="line">void vector_destroy(Vector *v)</span><br><span class="line">&#123;</span><br><span class="line">free(v-&gt;table);//先释放</span><br><span class="line">free(v);//后释放</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 向动态数组末尾添加一个元素</span><br><span class="line">void vector_push_back(Vector *v, ElemType element)</span><br><span class="line">&#123;</span><br><span class="line">if (v-&gt;size == v-&gt;capacity) &#123;</span><br><span class="line">vector_resize(v);</span><br><span class="line">&#125;//判断是否需要扩容</span><br><span class="line">v-&gt;table[v-&gt;size] = element;</span><br><span class="line">v-&gt;size++;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在动态数组最前面添加元素，所有元素依次后移</span><br><span class="line">void vector_push_front(Vector *v, ElemType val)</span><br><span class="line">&#123;</span><br><span class="line">if (v-&gt;size == v-&gt;capacity) &#123;</span><br><span class="line">vector_resize(v);</span><br><span class="line">&#125;//判断是否需要扩容</span><br><span class="line">for (int i = v-&gt;size; i &gt; 0; i--)</span><br><span class="line">&#123;</span><br><span class="line">v-&gt;table[i] = v-&gt;table[i - 1];</span><br><span class="line">&#125;</span><br><span class="line">v-&gt;table[0] = val;</span><br><span class="line">v-&gt;size++;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将元素val添加到索引为idx的位置，idx后面的元素依次后移</span><br><span class="line">void vector_insert(Vector *v, int idx, ElemType val)</span><br><span class="line">&#123;</span><br><span class="line">if (v-&gt;size == v-&gt;capacity) &#123;</span><br><span class="line">vector_resize(v);</span><br><span class="line">&#125;//判断是否需要扩容</span><br><span class="line"></span><br><span class="line">for (int i = v-&gt;size; i &gt; idx; i--)</span><br><span class="line">&#123;</span><br><span class="line">v-&gt;table[i] = v-&gt;table[i - 1];</span><br><span class="line">&#125;</span><br><span class="line">v-&gt;table[idx] = val;</span><br><span class="line">v-&gt;size++;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历打印整个Vector动态数组</span><br><span class="line">void vector_print(Vector *v)</span><br><span class="line">&#123;</span><br><span class="line">for (int i = 0; i &lt; v-&gt;size; i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d\t&quot;, v-&gt;table[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C-Code </category>
          
          <category> Foundational Syntax and Core Concepts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> Vector </tag>
            
            <tag> 动态数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言位运算</title>
      <link href="/posts/8f9a0b1c/"/>
      <url>/posts/8f9a0b1c/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/6.png" alt="C语言位运算" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><h1 id="引言：为什么需要掌握位运算？"><a href="#引言：为什么需要掌握位运算？" class="headerlink" title="引言：为什么需要掌握位运算？"></a>引言：为什么需要掌握位运算？</h1><p>在计算机底层，所有的数据都以二进制形式存储和处理。位运算（Bitwise Operations）作为直接操作二进制位的工具，是高性能计算、嵌入式开发、算法优化的核心技能。今天我们将通过一个实际案例，深入理解**与（&amp;）、或（|）、异或（^）、取反（~）、移位（&lt;&lt;、&gt;&gt;）**等位运算的应用场景，并实现一组实用的位操作函数。</p><hr><h1 id="位运算基础：二进制视角下的数字"><a href="#位运算基础：二进制视角下的数字" class="headerlink" title="位运算基础：二进制视角下的数字"></a>位运算基础：二进制视角下的数字</h1><p>要掌握位运算，首先需要理解二进制数的表示规则：</p><ul><li><strong>最低有效位（LSB）</strong>：二进制数的最右边一位（2⁰位），决定数的奇偶性；</li><li><strong>高位</strong>：从右往左依次为2¹、2²...2ⁿ位，每一位代表2的幂次；</li><li><strong>补码表示</strong>：负数在内存中以补码形式存储（原码取反+1），这是位运算处理负数的关键。</li></ul><hr><h1 id="实战函数解析：逐个击破位运算问题"><a href="#实战函数解析：逐个击破位运算问题" class="headerlink" title="实战函数解析：逐个击破位运算问题"></a>实战函数解析：逐个击破位运算问题</h1><h2 id="1-判断奇数：最低位的「1」密码"><a href="#1-判断奇数：最低位的「1」密码" class="headerlink" title="1. 判断奇数：最低位的「1」密码"></a>1. 判断奇数：最低位的「1」密码</h2><p><strong>问题描述</strong>：判断一个整数是否为奇数。<br> ​<strong>​位运算思路​</strong>​：奇数的二进制最低位一定是1，偶数的最低位是0。因此，只需将数字与1（二进制000...0001）进行按位与（&amp;）操作，若结果为1则是奇数，否则是偶数。</p><p><strong>代码实现</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void is_odd(int num) &#123;</span><br><span class="line">    // 奇数的二进制最低位一定是1，用 num &amp; 1 保留最低位</span><br><span class="line">    int result = num &amp; 1;</span><br><span class="line">    printf(&quot;数字 %d 是否为奇数？%s\n&quot;, num, result ? &quot;是&quot; : &quot;否&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例验证</strong>：</p><ul><li>输入5（二进制101）：5 &amp; 1 &#x3D; 1 → 奇数；</li><li>输入6（二进制110）：6 &amp; 1 &#x3D; 0 → 偶数。</li></ul><hr><h2 id="2-判断2的幂：二进制中的「孤独1」"><a href="#2-判断2的幂：二进制中的「孤独1」" class="headerlink" title="2. 判断2的幂：二进制中的「孤独1」"></a>2. 判断2的幂：二进制中的「孤独1」</h2><p><strong>问题描述</strong>：判断一个正整数是否是2的幂（如1&#x3D;2⁰，2&#x3D;2¹，4&#x3D;2²...）。<br> ​<strong>​位运算思路​</strong>​：2的幂的二进制表示中只有一个1（如8&#x3D;1000₂），若将其减1（如8-1&#x3D;7&#x3D;0111₂），则原数与减1后的数按位与结果必为0（1000 &amp; 0111 &#x3D; 0000）。注意：0和负数不可能是2的幂。</p><p><strong>代码实现</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void is_Power_of_two(int num) &#123;</span><br><span class="line">    // 2的幂必须是正整数</span><br><span class="line">    if (num &lt;= 0) &#123;</span><br><span class="line">        printf(&quot;数字 %d 不是2的幂（需为正整数）\n&quot;, num);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 若 num 是2的幂，则 num &amp; (num - 1) 必为0（如8=1000，8-1=0111，与运算结果为0）</span><br><span class="line">    int result = (num &amp; (num - 1)) == 0;</span><br><span class="line">    printf(&quot;数字 %d 是否为2的幂？%s\n&quot;, num, result ? &quot;是&quot; : &quot;否&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例验证</strong>：</p><ul><li>输入8（1000₂）：8 &amp; 7 &#x3D; 0 → 是2的幂；</li><li>输入6（0110₂）：6 &amp; 5 &#x3D; 4 ≠ 0 → 不是。</li></ul><hr><h2 id="3-找最低有效位（LSB）：定位第一个「1」"><a href="#3-找最低有效位（LSB）：定位第一个「1」" class="headerlink" title="3. 找最低有效位（LSB）：定位第一个「1」"></a>3. 找最低有效位（LSB）：定位第一个「1」</h2><p><strong>问题描述</strong>：给定非零整数，找出其值为1的最低有效位的位置（如6&#x3D;110₂，最低有效位是第2位，对应值为2¹&#x3D;2）。<br> ​<strong>​位运算思路​</strong>​：利用补码特性，负数的补码是原码取反+1。因此，<code>num &amp; (-num)</code>会将原数中最低位的1保留，其余位清零（如6&#x3D;000...0110，-6&#x3D;111...1010，6 &amp; -6&#x3D;000...0010&#x3D;2）。</p><p><strong>代码实现</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void find_lsb(int num) &#123;</span><br><span class="line">    if (num == 0) &#123;  // 0没有有效位</span><br><span class="line">        printf(&quot;数字0没有最低有效位\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 利用补码特性：num &amp; (-num) 会保留最低位的1，其余位清零</span><br><span class="line">    int lsb_value = num &amp; (-num);</span><br><span class="line">    printf(&quot;数字 %d 的最低有效位值是：%d\n&quot;, num, lsb_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例验证</strong>：</p><ul><li>输入6（0110₂）：6 &amp; -6 &#x3D; 2（0010₂）→ 最低有效位是2；</li><li>输入12（1100₂）：12 &amp; -12 &#x3D; 4（0100₂）→ 最低有效位是4。</li></ul><hr><h2 id="4-交换数值：异或的自反魔法"><a href="#4-交换数值：异或的自反魔法" class="headerlink" title="4. 交换数值：异或的自反魔法"></a>4. 交换数值：异或的自反魔法</h2><p><strong>问题描述</strong>：不使用临时变量，交换两个整数的值。<br> ​<strong>​位运算思路​</strong>​：异或（^）满足以下性质：</p><ul><li><code>a ^ a = 0</code>（相同数异或为0）；</li><li><code>a ^ 0 = a</code>（任何数异或0不变）；</li><li>异或满足交换律和结合律。</li></ul><p>利用这些性质，可通过三次异或操作完成交换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void change(int *a, int *b) &#123;</span><br><span class="line">    if (a == b) return;  // 避免相同地址异或导致结果为0</span><br><span class="line">    *a ^= *b;  // a = a ^ b</span><br><span class="line">    *b ^= *a;  // b = (a ^ b) ^ b = a</span><br><span class="line">    *a ^= *b;  // a = (a ^ b) ^ a = b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修正说明</strong>：原代码中<code>change</code>函数参数为值传递（<code>int a, int b</code>），无法修改主函数中的变量。正确实现需使用指针（<code>int *a, int *b</code>）。</p><hr><h2 id="5-寻找唯一元素：异或的「分组」艺术"><a href="#5-寻找唯一元素：异或的「分组」艺术" class="headerlink" title="5. 寻找唯一元素：异或的「分组」艺术"></a>5. 寻找唯一元素：异或的「分组」艺术</h2><p><strong>问题描述</strong>：给定一个非空整数数组，除某个元素只出现一次外，其余元素均出现两次。找出这个唯一元素（扩展：若有两个元素各出现一次，其余出现两次，如何找出这两个元素？）。</p><h3 id="场景1：仅一个唯一元素"><a href="#场景1：仅一个唯一元素" class="headerlink" title="场景1：仅一个唯一元素"></a>场景1：仅一个唯一元素</h3><p><strong>位运算思路</strong>：利用异或性质，相同数异或结果为0，0异或任何数为自身。因此，遍历数组异或所有元素，最终结果即为唯一元素。</p><p><strong>代码实现</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int find_only(int nums[], int length) &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result ^= nums[i];  // 异或性质：相同数异或为0，0异或任何数为自身</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="场景2：两个唯一元素（扩展）"><a href="#场景2：两个唯一元素（扩展）" class="headerlink" title="场景2：两个唯一元素（扩展）"></a>场景2：两个唯一元素（扩展）</h3><p><strong>位运算思路</strong>：</p><ol><li>先异或所有元素，得到两个唯一元素的异或结果（记为<code>lsb</code>）；</li><li><code>lsb</code>的二进制中至少有一位是1（因为两数不同），找到最低位的1（即<code>lsb &amp; (-lsb)</code>）；</li><li>根据该位将数组分为两组（该位为1和该位为0），每组内的元素异或结果即为两个唯一元素。</li></ol><p><strong>代码实现</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void find_two(int nums[], int length) &#123;</span><br><span class="line">    if (length &lt; 2) &#123;</span><br><span class="line">        printf(&quot;数组长度至少为2\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 第一轮异或：得到两个唯一元素的异或结果（记为 xor_sum）</span><br><span class="line">    int xor_sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        xor_sum ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 找到 xor_sum 中最低位的1（该位是两个唯一元素不同的位）</span><br><span class="line">    int lsb = xor_sum &amp; (-xor_sum);</span><br><span class="line"></span><br><span class="line">    // 第二轮异或：按 lsb 分组异或，每组结果即为一个唯一元素</span><br><span class="line">    int a = 0, b = 0;</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        if (nums[i] &amp; lsb) &#123;  // 该位为1的元素分到组a</span><br><span class="line">            a ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;  // 该位为0的元素分到组b</span><br><span class="line">            b ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;数组中两个唯一出现的元素是：%d 和 %d\n&quot;, a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例验证</strong>：</p><ul><li>数组<code>[2, 3, 2, 4]</code>：唯一元素是3和4；<br> 第一轮异或：2^3^2^4 &#x3D; 3^4 &#x3D; 7（二进制111）；<br> lsb &#x3D; 7 &amp; (-7) &#x3D; 1（二进制001）；<br> 分组异或：3（011）在组1（lsb&#x3D;1），4（100）在组2（lsb&#x3D;0），结果a&#x3D;3，b&#x3D;4。</li></ul><hr><h1 id="注意事项与常见陷阱"><a href="#注意事项与常见陷阱" class="headerlink" title="注意事项与常见陷阱"></a>注意事项与常见陷阱</h1><ol><li><strong>指针传递的重要性</strong>：<code>change</code>函数若使用值传递无法修改原变量，必须用指针（<code>int *</code>）；</li><li><strong>负数处理</strong>：位运算中负数以补码形式存在，需注意符号位的影响（如<code>-1</code>的二进制是全1）；</li><li><strong>移位溢出</strong>：左移操作（<code>&lt;&lt;</code>）可能导致高位丢失（如<code>int</code>类型左移32位结果未定义）；</li><li><strong>边界条件</strong>：判断2的幂时需排除0和负数（如<code>num=0</code>时<code>num&amp;(num-1)</code>会引发错误）。</li></ol><hr><h1 id="总结：位运算的核心价值"><a href="#总结：位运算的核心价值" class="headerlink" title="总结：位运算的核心价值"></a>总结：位运算的核心价值</h1><p>位运算不仅是C语言的基础技能，更是理解计算机底层原理的关键。通过本文的实战案例，我们掌握了：</p><ul><li>如何用位运算快速判断奇偶、2的幂；</li><li>如何定位最低有效位；</li><li>如何用异或实现无临时变量交换；</li><li>如何用异或分组解决复杂唯一元素问题。</li></ul><p>下次遇到类似问题时，不妨尝试用二进制视角重新审视数据——位运算的简洁与高效，会让你惊叹于计算机世界的「位」妙！</p><blockquote><p>提示：实际开发中需注意位运算的可读性，避免过度优化导致代码难以维护。对于复杂场景（如大端小端处理），建议结合具体硬件架构文档进行适配。</p></blockquote><hr><h1 id="附录：完整源代码与文件说明"><a href="#附录：完整源代码与文件说明" class="headerlink" title="附录：完整源代码与文件说明"></a>附录：完整源代码与文件说明</h1><p>为了方便读者复现与调试，以下是项目的完整源代码，并附各文件功能说明。</p><hr><h2 id="1-function-h-——-头文件（函数声明与宏定义）"><a href="#1-function-h-——-头文件（函数声明与宏定义）" class="headerlink" title="1. function.h —— 头文件（函数声明与宏定义）"></a>1. <code>function.h</code> —— 头文件（函数声明与宏定义）</h2><p><strong>文件作用</strong>：<br> 声明需要实现的位运算函数，以及必要的宏定义（如防止头文件重复包含）。头文件是C语言中实现模块化编程的关键，通过<code>#include</code>指令被其他源文件引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#ifndef FUNCTION_H  // 防止头文件重复包含</span><br><span class="line">#define FUNCTION_H</span><br><span class="line"></span><br><span class="line">// 函数声明：判断整数是否为奇数</span><br><span class="line">void is_odd(int num);</span><br><span class="line"></span><br><span class="line">// 函数声明：判断是否为2的幂</span><br><span class="line">void is_Power_of_two(int num);</span><br><span class="line"></span><br><span class="line">// 函数声明：查找最低有效位（Last Set Bit）</span><br><span class="line">void find_lsb(int num);</span><br><span class="line"></span><br><span class="line">// 函数声明：交换两个整数的值（异或实现）</span><br><span class="line">void change(int *a, int *b);  // 注意：必须用指针传递才能修改原变量</span><br><span class="line"></span><br><span class="line">// 函数声明：查找数组中唯一出现一次的元素（其余出现两次）</span><br><span class="line">int find_only(int nums[], int length);</span><br><span class="line"></span><br><span class="line">// 函数声明：查找数组中两个唯一出现一次的元素（其余出现两次）</span><br><span class="line">void find_two(int nums[], int length);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><hr><h2 id="2-function-c-——-源文件（函数实现）"><a href="#2-function-c-——-源文件（函数实现）" class="headerlink" title="2. function.c —— 源文件（函数实现）"></a>2. <code>function.c</code> —— 源文件（函数实现）</h2><p><strong>文件作用</strong>：<br> 实现<code>function.h</code>中声明的所有位运算函数。将函数实现与声明分离，符合C语言的模块化编程规范，便于维护与代码复用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;function.h&quot;</span><br><span class="line"></span><br><span class="line">// 函数实现：判断整数是否为奇数（最低位是否为1）</span><br><span class="line">void is_odd(int num) &#123;</span><br><span class="line">    // 奇数的二进制最低位一定是1，用 num &amp; 1 保留最低位</span><br><span class="line">    int result = num &amp; 1;</span><br><span class="line">    printf(&quot;数字 %d 是否为奇数？%s&quot;, num, result ? &quot;是&quot; : &quot;否&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数实现：判断是否为2的幂（二进制仅有一个1）</span><br><span class="line">void is_Power_of_two(int num) &#123;</span><br><span class="line">// 2的幂必须是正整数</span><br><span class="line">    if (num &lt;= 0) &#123;  </span><br><span class="line">        printf(&quot;数字 %d 不是2的幂（需为正整数）&quot;, num);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 若 num 是2的幂，则 num &amp; (num - 1) 必为0（如8=1000，8-1=0111，与运算结果为0）</span><br><span class="line">    int result = (num &amp; (num - 1)) == 0;</span><br><span class="line">    printf(&quot;数字 %d 是否为2的幂？%s&quot;, num, result ? &quot;是&quot; : &quot;否&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数实现：查找最低有效位（Last Set Bit）</span><br><span class="line">void find_lsb(int num) &#123;</span><br><span class="line">    if (num == 0) &#123;  // 0没有有效位</span><br><span class="line">        printf(&quot;数字0没有最低有效位&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 利用补码特性：num &amp; (-num) 会保留最低位的1，其余位清零</span><br><span class="line">    int lsb_value = num &amp; (-num);</span><br><span class="line">    printf(&quot;数字 %d 的最低有效位值是：%d（对应2^%d位）&quot;, num, lsb_value, __builtin_ctz(lsb_value));  </span><br><span class="line">// __builtin_ctz计算末尾0的个数（GCC内置函数）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数实现：交换两个整数的值（异或无临时变量版）</span><br><span class="line">void change(int *a, int *b) &#123;</span><br><span class="line">    if (a == b) return;  // 避免相同地址异或导致结果为0</span><br><span class="line">    *a ^= *b;  // a = a ^ b</span><br><span class="line">    *b ^= *a;  // b = (a ^ b) ^ b = a</span><br><span class="line">    *a ^= *b;  // a = (a ^ b) ^ a = b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数实现：查找数组中唯一出现一次的元素（其余出现两次）</span><br><span class="line">int find_only(int nums[], int length) &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result ^= nums[i];  // 异或性质：相同数异或为0，0异或任何数为自身</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数实现：查找数组中两个唯一出现一次的元素（其余出现两次）</span><br><span class="line">void find_two(int nums[], int length) &#123;</span><br><span class="line">    if (length &lt; 2) &#123;</span><br><span class="line">    printf(&quot;数组长度至少为2&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 第一轮异或：得到两个唯一元素的异或结果（记为 xor_sum）</span><br><span class="line">    int xor_sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        xor_sum ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 找到 xor_sum 中最低位的1（该位是两个唯一元素不同的位）</span><br><span class="line">    int lsb = xor_sum &amp; (-xor_sum);</span><br><span class="line"></span><br><span class="line">    // 第二轮异或：按 lsb 分组异或，每组结果即为一个唯一元素</span><br><span class="line">    int a = 0, b = 0;</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        if (nums[i] &amp; lsb) &#123;  // 该位为1的元素分到组a</span><br><span class="line">            a ^= nums[i];</span><br><span class="line">        &#125; else &#123;  // 该位为0的元素分到组b</span><br><span class="line">            b ^= nums[i];#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;function.h&quot;</span><br><span class="line"></span><br><span class="line">// 函数实现：判断整数是否为奇数（最低位是否为1）</span><br><span class="line">void is_odd(int num) &#123;</span><br><span class="line">    // 奇数的二进制最低位一定是1，用 num &amp; 1 保留最低位</span><br><span class="line">    int result = num &amp; 1;</span><br><span class="line">    printf(&quot;数字 %d 是否为奇数？%s\n&quot;, num, result ? &quot;是&quot; : &quot;否&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数实现：判断是否为2的幂（二进制仅有一个1）</span><br><span class="line">void is_Power_of_two(int num) &#123;</span><br><span class="line">    // 2的幂必须是正整数</span><br><span class="line">    if (num &lt;= 0) &#123;</span><br><span class="line">        printf(&quot;数字 %d 不是2的幂（需为正整数）\n&quot;, num);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 若 num 是2的幂，则 num &amp; (num - 1) 必为0（如8=1000，8-1=0111，与运算结果为0）</span><br><span class="line">    int result = (num &amp; (num - 1)) == 0;</span><br><span class="line">    printf(&quot;数字 %d 是否为2的幂？%s\n&quot;, num, result ? &quot;是&quot; : &quot;否&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数实现：查找最低有效位（Last Set Bit）</span><br><span class="line">void find_lsb(int num) &#123;</span><br><span class="line">    if (num == 0) &#123;  // 0没有有效位</span><br><span class="line">        printf(&quot;数字0没有最低有效位\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 利用补码特性：num &amp; (-num) 会保留最低位的1，其余位清零</span><br><span class="line">    int lsb_value = num &amp; (-num);</span><br><span class="line">    printf(&quot;数字 %d 的最低有效位值是：%d\n&quot;, num, lsb_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数实现：交换两个整数的值（异或无临时变量版）</span><br><span class="line">void change(int *a, int *b) &#123;</span><br><span class="line">    if (a == b) return;  // 避免相同地址异或导致结果为0</span><br><span class="line">    *a ^= *b;  // a = a ^ b</span><br><span class="line">    *b ^= *a;  // b = (a ^ b) ^ b = a</span><br><span class="line">    *a ^= *b;  // a = (a ^ b) ^ a = b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数实现：查找数组中唯一出现一次的元素（其余出现两次）</span><br><span class="line">int find_only(int nums[], int length) &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result ^= nums[i];  // 异或性质：相同数异或为0，0异或任何数为自身</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数实现：查找数组中两个唯一出现一次的元素（其余出现两次）</span><br><span class="line">void find_two(int nums[], int length) &#123;</span><br><span class="line">    if (length &lt; 2) &#123;</span><br><span class="line">        printf(&quot;数组长度至少为2\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 第一轮异或：得到两个唯一元素的异或结果（记为 xor_sum）</span><br><span class="line">    int xor_sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        xor_sum ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 找到 xor_sum 中最低位的1（该位是两个唯一元素不同的位）</span><br><span class="line">    int lsb = xor_sum &amp; (-xor_sum);</span><br><span class="line"></span><br><span class="line">    // 第二轮异或：按 lsb 分组异或，每组结果即为一个唯一元素</span><br><span class="line">    int a = 0, b = 0;</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        if (nums[i] &amp; lsb) &#123;  // 该位为1的元素分到组a</span><br><span class="line">            a ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;  // 该位为0的元素分到组b</span><br><span class="line">            b ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;数组中两个唯一出现的元素是：%d 和 %d\n&quot;, a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-main-c-——-主程序入口"><a href="#3-main-c-——-主程序入口" class="headerlink" title="3. main.c —— 主程序入口"></a>3. <code>main.c</code> —— 主程序入口</h2><p><strong>文件作用</strong>：<br> 程序的入口函数（<code>main</code>函数），负责调用<code>function.c</code>中实现的位运算函数，完成测试逻辑。用户通过<code>main</code>函数输入数据，触发各个位运算功能的演示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS  // 关闭VS编译器的安全警告（如scanf）</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;function.h&quot;  // 包含函数声明</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    int num = 0;</span><br><span class="line">    printf(&quot;请输入你要查询的整数：\n&quot;);</span><br><span class="line">        scanf(&quot; %d&quot;, &amp;num);</span><br><span class="line">    // 输入整数（注意空格跳过换行符）</span><br><span class="line"></span><br><span class="line">    // 测试单个数字的位运算功能</span><br><span class="line">    is_odd(num);          // 判断奇偶</span><br><span class="line">    is_Power_of_two(num); // 判断是否为2的幂</span><br><span class="line">    find_lsb(num);        // 查找最低有效位</span><br><span class="line"></span><br><span class="line">    // 测试数组的唯一元素查找功能（示例数组）</span><br><span class="line">    int test_array[] = &#123; 2, 3, 2, 4, 5, 5, 3, 6 &#125;;</span><br><span class="line">    // 示例数组：2、4、6各出现一次，其余出现两次</span><br><span class="line">    int array_length = sizeof(test_array) / sizeof(test_array[0]);</span><br><span class="line">    // 计算数组长度</span><br><span class="line"></span><br><span class="line">    printf(&quot;--- 数组唯一元素测试 ---\n&quot;);</span><br><span class="line">    find_two(test_array, array_length);</span><br><span class="line">    // 查找两个唯一元素（本例中是4和6）</span><br><span class="line"></span><br><span class="line">    // 测试交换函数（可选）</span><br><span class="line">    int a = 10, b = 20;</span><br><span class="line">    printf(&quot;交换前：a=%d, b=%d\n&quot;, a, b);</span><br><span class="line">    change(&amp;a, &amp;b);  // 传递指针以修改原变量</span><br><span class="line">    printf(&quot;交换后：a=%d, b=%d\n&quot;, a, b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码，读者可直接运行并验证位运算的实战效果，加深对二进制操作的理解。</p>]]></content>
      
      
      <categories>
          
          <category> C-Code </category>
          
          <category> Foundational Syntax and Core Concepts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 算法优化 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现简易书籍管理系统</title>
      <link href="/posts/12989e68/"/>
      <url>/posts/12989e68/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/4.png" alt="C语言实现简易书籍管理系统" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><h1 id="一、引言：为什么需要书籍管理系统？"><a href="#一、引言：为什么需要书籍管理系统？" class="headerlink" title="一、引言：为什么需要书籍管理系统？"></a>一、引言：为什么需要书籍管理系统？</h1><p>在日常生活中，我们常常需要整理自己的书籍收藏：可能是个人阅读清单、家庭藏书目录，或是小型图书馆的管理需求。手动记录书籍信息（如书名、作者、类别）容易出错，且查询效率低下。今天，我们将用C语言实现一个<strong>简易书籍管理系统</strong>，通过结构化的数据存储和友好的用户交互，解决这一痛点。</p><p>这个系统将实现以下核心功能：</p><ul><li>存储书籍的基础信息（编号、书名、作者、类别）；</li><li>按类别快速筛选书籍；</li><li>清晰展示所有书籍信息；</li><li>提供用户友好的交互界面。</li></ul><p>通过这个项目，你将掌握C语言中枚举、结构体、函数封装、用户输入处理等核心技术的实际应用。</p><hr><h1 id="二、核心数据结构：用枚举和结构体组织信息"><a href="#二、核心数据结构：用枚举和结构体组织信息" class="headerlink" title="二、核心数据结构：用枚举和结构体组织信息"></a>二、核心数据结构：用枚举和结构体组织信息</h1><h2 id="1-1-枚举类型：定义书籍类别"><a href="#1-1-枚举类型：定义书籍类别" class="headerlink" title="1.1 枚举类型：定义书籍类别"></a>1.1 枚举类型：定义书籍类别</h2><p>书籍的类别是固定的（如科幻、文学、历史等），使用枚举（<code>enum</code>）可以避免魔法数字，提高代码可读性。在头文件<code>function.h</code>中定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef enum Genre &#123;</span><br><span class="line">    SCIENCE_FICTION = 0,  // 科幻</span><br><span class="line">    LITERATURE = 1,       // 文学</span><br><span class="line">    HISTORY = 2,          // 历史</span><br><span class="line">    TECHNOLOGY = 3,       // 科技</span><br><span class="line">    OTHER = 4             // 其他</span><br><span class="line">&#125; Genre;</span><br></pre></td></tr></table></figure><h2 id="1-2-结构体：封装书籍信息"><a href="#1-2-结构体：封装书籍信息" class="headerlink" title="1.2 结构体：封装书籍信息"></a>1.2 结构体：封装书籍信息</h2><p>每本书的信息可以封装为一个结构体（<code>struct</code>），将相关数据绑定在一起。结构体<code>Book</code>包含编号、书名、作者和类别四个字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Book &#123;</span><br><span class="line">    int num;              // 编号（唯一标识）</span><br><span class="line">    char name[15];        // 书名（最多14字符+终止符）</span><br><span class="line">    char author[20];      // 作者（最多19字符+终止符）</span><br><span class="line">    Genre genre;          // 类别（使用枚举类型）</span><br><span class="line">&#125; Book;</span><br></pre></td></tr></table></figure><h2 id="1-3-初始化书籍数组"><a href="#1-3-初始化书籍数组" class="headerlink" title="1.3 初始化书籍数组"></a>1.3 初始化书籍数组</h2><p>为了演示功能，我们在源文件<code>main.c</code>中预先初始化一个包含10本书的数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Book books[MAX_BOOKS] = &#123;</span><br><span class="line">    &#123;1, &quot;三体&quot;, &quot;刘慈欣&quot;, SCIENCE_FICTION&#125;,</span><br><span class="line">    &#123;2, &quot;红楼梦&quot;, &quot;曹雪芹&quot;, LITERATURE&#125;,</span><br><span class="line">    &#123;3, &quot;中国通史&quot;, &quot;吕思勉&quot;, HISTORY&#125;,</span><br><span class="line">    &#123;4, &quot;时间简史&quot;, &quot;史蒂芬_霍金&quot;, TECHNOLOGY&#125;,</span><br><span class="line">    &#123;5, &quot;围城&quot;, &quot;钱钟书&quot;, LITERATURE&#125;,</span><br><span class="line">    &#123;6, &quot;傲慢与偏见&quot;, &quot;简_奥斯汀&quot;, LITERATURE&#125;,</span><br><span class="line">    &#123;7, &quot;呼啸山庄&quot;, &quot;艾米莉_勃朗特&quot;, LITERATURE&#125;,</span><br><span class="line">    &#123;8, &quot;活着&quot;, &quot;余华&quot;, LITERATURE&#125;,</span><br><span class="line">    &#123;9, &quot;明朝那些事儿&quot;, &quot;当年明月&quot;, HISTORY&#125;,</span><br><span class="line">    &#123;10, &quot;乌合之众&quot;, &quot;古斯塔夫_勒庞&quot;, OTHER&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="三、功能实现：从数据打印到类别筛选"><a href="#三、功能实现：从数据打印到类别筛选" class="headerlink" title="三、功能实现：从数据打印到类别筛选"></a>三、功能实现：从数据打印到类别筛选</h1><h2 id="3-1-函数1：Genre-Zn——枚举转中文"><a href="#3-1-函数1：Genre-Zn——枚举转中文" class="headerlink" title="3.1 函数1：Genre_Zn——枚举转中文"></a>3.1 函数1：<code>Genre_Zn</code>——枚举转中文</h2><p>枚举值（如<code>SCIENCE_FICTION</code>）是数字，直接打印不直观。通过<code>switch</code>语句将其转换为中文字符串，增强可读性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const char *Genre_Zn(Genre i) &#123;</span><br><span class="line">    switch (i) &#123;</span><br><span class="line">        case SCIENCE_FICTION: return &quot;科幻&quot;;</span><br><span class="line">        case LITERATURE:         return &quot;文学&quot;;</span><br><span class="line">        case HISTORY:          return &quot;历史&quot;;</span><br><span class="line">        case TECHNOLOGY:          return &quot;科技&quot;;</span><br><span class="line">        case OTHER:          return &quot;其他&quot;;</span><br><span class="line">        default:              return &quot;未知&quot;;  // 处理非法输入</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-函数2：print-book-info——打印所有书籍信息"><a href="#3-2-函数2：print-book-info——打印所有书籍信息" class="headerlink" title="3.2 函数2：print_book_info——打印所有书籍信息"></a>3.2 函数2：<code>print_book_info</code>——打印所有书籍信息</h2><p>该函数遍历书籍数组，按固定格式打印每本书的详细信息。为了美观，使用分隔线增强可读性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void print_book_info(Book *books, int count) &#123;</span><br><span class="line">    // 打印分隔线（21个&quot;-&quot;）</span><br><span class="line">    for (int i = 0; i &lt; 21; i++) printf(&quot;-&quot;);</span><br><span class="line">    printf(&quot; 所有的书籍信息 &quot;);</span><br><span class="line">    for (int i = 0; i &lt; 21; i++) printf(&quot;-&quot;);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 遍历并打印每本书</span><br><span class="line">    for (int i = 0; i &lt; MAX_BOOKS; i++) &#123;</span><br><span class="line">        printf(&quot;编号:%-2d  书名:%-12s  作者:%-13s   类别:%-8s\n&quot;,books[i].num, books[i].name,books[i].author,Genre_Zn(books[i].genre));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-函数3：find-books-by-genre——按类别筛选书籍"><a href="#3-3-函数3：find-books-by-genre——按类别筛选书籍" class="headerlink" title="3.3 函数3：find_books_by_genre——按类别筛选书籍"></a>3.3 函数3：<code>find_books_by_genre</code>——按类别筛选书籍</h2><p>用户输入类别编号后，该函数遍历数组，只打印符合条件的书籍：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void find_books_by_genre(Book *books, int count, Genre genre) &#123;</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        if (books[i].genre == genre) &#123;</span><br><span class="line">            printf(&quot;编号:%-2d  书名:%-12s  作者:%-13s   类别:%-8s\n&quot;,books[i].num, books[i].name,books[i].author,Genre_Zn(books[i].genre));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="四、主函数：用户交互流程"><a href="#四、主函数：用户交互流程" class="headerlink" title="四、主函数：用户交互流程"></a>四、主函数：用户交互流程</h1><p>主函数负责调用上述函数，提供交互界面。用户可以查看所有书籍，或按类别筛选书籍，输入<code>5</code>退出程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main(void) &#123;</span><br><span class="line">    // 打印所有书籍信息</span><br><span class="line">    print_book_info(books, MAX_BOOKS);</span><br><span class="line"></span><br><span class="line">    // 用户按类别查询循环</span><br><span class="line">    Genre gen;</span><br><span class="line">    do &#123;</span><br><span class="line">        printf(&quot;\n请输入书籍类别编号（0:科幻 1.文学 2.历史 3.科技 4.其他 5.退出）\n&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;gen);  // 读取用户输入的类别编号</span><br><span class="line">        find_books_by_genre(books, MAX_BOOKS, gen);  // 筛选并打印</span><br><span class="line">    &#125; while (gen != 5);  // 输入5时退出循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="五、测试与验证：运行效果展示"><a href="#五、测试与验证：运行效果展示" class="headerlink" title="五、测试与验证：运行效果展示"></a>五、测试与验证：运行效果展示</h1><h2 id="5-1-初始书籍列表打印"><a href="#5-1-初始书籍列表打印" class="headerlink" title="5.1 初始书籍列表打印"></a>5.1 初始书籍列表打印</h2><p>程序启动后，首先打印所有书籍的信息，输出类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--------------------- 所有的书籍信息 ---------------------</span><br><span class="line"></span><br><span class="line">编号:1  书名:三体        作者:刘慈欣       类别:科幻    </span><br><span class="line">编号:2  书名:红楼梦      作者:曹雪芹       类别:文学    </span><br><span class="line">编号:3  书名:中国通史    作者:吕思勉       类别:历史    </span><br><span class="line">编号:4  书名:时间简史    作者:史蒂芬_霍金   类别:科技    </span><br><span class="line">编号:5  书名:围城        作者:钱钟书       类别:文学    </span><br><span class="line">编号:6  书名:傲慢与偏见  作者:简_奥斯汀    类别:文学    </span><br><span class="line">编号:7  书名:呼啸山庄    作者:艾米莉_勃朗特 类别:文学    </span><br><span class="line">编号:8  书名:活着        作者:余华         类别:文学    </span><br><span class="line">编号:9  书名:明朝那些事儿  作者:当年明月     类别:历史    </span><br><span class="line">编号:10 书名:乌合之众    作者:古斯塔夫_勒庞 类别:其他    </span><br></pre></td></tr></table></figure><h2 id="5-2-按类别查询功能"><a href="#5-2-按类别查询功能" class="headerlink" title="5.2 按类别查询功能"></a>5.2 按类别查询功能</h2><p>用户输入<code>1</code>（文学），程序筛选并打印所有文学类书籍：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">编号:2  书名:红楼梦      作者:曹雪芹       类别:文学    </span><br><span class="line">编号:5  书名:围城        作者:钱钟书       类别:文学    </span><br><span class="line">编号:6  书名:傲慢与偏见  作者:简_奥斯汀    类别:文学    </span><br><span class="line">编号:7  书名:呼啸山庄    作者:艾米莉_勃朗特 类别:文学    </span><br><span class="line">编号:8  书名:活着        作者:余华         类别:文学    </span><br></pre></td></tr></table></figure><p>输入<code>5</code>后，程序退出。</p><hr><h1 id="六、潜在问题"><a href="#六、潜在问题" class="headerlink" title="六、潜在问题"></a>六、潜在问题</h1><h2 id="问题：MAX-BOOKS未定义"><a href="#问题：MAX-BOOKS未定义" class="headerlink" title="问题：MAX_BOOKS未定义"></a>问题：<code>MAX_BOOKS</code>未定义</h2><p>当前代码中<code>MAX_BOOKS</code>在<code>function.h</code>中定义为<code>10</code>，但需确保源文件<code>main.c</code>和<code>function.c</code>中一致。若书籍数量超过<code>MAX_BOOKS</code>，会导致数组越界。需要在<code>function.h</code>中明确定义，并在使用时检查边界。</p><h3 id="改进建议1：增加书籍属性"><a href="#改进建议1：增加书籍属性" class="headerlink" title="改进建议1：增加书籍属性"></a>改进建议1：增加书籍属性</h3><p>可以扩展<code>Book</code>结构体，添加出版年份、ISBN、页数等字段，丰富信息维度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Book &#123;</span><br><span class="line">    int num;              // 编号</span><br><span class="line">    char name[15];        // 书名</span><br><span class="line">    char author[20];      // 作者</span><br><span class="line">    Genre genre;          // 类别</span><br><span class="line">    int publish_year;     // 出版年份（新增）</span><br><span class="line">    char isbn[13];        // ISBN（新增）</span><br><span class="line">&#125; Book;</span><br></pre></td></tr></table></figure><h3 id="改进建议2：数据持久化"><a href="#改进建议2：数据持久化" class="headerlink" title="改进建议2：数据持久化"></a>改进建议2：数据持久化</h3><p>当前书籍数据是硬编码的，重启程序后数据丢失。可以将数据保存到文件（如<code>books.txt</code>），启动时读取，实现持久化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 示例：从文件读取书籍数据</span><br><span class="line">FILE *fp = fopen(&quot;books.txt&quot;, &quot;r&quot;);</span><br><span class="line">if (fp) &#123;</span><br><span class="line">    fscanf(fp, &quot;%d&quot;, &amp;count);  // 读取书籍数量</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        fscanf(fp, &quot;%d %s %s %d&quot;, &amp;books[i].num, books[i].name, books[i].author, &amp;books[i].genre);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改进建议3：图形化界面"><a href="#改进建议3：图形化界面" class="headerlink" title="改进建议3：图形化界面"></a>改进建议3：图形化界面</h3><p>当前交互是命令行形式，可通过<code>SDL</code>或<code>Qt</code>等库开发图形界面（GUI），提升用户体验。</p><hr><h1 id="七、总结：从代码到能力的提升"><a href="#七、总结：从代码到能力的提升" class="headerlink" title="七、总结：从代码到能力的提升"></a>七、总结：从代码到能力的提升</h1><p>通过这个简易书籍管理系统，我们实践了C语言的核心知识点：</p><ul><li><strong>枚举类型</strong>：定义固定类别，提高代码可读性；</li><li><strong>结构体</strong>：封装复杂数据，组织信息更清晰；</li><li><strong>函数封装</strong>：将功能拆分为独立函数，提升代码复用性；</li><li><strong>用户交互</strong>：处理输入输出，实现基础的CLI（命令行界面）。</li></ul><p>这些经验是后续开发更复杂系统（如学生管理系统、库存管理系统）的基础。不妨尝试扩展本文的功能（如添加书籍、删除书籍），在实践中进一步提升编程能力！</p><hr><h1 id="八、完整源代码"><a href="#八、完整源代码" class="headerlink" title="八、完整源代码"></a>八、完整源代码</h1><h2 id="头文件-function-h"><a href="#头文件-function-h" class="headerlink" title="头文件 function.h"></a>头文件 function.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#ifndef FUNCTION_H</span><br><span class="line">#define FUNCTION_H</span><br><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#define MAX_BOOKS 10</span><br><span class="line"></span><br><span class="line">typedef enum Genre &#123;</span><br><span class="line">    SCIENCE_FICTION = 0,</span><br><span class="line">    LITERATURE = 1,</span><br><span class="line">    HISTORY = 2,</span><br><span class="line">    TECHNOLOGY = 3,</span><br><span class="line">    OTHER = 4</span><br><span class="line">&#125; Genre;</span><br><span class="line"></span><br><span class="line">typedef struct Book &#123;</span><br><span class="line">    int num;</span><br><span class="line">    char name[15];</span><br><span class="line">    char author[20];</span><br><span class="line">    Genre genre;</span><br><span class="line">&#125; Book;</span><br><span class="line"></span><br><span class="line">const char *Genre_Zn(Genre i);</span><br><span class="line">void print_book_info(Book *books, int count);</span><br><span class="line">void find_books_by_genre(Book *books, int count, Genre genre);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h2 id="源文件-main-c"><a href="#源文件-main-c" class="headerlink" title="源文件 main.c"></a>源文件 main.c</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &quot;function.h&quot;</span><br><span class="line"></span><br><span class="line">Book books[MAX_BOOKS] = &#123;</span><br><span class="line">    &#123;1, &quot;三体&quot;, &quot;刘慈欣&quot;, SCIENCE_FICTION&#125;,</span><br><span class="line">    &#123;2, &quot;红楼梦&quot;, &quot;曹雪芹&quot;, LITERATURE&#125;,</span><br><span class="line">    &#123;3, &quot;中国通史&quot;, &quot;吕思勉&quot;, HISTORY&#125;,</span><br><span class="line">    &#123;4, &quot;时间简史&quot;, &quot;史蒂芬_霍金&quot;, TECHNOLOGY&#125;,</span><br><span class="line">    &#123;5, &quot;围城&quot;, &quot;钱钟书&quot;, LITERATURE&#125;,</span><br><span class="line">    &#123;6, &quot;傲慢与偏见&quot;, &quot;简_奥斯汀&quot;, LITERATURE&#125;,</span><br><span class="line">    &#123;7, &quot;呼啸山庄&quot;, &quot;艾米莉_勃朗特&quot;, LITERATURE&#125;,</span><br><span class="line">    &#123;8, &quot;活着&quot;, &quot;余华&quot;, LITERATURE&#125;,</span><br><span class="line">    &#123;9, &quot;明朝那些事儿&quot;, &quot;当年明月&quot;, HISTORY&#125;,</span><br><span class="line">    &#123;10, &quot;乌合之众&quot;, &quot;古斯塔夫_勒庞&quot;, OTHER&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    print_book_info(books, MAX_BOOKS);</span><br><span class="line">    Genre gen;</span><br><span class="line">    do &#123;</span><br><span class="line">        printf(&quot;\n请输入书籍类别编号（0:科幻 1.文学 2.历史 3.科技 4.其他 5.退出）\n&quot;);</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;gen);</span><br><span class="line">        find_books_by_genre(books, MAX_BOOKS, gen);</span><br><span class="line">    &#125; while (gen != 5);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源文件-function-c"><a href="#源文件-function-c" class="headerlink" title="源文件 function.c"></a>源文件 function.c</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &quot;function.h&quot;</span><br><span class="line"></span><br><span class="line">const char *Genre_Zn(Genre i) &#123;</span><br><span class="line">switch (i) &#123;</span><br><span class="line">case SCIENCE_FICTION: return &quot;科幻&quot;;</span><br><span class="line">case LITERATURE:         return &quot;文学&quot;;</span><br><span class="line">case HISTORY:          return &quot;历史&quot;;</span><br><span class="line">case TECHNOLOGY:          return &quot;科技&quot;;</span><br><span class="line">case OTHER:          return &quot;其他&quot;;</span><br><span class="line">default:              return &quot;未知&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_book_info(Book *books, int count) &#123;</span><br><span class="line">for (int i = 0; i &lt; 21; i++) printf(&quot;-&quot;);</span><br><span class="line">printf(&quot; 所有的书籍信息 &quot;);</span><br><span class="line">for (int i = 0; i &lt; 21; i++) printf(&quot;-&quot;);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; MAX_BOOKS; i++) &#123;</span><br><span class="line">printf(&quot;编号:%-2d  书名:%-12s  作者:%-13s   类别:%-8s\n&quot;, books[i].num, books[i].name, books[i].author, Genre_Zn(books[i].genre));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void find_books_by_genre(Book *books, int count, Genre genre) &#123;</span><br><span class="line">for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">if (books[i].genre == genre) &#123;</span><br><span class="line">printf(&quot;编号:%-2d  书名:%-12s  作者:%-13s   类别:%-8s\n&quot;, books[i].num, books[i].name, books[i].author, Genre_Zn(books[i].genre));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C-Code </category>
          
          <category> Practical System Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> CODE </tag>
            
            <tag> 结构体 </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C标准库字符串函数复现</title>
      <link href="/posts/83143407/"/>
      <url>/posts/83143407/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/3.png" alt="C标准库字符串函数复现" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><h1 id="引言：为什么需要复现标准库字符串函数？"><a href="#引言：为什么需要复现标准库字符串函数？" class="headerlink" title="引言：为什么需要复现标准库字符串函数？"></a>引言：为什么需要复现标准库字符串函数？</h1><p>在C语言开发中，&#96;&#96;提供的字符串函数（如<code>strlen</code>、<code>strcpy</code>）是最常用的工具之一。但这些函数的底层实现逻辑你真的清楚吗？</p><ul><li><strong>学习价值</strong>：复现标准库函数能帮你深入理解字符串操作的底层逻辑（如空终止符的作用、内存复制的安全性）；</li><li><strong>工程实践</strong>：在嵌入式开发、操作系统内核等场景中，可能因内存限制或安全要求无法直接使用标准库，需自定义实现；</li><li><strong>避坑指南</strong>：了解标准库函数的潜在问题（如<code>strcpy</code>的缓冲区溢出风险），能帮助你在实际开发中写出更安全的代码。</li></ul><p>今天，我们就通过复现6个核心字符串函数（<code>strlen</code>、<code>strcpy</code>、<code>strncpy</code>、<code>strcat</code>、<code>strncat</code>、<code>strcmp</code>），彻底掌握字符串操作的底层原理！</p><hr><h1 id="复现1：my-strlen——计算字符串长度"><a href="#复现1：my-strlen——计算字符串长度" class="headerlink" title="复现1：my_strlen——计算字符串长度"></a>复现1：<code>my_strlen</code>——计算字符串长度</h1><h2 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h2><p><code>my_strlen</code>用于计算字符串的有效字符数（不包含空终止符<code>\0</code>）。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>从字符串起始地址开始遍历，每遇到一个非<code>\0</code>字符计数加1，直到遇到<code>\0</code>停止。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">size_t my_strlen(const char *p) &#123;</span><br><span class="line">    size_t count = 0;</span><br><span class="line">    while (*p != &#x27;\0&#x27;) &#123;  // 遍历直到空终止符</span><br><span class="line">        count++;</span><br><span class="line">        p++;              // 移动到下一个字符</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul><li>使用<code>size_t</code>类型避免负数问题（长度不可能为负）；</li><li>时间复杂度为O(n)（n为字符串长度），空间复杂度为O(1)（仅用计数器）。</li></ul><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char p[30] = &quot;122345&quot;; </span><br><span class="line">printf(&quot;%zu\n&quot;, my_strlen(p));  // 输出6（字符&#x27;1&#x27;,&#x27;2&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;）</span><br></pre></td></tr></table></figure><hr><h1 id="复现2：my-strcpy——复制字符串内容"><a href="#复现2：my-strcpy——复制字符串内容" class="headerlink" title="复现2：my_strcpy——复制字符串内容"></a>复现2：<code>my_strcpy</code>——复制字符串内容</h1><h2 id="功能说明-1"><a href="#功能说明-1" class="headerlink" title="功能说明"></a>功能说明</h2><p><code>my_strcpy</code>将源字符串（<code>src</code>）的内容复制到目标字符串（<code>dest</code>），并确保<code>dest</code>以<code>\0</code>结尾。</p><h2 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h2><ol><li>保存<code>dest</code>的起始地址（用于返回）；</li><li>逐个复制<code>src</code>的字符到<code>dest</code>，直到遇到<code>src</code>的<code>\0</code>；</li><li>手动在<code>dest</code>末尾添加<code>\0</code>（确保目标字符串合法）。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char *my_strcpy(char *dest, const char *src) &#123;</span><br><span class="line">    char *tmp = dest;       // 保存目标起始地址</span><br><span class="line">    while (*src != &#x27;\0&#x27;) &#123;  // 复制直到源字符串结束</span><br><span class="line">        *dest++ = *src++;   // 逐个字符复制（后置++避免覆盖）</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = &#x27;\0&#x27;;           // 手动添加空终止符</span><br><span class="line">    return tmp;             // 返回目标起始地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h2><ul><li>必须确保<code>dest</code>有足够空间容纳<code>src</code>的内容（否则会导致缓冲区溢出）；</li><li>返回<code>dest</code>的起始地址是为了支持链式调用（如<code>strcpy(dest, strcpy(tmp, src))</code>）。</li></ul><h2 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char p[30] = &quot;122345&quot;; </span><br><span class="line">char q[] = &quot;12234&quot;; </span><br><span class="line">printf(&quot;%s\n&quot;, my_strcpy(p, q));  // 输出&quot;12234&quot;（p被覆盖为q的内容）</span><br></pre></td></tr></table></figure><hr><h1 id="复现3：my-strncpy——安全复制（限制长度）"><a href="#复现3：my-strncpy——安全复制（限制长度）" class="headerlink" title="复现3：my_strncpy——安全复制（限制长度）"></a>复现3：<code>my_strncpy</code>——安全复制（限制长度）</h1><h2 id="功能说明-2"><a href="#功能说明-2" class="headerlink" title="功能说明"></a>功能说明</h2><p><code>my_strncpy</code>将源字符串的前<code>n</code>个字符复制到目标字符串，若源字符串长度小于<code>n</code>，则用<code>\0</code>填充剩余空间。</p><h2 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h2><ol><li>遍历源字符串的前<code>n</code>个字符（或直到遇到<code>\0</code>）；</li><li>若源字符串长度不足<code>n</code>，继续用<code>\0</code>填充目标字符串至<code>n</code>长度。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">char *my_strncpy(char *dest, const char *src, size_t n) &#123;</span><br><span class="line">    size_t i;</span><br><span class="line">    for (i = 0; i &lt; n &amp;&amp; src[i] != &#x27;\0&#x27;; i++) &#123;  // 复制前n个有效字符</span><br><span class="line">        dest[i] = src[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (; i &lt; n; i++) &#123;                        // 填充剩余空间为\0</span><br><span class="line">        dest[i] = &#x27;\0&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    return dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键点-2"><a href="#关键点-2" class="headerlink" title="关键点"></a>关键点</h2><ul><li>若<code>n</code>大于源字符串长度，目标字符串末尾会被填充<code>\0</code>（避免未终止）；</li><li>若<code>n</code>小于源字符串长度，仅复制前<code>n</code>个字符（目标字符串不会以<code>\0</code>结尾！需额外处理）。</li></ul><h2 id="测试用例-2"><a href="#测试用例-2" class="headerlink" title="测试用例"></a>测试用例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char p[30] = &quot;122345&quot;; </span><br><span class="line">char a[] = &quot;128757&quot;; </span><br><span class="line">printf(&quot;%s\n&quot;, my_strncpy(p, a, 4));  // 输出&quot;1287&quot;（复制前4个字符）</span><br></pre></td></tr></table></figure><hr><h1 id="复现4：my-strcat——拼接字符串"><a href="#复现4：my-strcat——拼接字符串" class="headerlink" title="复现4：my_strcat——拼接字符串"></a>复现4：<code>my_strcat</code>——拼接字符串</h1><h2 id="功能说明-3"><a href="#功能说明-3" class="headerlink" title="功能说明"></a>功能说明</h2><p><code>my_strcat</code>将源字符串（<code>src</code>）的内容追加到目标字符串（<code>dest</code>）的末尾，并确保<code>dest</code>以<code>\0</code>结尾。</p><h2 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h2><ol><li>找到<code>dest</code>的末尾（空终止符位置）；</li><li>将<code>src</code>的字符逐个复制到<code>dest</code>末尾，直到<code>src</code>结束；</li><li>手动在<code>dest</code>末尾添加<code>\0</code>。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">char *my_strcat(char *dest, const char *src) &#123;</span><br><span class="line">    char *tmp = dest;       // 保存目标起始地址</span><br><span class="line">    while (*dest != &#x27;\0&#x27;) &#123; // 找到dest的末尾</span><br><span class="line">        dest++;</span><br><span class="line">    &#125;</span><br><span class="line">    while ((*dest++ = *src++) != &#x27;\0&#x27;);  // 复制src到dest末尾</span><br><span class="line">    *dest = &#x27;\0&#x27;;           // 手动添加空终止符（防止src未终止导致dest越界）</span><br><span class="line">    return tmp;             // 返回目标起始地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键点-3"><a href="#关键点-3" class="headerlink" title="关键点"></a>关键点</h2><ul><li>必须确保<code>dest</code>有足够空间容纳<code>src</code>的内容（否则会导致缓冲区溢出）；</li><li>若<code>dest</code>原本为空字符串（<code>&quot;&quot;</code>），则直接复制<code>src</code>。</li></ul><h2 id="测试用例-3"><a href="#测试用例-3" class="headerlink" title="测试用例"></a>测试用例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char p[30] = &quot;122345&quot;; </span><br><span class="line">char a[] = &quot;128757&quot;; </span><br><span class="line">printf(&quot;%s\n&quot;, my_strcat(p, a));  // 输出&quot;122345128757&quot;（p被扩展为两字符串拼接结果）</span><br></pre></td></tr></table></figure><hr><h1 id="复现5：my-strncat——安全拼接（限制长度）"><a href="#复现5：my-strncat——安全拼接（限制长度）" class="headerlink" title="复现5：my_strncat——安全拼接（限制长度）"></a>复现5：<code>my_strncat</code>——安全拼接（限制长度）</h1><h2 id="功能说明-4"><a href="#功能说明-4" class="headerlink" title="功能说明"></a>功能说明</h2><p><code>my_strncat</code>将源字符串的前<code>n</code>个字符追加到目标字符串（<code>dest</code>）的末尾，并确保<code>dest</code>以<code>\0</code>结尾。</p><h2 id="实现原理-4"><a href="#实现原理-4" class="headerlink" title="实现原理"></a>实现原理</h2><ol><li>找到<code>dest</code>的末尾（空终止符位置）；</li><li>复制源字符串的前<code>n</code>个字符到<code>dest</code>末尾（若源字符串提前结束则停止）；</li><li>手动在<code>dest</code>末尾添加<code>\0</code>。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char *my_strncat(char *dest, const char *src, size_t n) &#123;</span><br><span class="line">    char *tmp = dest;       // 保存目标起始地址</span><br><span class="line">    while (*dest != &#x27;\0&#x27;) &#123; // 找到dest的末尾</span><br><span class="line">        dest++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (size_t i = 0; i &lt; n &amp;&amp; *src != &#x27;\0&#x27;; i++) &#123;  // 复制前n个字符（或源提前结束）</span><br><span class="line">        *dest++ = *src++;</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = &#x27;\0&#x27;;           // 手动添加空终止符</span><br><span class="line">    return tmp;             // 返回目标起始地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键点-4"><a href="#关键点-4" class="headerlink" title="关键点"></a>关键点</h2><ul><li>若<code>n</code>大于源字符串长度，仅复制源的全部内容并在末尾添加<code>\0</code>；</li><li>若<code>n</code>小于源字符串长度，复制前<code>n</code>个字符后强制终止<code>dest</code>。</li></ul><h2 id="测试用例-4"><a href="#测试用例-4" class="headerlink" title="测试用例"></a>测试用例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char p[30] = &quot;122345&quot;; </span><br><span class="line">char a[] = &quot;128757&quot;; </span><br><span class="line">printf(&quot;%s\n&quot;, my_strncat(p, a, 4));  // 输出&quot;1223451287&quot;（p末尾追加前4个字符）</span><br></pre></td></tr></table></figure><hr><h1 id="复现6：my-strcmp——比较字符串大小"><a href="#复现6：my-strcmp——比较字符串大小" class="headerlink" title="复现6：my_strcmp——比较字符串大小"></a>复现6：<code>my_strcmp</code>——比较字符串大小</h1><h2 id="功能说明-5"><a href="#功能说明-5" class="headerlink" title="功能说明"></a>功能说明</h2><p><code>my_strcmp</code>逐个比较两个字符串的字符，返回它们的字典序关系（负数、0、正数分别表示<code>str1 &lt; str2</code>、<code>相等</code>、<code>str1 &gt; str2</code>）。</p><h2 id="实现原理-5"><a href="#实现原理-5" class="headerlink" title="实现原理"></a>实现原理</h2><p>逐个比较<code>str1</code>和<code>str2</code>的字符，直到遇到不同的字符或其中一个字符串结束：</p><ul><li>若字符值不同，返回它们的ASCII差值（<code>*(unsigned char *)str1 - *(unsigned char *)str2</code>）；</li><li>若全部字符相同且同时结束，返回0。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int my_strcmp(const char *str1, const char *str2) &#123;</span><br><span class="line">    while (*str1 &amp;&amp; *str2 &amp;&amp; *str1 == *str2) &#123;  </span><br><span class="line">    // 字符相同且未结束则继续</span><br><span class="line">        str1++;</span><br><span class="line">        str2++;</span><br><span class="line">    &#125;</span><br><span class="line">    return *(unsigned char *)str1 - *(unsigned char *)str2;  </span><br><span class="line">    // 返回差值（处理符号问题）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键点-5"><a href="#关键点-5" class="headerlink" title="关键点"></a>关键点</h2><ul><li>使用<code>unsigned char</code>强制转换避免符号扩展问题（如<code>char</code>为有符号类型时，<code>\xff</code>会被视为-1）；</li><li>若两个字符串完全相同但长度不同（如<code>&quot;abc&quot;</code>和<code>&quot;abcd&quot;</code>），会在较短字符串的<code>\0</code>处停止比较，返回<code>\0 - &#39;d&#39;</code>（负数）。</li></ul><h2 id="测试用例-5"><a href="#测试用例-5" class="headerlink" title="测试用例"></a>测试用例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char a[] = &quot;128757&quot;; </span><br><span class="line">char q[] = &quot;12234&quot;; </span><br><span class="line">printf(&quot;%d\n&quot;, my_strcmp(a, q));  // 输出正数（&quot;128757&quot; &gt; &quot;12234&quot;）</span><br></pre></td></tr></table></figure><hr><h1 id="主函数测试：验证所有函数"><a href="#主函数测试：验证所有函数" class="headerlink" title="主函数测试：验证所有函数"></a>主函数测试：验证所有函数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int main(void) &#123;</span><br><span class="line">    char p[30] = &quot;122345&quot;;  // 可修改的数组</span><br><span class="line">    char q[] = &quot;12234&quot;;</span><br><span class="line">    char a[] = &quot;128757&quot;;</span><br><span class="line"></span><br><span class="line">    // 测试 strcmp</span><br><span class="line">    printf(&quot;%d\n&quot;, my_strcmp(a, q));  // 输出正数（&quot;128757&quot; &gt; &quot;12234&quot;）</span><br><span class="line"></span><br><span class="line">    // 测试 strlen</span><br><span class="line">    printf(&quot;%zu\n&quot;, my_strlen(p));  // 输出6（字&#x27;1&#x27;,&#x27;2&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;）</span><br><span class="line"></span><br><span class="line">    // 测试 strcpy</span><br><span class="line">    printf(&quot;%s\n&quot;, my_strcpy(p, q));  // 输出&quot;12234&quot;（p被覆盖为q的内容）</span><br><span class="line"></span><br><span class="line">    // 测试 strcmp（比较修改后的p和q）</span><br><span class="line">    printf(&quot;%d\n&quot;, my_strcmp(p, q));  // 输出0（两者内容相同）</span><br><span class="line"></span><br><span class="line">    // 测试 strncpy（复制前4个字符）</span><br><span class="line">    printf(&quot;%s\n&quot;, my_strncpy(p, a, 4));  // 输出&quot;1287&quot;（p前4位被覆盖）</span><br><span class="line"></span><br><span class="line">    // 测试 strcat（拼接a到p末尾）</span><br><span class="line">    printf(&quot;%s\n&quot;, my_strcat(p, a));  // 输出&quot;1287128757&quot;（p末尾追加a的内容）</span><br><span class="line"></span><br><span class="line">    // 测试 strncat（拼接前4个字符）</span><br><span class="line">    printf(&quot;%s\n&quot;, my_strncat(p, a, 4));  // 输出&quot;128712871287&quot;（p末尾追加前4个字符）</span><br><span class="line"></span><br><span class="line">    // 测试 strcpy（再次覆盖p）</span><br><span class="line">    printf(&quot;%s\n&quot;, my_strcpy(p, q));  // 输出&quot;12234&quot;（p被覆盖为q的内容）</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="总结：复现标准库函数的价值"><a href="#总结：复现标准库函数的价值" class="headerlink" title="总结：复现标准库函数的价值"></a>总结：复现标准库函数的价值</h1><blockquote><p>通过手动实现C语言标准库的字符串函数，我们不仅掌握了底层内存操作的细节（如空终止符的作用、缓冲区溢出的风险），更深入理解了这些函数的设计逻辑和潜在陷阱。这对提升代码的安全性（如避免<code>strcpy</code>的缓冲区溢出）、优化性能（如<code>strncpy</code>的按需复制）以及调试复杂问题（如字符串越界）都有重要意义。</p></blockquote><blockquote><p>下次遇到字符串操作需求时，不妨尝试自己实现核心逻辑——这不仅能加深对C语言的理解，更能让你在工程实践中写出更健壮的代码！</p></blockquote><hr><h1 id="完整源代码：复现C语言标准库字符串函数"><a href="#完整源代码：复现C语言标准库字符串函数" class="headerlink" title="完整源代码：复现C语言标准库字符串函数"></a>完整源代码：复现C语言标准库字符串函数</h1><p>以下是所有复现函数的完整实现，包含详细注释与测试用例，可直接复制编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdbool.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stddef.h&gt;  // 用于size_t类型</span></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">复现C语言中的库函数</span><br><span class="line">* 1.size_t my_strlen(const char *str);</span><br><span class="line">* 2.char *my_strcpy(char *dest, const char *src);</span><br><span class="line">* 3.char *my_strncpy(char *dest, const char *src, size_t n);</span><br><span class="line">* 4.char *my_strcat(char *dest, const char *src);</span><br><span class="line">* 5.char *my_strncat(char *dest, const char *src, size_t n);</span><br><span class="line">* 6.int my_strcmp(const char *str1, const char *str2);</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 1. 实现 strlen 求字符的长度</span><br><span class="line">size_t my_strlen(const char *p) &#123;</span><br><span class="line">    size_t count = 0;</span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="string">&#x27;\0&#x27;</span>) &#123;  // 遍历直到空终止符</span><br><span class="line">        count++;</span><br><span class="line">        p++;              // 移动到下一个字符</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 实现 strcpy 复制字符串的值</span><br><span class="line">char *my_strcpy(char *dest, const char *src) &#123;</span><br><span class="line">    char *tmp = dest;       // 保存目标起始地址</span><br><span class="line">    <span class="keyword">while</span> (*src != <span class="string">&#x27;\0&#x27;</span>) &#123;  // 复制直到源字符串结束</span><br><span class="line">        *dest++ = *src++;   // 逐个字符复制（后置++避免覆盖）</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = <span class="string">&#x27;\0&#x27;</span>;           // 手动添加空终止符</span><br><span class="line">    <span class="built_in">return</span> tmp;             // 返回目标起始地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3. 更安全的复制（带长度限制）</span><br><span class="line">char *my_strncpy(char *dest, const char *src, size_t n) &#123;</span><br><span class="line">    size_t i;</span><br><span class="line">    <span class="keyword">for</span> (i = 0; i &lt; n &amp;&amp; src[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        // 复制前n个有效字符</span><br><span class="line">        dest[i] = src[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n; i++) &#123;</span><br><span class="line">        // 填充剩余空间为\0</span><br><span class="line">        dest[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4. 实现 strcat 拼接字符串</span><br><span class="line">char *my_strcat(char *dest, const char *src) &#123;</span><br><span class="line">    char *tmp = dest;</span><br><span class="line">    // 保存目标起始地址</span><br><span class="line">    <span class="keyword">while</span> (*dest != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        // 找到dest的末尾（空终止符位置）</span><br><span class="line">        dest++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((*dest++ = *src++) != &#x27;\<span class="number">0</span>&#x27;);</span><br><span class="line">    // 复制src到dest末尾</span><br><span class="line">    *dest = &#x27;\<span class="number">0</span>&#x27;;</span><br><span class="line">    // 手动添加空终止符（防止src未终止导致dest越界）</span><br><span class="line">    return tmp;</span><br><span class="line">    // 返回目标起始地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// <span class="number">5</span>. 实现 strncat 安全拼接（限制长度）</span><br><span class="line">char *my_strncat(char *dest, const char *src, size_t n) &#123;</span><br><span class="line">    char *tmp = dest;       // 保存目标起始地址</span><br><span class="line">    while (*dest != &#x27;\<span class="number">0</span>&#x27;) &#123; // 找到dest的末尾</span><br><span class="line">        dest++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (size_t i = <span class="number">0</span>; i &lt; n &amp;&amp; *src != &#x27;\<span class="number">0</span>&#x27;; i++) &#123;  // 复制前n个字符（或源提前结束）</span><br><span class="line">        *dest++ = *src++;</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = &#x27;\<span class="number">0</span>&#x27;;           // 手动添加空终止符</span><br><span class="line">    return tmp;             // 返回目标起始地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// <span class="number">6</span>. 实现 strcmp 比较字符串大小</span><br><span class="line">int my_strcmp(const char *str1, const char *str2) &#123;</span><br><span class="line">    while (*str1 &amp;&amp; *str2 &amp;&amp; *str1 == *str2) &#123;  // 字符相同且未结束则继续</span><br><span class="line">        str1++;</span><br><span class="line">        str2++;</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回差值（转换为unsigned char避免符号扩展问题）</span><br><span class="line">    return *(unsigned char *)str1 - *(unsigned char *)str2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主函数：测试所有复现函数</span><br><span class="line">int main(void) &#123;</span><br><span class="line">    char p[<span class="number">30</span>] = &quot;<span class="number">122345</span>&quot;;  // 可修改的数组（初始长度<span class="number">6</span>）</span><br><span class="line">    char q[] = &quot;<span class="number">12234</span>&quot;;     // 自动推导长度（<span class="number">5</span>+<span class="number">1</span>=<span class="number">6</span>）</span><br><span class="line">    char a[] = &quot;<span class="number">128757</span>&quot;;    // 自动推导长度（<span class="number">6</span>+<span class="number">1</span>=<span class="number">7</span>）</span><br><span class="line"></span><br><span class="line">    // 测试 my_strcmp（比较a和q）</span><br><span class="line">    printf(&quot;my_strcmp(a, q) = %d\n&quot;, my_strcmp(a, q));  // 输出正数（<span class="string">&quot;128757&quot;</span> &gt; <span class="string">&quot;12234&quot;</span>）</span><br><span class="line"></span><br><span class="line">    // 测试 my_strlen（计算p的长度）</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my_strlen(p) = %zu\n&quot;</span>, my_strlen(p));  // 输出6（字符<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>）</span><br><span class="line"></span><br><span class="line">    // 测试 my_strcpy（将q复制到p）</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my_strcpy(p, q) = %s\n&quot;</span>, my_strcpy(p, q));  // 输出<span class="string">&quot;12234&quot;</span>（p被覆盖为q的内容）</span><br><span class="line"></span><br><span class="line">    // 测试 my_strcmp（比较修改后的p和q）</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my_strcmp(p, q) = %d\n&quot;</span>, my_strcmp(p, q));  // 输出0（两者内容相同）</span><br><span class="line"></span><br><span class="line">    // 测试 my_strncpy（将a的前4个字符复制到p）</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my_strncpy(p, a, 4) = %s\n&quot;</span>, my_strncpy(p, a, 4));  // 输出<span class="string">&quot;1287&quot;</span>（p前4位被覆盖）</span><br><span class="line"></span><br><span class="line">    // 测试 my_strcat（将a拼接至p末尾）</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my_strcat(p, a) = %s\n&quot;</span>, my_strcat(p, a));  // 输出<span class="string">&quot;1287128757&quot;</span>（p末尾追加a的内容）</span><br><span class="line"></span><br><span class="line">    // 测试 my_strncat（将a的前4个字符拼接至p末尾）</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my_strncat(p, a, 4) = %s\n&quot;</span>, my_strncat(p, a, 4));  // 输出<span class="string">&quot;128712871287&quot;</span>（p末尾追加前4个字符）</span><br><span class="line"></span><br><span class="line">    // 测试 my_strcpy（再次将q复制到p）</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my_strcpy(p, q) = %s\n&quot;</span>, my_strcpy(p, q));  // 输出<span class="string">&quot;12234&quot;</span>（p被覆盖为q的内容）</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C-Code </category>
          
          <category> Foundational Syntax and Core Concepts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> CODE </tag>
            
            <tag> 安全编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言日期工具完整实现</title>
      <link href="/posts/39679951/"/>
      <url>/posts/39679951/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/2.png" alt="C语言日期工具完整实现" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><h1 id="引言：为什么需要自己写日期工具？"><a href="#引言：为什么需要自己写日期工具？" class="headerlink" title="引言：为什么需要自己写日期工具？"></a>引言：为什么需要自己写日期工具？</h1><p>在开发日程管理、财务统计或数据分析类应用时，日期处理是绕不开的需求。虽然C标准库提供了相关函数，但实际场景中往往需要更灵活的功能——比如精确计算两个日期的天数差、自定义格式打印月历，或验证用户输入的日期合法性。今天我们就用C语言手写一个<strong>全功能日期工具</strong>，覆盖从基础判断到复杂交互的全流程，并拆解核心算法原理。</p><hr><h1 id="核心功能清单"><a href="#核心功能清单" class="headerlink" title="核心功能清单"></a>核心功能清单</h1><p>这个日期工具实现了5大核心功能，覆盖日常开发中最常用的日期操作场景：</p><ul><li>✅ <strong>计算日期差</strong>：精确计算任意两个日期之间的天数间隔；</li><li>✅ <strong>查询星期几</strong>：输入年月日，快速得到对应的星期名称；</li><li>✅ <strong>打印月历</strong>：以表格形式展示当月日期与星期的对应关系；</li><li>✅ <strong>打印年历</strong>：按月份分开展示全年日历；</li><li>✅ <strong>输入验证</strong>：自动检查日期合法性（如闰年二月是否有29天）。</li></ul><hr><h1 id="关键数据与算法：日期计算的底层逻辑"><a href="#关键数据与算法：日期计算的底层逻辑" class="headerlink" title="关键数据与算法：日期计算的底层逻辑"></a>关键数据与算法：日期计算的底层逻辑</h1><h2 id="基础数据：月份天数与星期映射"><a href="#基础数据：月份天数与星期映射" class="headerlink" title="基础数据：月份天数与星期映射"></a>基础数据：月份天数与星期映射</h2><p>代码中定义了两个全局常量数组，它们是整个工具的「数据基石」：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int mon[12] = &#123; 31,28,31,30,31,30,31,31,30,31,30,31 &#125;;  </span><br><span class="line">// 平年各月天数（索引0=1月）</span><br><span class="line">const char *week_day[7] = &#123; &quot;周日&quot;, &quot;周一&quot;, &quot;周二&quot;, &quot;周三&quot;, &quot;周四&quot;, &quot;周五&quot;, &quot;周六&quot; &#125;;  </span><br><span class="line">// 星期名称映射</span><br></pre></td></tr></table></figure><ul><li><code>mon</code>数组：存储平年各月的天数（如1月31天，2月28天）；</li><li><code>week_day</code>数组：将0-6映射到「周日-周六」，用于后续星期几的输出。</li></ul><h2 id="闰年判断：时间的「校正器」"><a href="#闰年判断：时间的「校正器」" class="headerlink" title="闰年判断：时间的「校正器」"></a>闰年判断：时间的「校正器」</h2><p>闰年的规则是：能被4整除但不能被100整除，或能被400整除的年份。这个函数是日期计算的「时间校正器」：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool is_leap_year(int year) &#123;</span><br><span class="line">    return ((year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么需要闰年？</strong> 地球绕太阳公转周期约为365.2422天，平年365天会累积误差，闰年通过增加2月1天（29天）来修正。</p><h2 id="计算每月第一天的星期：月历的「定位仪」"><a href="#计算每月第一天的星期：月历的「定位仪」" class="headerlink" title="计算每月第一天的星期：月历的「定位仪」"></a>计算每月第一天的星期：月历的「定位仪」</h2><p>这个函数是月历打印的「定位仪」，它的作用是：计算「从公元1年1月1日到目标年月1日」的总天数，再通过取模7得到星期几（0&#x3D;周日，1&#x3D;周一...6&#x3D;周六）。实现步骤如下：</p><ol><li><strong>累计基准天数</strong>：<code>(year - 1) * 365</code>计算所有完整年的天数，加上闰年修正项<code>(year - 1)/4 - (year - 1)/100 + (year - 1)/400</code>（每4年一闰，每100年去闰，每400年加闰）；</li><li><strong>闰年修正</strong>：若当前年是闰年且月份&gt;2（2月已过），总天数加1；</li><li><strong>月份累计</strong>：从当年1月开始累加前几个月的天数（如计算3月1日，需累加1月和2月的天数）。</li></ol><p><strong>示例验证</strong>（2024年3月1日）：</p><ul><li>基准年（2023年及之前）：2023×365 + 2023&#x2F;4 - 2023&#x2F;100 + 2023&#x2F;400 &#x3D; 738315 + 505 - 20 + 5 &#x3D; 738805天；</li><li>闰年修正：2024是闰年且月份&gt;2，加1天 → 738806天；</li><li>月份累计：1月（31）+2月（29，闰年）&#x3D;60天 → 总天数738806+60&#x3D;738866天；</li><li>738866 % 7 &#x3D; 2 → 2024年3月1日是周二（<code>week_day[2]</code>）。</li></ul><hr><h1 id="功能实现：从代码到交互的全链路"><a href="#功能实现：从代码到交互的全链路" class="headerlink" title="功能实现：从代码到交互的全链路"></a>功能实现：从代码到交互的全链路</h1><h2 id="月历打印：对齐的艺术"><a href="#月历打印：对齐的艺术" class="headerlink" title="月历打印：对齐的艺术"></a>月历打印：对齐的艺术</h2><p>月历的核心是「对齐」——根据每月第一天的星期，在月初填充空白，然后逐行打印日期。代码实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void calendar_month(int year, int month) &#123;</span><br><span class="line">    printf(&quot;日\t一\t二\t三\t四\t五\t六\n&quot;);  // 表头</span><br><span class="line">    for (int i = 0; i &lt; 51; i++) printf(&quot;=&quot;);  // 分隔线</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    int first_day = month_first_day(year, month) % 7;  // 当月1日的星期（0=周日）</span><br><span class="line">    for (int i = 0; i &lt; first_day; i++) printf(&quot;\t&quot;);  // 填充月初空白</span><br><span class="line"></span><br><span class="line">    // 打印日期（1日到月末）</span><br><span class="line">    for (int d = 1; d &lt;= mon[month - 1]; d++) &#123;</span><br><span class="line">        printf(&quot;%d\t&quot;, d);</span><br><span class="line">        if ((first_day + d) % 7 == 0) printf(&quot;\n&quot;);  // 每7天换行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出示例</strong>（2024年3月）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">日一二三四五六</span><br><span class="line">===============================</span><br><span class="line">                12345</span><br><span class="line">6789101112</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="计算日期差：总天数相减的巧思"><a href="#计算日期差：总天数相减的巧思" class="headerlink" title="计算日期差：总天数相减的巧思"></a>计算日期差：总天数相减的巧思</h2><p>计算两个日期的天数差，本质是「总天数相减」。代码通过<code>month_first_day</code>获取两个日期到年初的总天数，再求差值的绝对值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">case 1: &#123;</span><br><span class="line">    int days = month_first_day(year, month) + day;  // 当前日期到年初的总天数</span><br><span class="line">    printf(&quot;请输入第二个日期，例如2025年6月2日\n&quot;);</span><br><span class="line">    scanf(&quot;%d年%d月%d日&quot;, &amp;year, &amp;month, &amp;day);</span><br><span class="line">    days = days - (month_first_day(year, month) + day);  // 减去第二个日期的总天数</span><br><span class="line">    printf(&quot;天数差为：%d\n&quot;, abs(days));  // 取绝对值</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询星期几：星期的「解码器」"><a href="#查询星期几：星期的「解码器」" class="headerlink" title="查询星期几：星期的「解码器」"></a>查询星期几：星期的「解码器」</h2><p>通过<code>month_first_day</code>获取当月1日的星期，再加上日期数减1（因为1日是第0天），最后取模7得到星期索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case 2: &#123;</span><br><span class="line">    int week_index = (month_first_day(year, month) % 7 + day - 1) % 7;</span><br><span class="line">    printf(&quot;%d年%d月%d日是 %s\n&quot;, year, month, day, week_day[week_index]);</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入验证：防错设计"><a href="#输入验证：防错设计" class="headerlink" title="输入验证：防错设计"></a>输入验证：防错设计</h2><p>代码通过多重校验确保用户输入的日期合法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 日期合法性校验（case 1-4共用）</span><br><span class="line">int max_day = mon[month - 1];  // 当月最大天数（平年）</span><br><span class="line">if (month == 2 &amp;&amp; is_leap_year(year)) max_day++;  // 闰年二月修正</span><br><span class="line">if (day &lt; 1 || day &gt; max_day || month &lt; 1 || month &gt; 12 || year &lt; 0) &#123;</span><br><span class="line">    printf(&quot;错误，重新输入\n&quot;);</span><br><span class="line">    continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="交互设计：从命令行到用户体验"><a href="#交互设计：从命令行到用户体验" class="headerlink" title="交互设计：从命令行到用户体验"></a>交互设计：从命令行到用户体验</h1><p>主函数通过<code>do-while</code>循环实现菜单驱动的交互界面，核心流程如下：</p><ol><li><strong>清空输入缓冲区</strong>：避免因输入错误（如输入字母）导致的死循环；</li><li><strong>菜单引导</strong>：清晰的选项提示（1-5）；</li><li><strong>错误处理</strong>：对非法输入（如月份13、日期32）进行友好提示；</li><li><strong>功能分发</strong>：根据用户选择调用对应函数。</li></ol><p><strong>示例交互流程</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">请输入你想选择的功能：</span><br><span class="line">1.计算指定日期间的天数</span><br><span class="line">2.计算指定日期是星期几</span><br><span class="line">3.打印指定日期的月历</span><br><span class="line">4.打印指定日期年历</span><br><span class="line">5.退出</span><br><span class="line">1</span><br><span class="line">请输入日期，例如2025年6月2日</span><br><span class="line">2024年3月1日</span><br><span class="line">请输入第二个日期，例如2025年6月2日</span><br><span class="line">2024年3月2日</span><br><span class="line">计算指定日期间的天数差为：1</span><br></pre></td></tr></table></figure><hr><h1 id="完整源代码"><a href="#完整源代码" class="headerlink" title="完整源代码"></a>完整源代码</h1><p>以下是项目的完整C语言源代码，可直接复制编译运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&quot;function.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">printf(&quot;请输入你想选择的功能：\n1.计算指定日期间的天数\n2.计算指定日期是星期几\n3.打印指定日期的月历\n4.打印指定日期年历\n5.退出\n&quot;);</span><br><span class="line">scanf(&quot; %d&quot;, &amp;num);</span><br><span class="line">while (getchar() != &#x27;\n&#x27;);</span><br><span class="line">if (num &gt; 0 &amp;&amp; num &lt; 5)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;请输入日期，例如2025年6月2日\n&quot;);</span><br><span class="line">if (scanf(&quot;%d年%d月%d日&quot;, &amp;year, &amp;month, &amp;day) != 3) &#123;</span><br><span class="line">while (getchar() != &#x27;\n&#x27;);</span><br><span class="line">printf(&quot;输入格式错误！\n&quot;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">if (day &gt; mon[month - 1] || is_leap_year(year) &amp;&amp; month == 2 &amp;&amp; day &gt; mon[1] + 1 || month &gt; 12 || day &lt; 0 || month &lt; 0 || year &lt; 0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;错误，重新输入\n&quot;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">switch (num) &#123;</span><br><span class="line">case 1:</span><br><span class="line">&#123;</span><br><span class="line">days = month_first_day(year, month) + day;</span><br><span class="line">printf(&quot;请输入第二个日期，例如2025年6月2日\n&quot;);</span><br><span class="line">while (scanf(&quot;%d年%d月%d日&quot;, &amp;year, &amp;month, &amp;day) != 3) &#123;</span><br><span class="line">while (getchar() != &#x27;\n&#x27;);</span><br><span class="line">printf(&quot;输入格式错误2！\n&quot;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">days = days - (month_first_day(year, month) + day);</span><br><span class="line">days = days &lt; 0 ? -days : days;</span><br><span class="line">printf(&quot;计算指定日期间的天数差为%d\n&quot;, days);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case 2:</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d年%d月%d日是 %s\n&quot;, year, month, day, week_day[(month_first_day(year, month) % 7 + day - 1) % 7]);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case 3:</span><br><span class="line">&#123;</span><br><span class="line">calendar_month(year, month, day);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case 4:</span><br><span class="line">&#123;</span><br><span class="line">for (int month = 1; month &lt; 13; month++)</span><br><span class="line">&#123;</span><br><span class="line">day = 1;</span><br><span class="line">printf(&quot;\n\n&quot;);</span><br><span class="line">printf(&quot;\t\t     %d年%d月\t\t\t&quot;, year, month);</span><br><span class="line">printf(&quot;\n\n&quot;);</span><br><span class="line">calendar_month(year, month, 1);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; while (num != 5);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="代码亮点总结"><a href="#代码亮点总结" class="headerlink" title="代码亮点总结"></a>代码亮点总结</h1><ul><li><strong>模块化设计</strong>：通过函数拆分（如<code>is_leap_year</code>、<code>month_first_day</code>）实现逻辑解耦，便于维护；</li><li><strong>输入验证</strong>：使用<code>while (getchar() != &#39; &#39;)</code>清空缓冲区，避免因输入错误导致的死循环；</li><li><strong>高效算法</strong>：基于总天数差计算日期间隔，避免逐月累加的低效操作；</li><li><strong>友好的交互</strong>：清晰的菜单引导和错误提示，提升用户体验。</li></ul><p>通过本文的完整代码，读者可直接运行并体验日期工具的所有功能，同时深入理解日期处理的底层逻辑！</p>]]></content>
      
      
      <categories>
          
          <category> C-Code </category>
          
          <category> Practical System Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> CODE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C程序项目计划书</title>
      <link href="/posts/870cf8e7/"/>
      <url>/posts/870cf8e7/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/0.png" alt="C程序项目计划书" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">刷题</button><button type="button" class="tab">项目</button><button type="button" class="tab">开源项目学习</button></div><div class="tab-contents"><div class="tab-item-content active"><div class="timeline blue"><div class='timeline-item headline'>        <div class='timeline-item-title'>          <div class='item-circle'><p>2025</p></div>        </div>      </div><div class='timeline-item'>        <div class='timeline-item-title'>          <div class='item-circle'><p>6.9</p></div>        </div>        <div class='timeline-item-content'><p><a href="/posts/83dcefb7/"><strong>0001.Two-Sum</strong></a></p></div>      </div></div></div><div class="tab-item-content"><p><a href="/posts/39679951/"><strong>0001.万年历程序</strong></a><br><a href="/posts/12989e68/"><strong>0002.书籍管理程序</strong></a><br><a href="/posts/834f76ba/"><strong>0003.书籍管理系统基于文件流输入输出</strong></a></p></div><div class="tab-item-content"><p><a href="https://github.com/DoctorWkt/acwj?tab=readme-ov-file"><strong>acwj</strong></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">教程注重实战循序渐进，一步步教你如何用 C 语言写一个可以自己编译自己（自举）、能够在真正的硬件上运行的 C 语言编译器。</span><br></pre></td></tr></table></figure><p><a href="https://github.com/cstack/db_tutorial"><strong>db_tutorial</strong></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用 C 从零创建一个简单的数据库</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Simple-XX/SimpleKernel"><strong>SimpleKerne</strong></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提供了各个阶段完成度不同的内核，可以选择从自己喜欢的地方开始。</span><br></pre></td></tr></table></figure><p><a href="https://github.com/zouxiaohang/TinySTL"><strong>TinnySTL</strong></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TinnySTL 是一个轻量级的 C++ STL 实现，它由一系列头文件组成，可以方便地嵌入到你的项目中使用。这个项目涵盖了很多基础的 STL 组件，比如 vector、list、map 等，它们都是在 STL 标准基础上重新实现的，可以帮助你更好地理解 STL 的实现原理，可以用来理解服务器程序的原理和本质。</span><br></pre></td></tr></table></figure><p><a href="https://github.com/EZLippi/WebBench"><strong>Webbench</strong></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Webbench 是一个著名的轻量级 Web 压力测试工具，用于对 Web 服务器进行性能测试和基准测试。通过这个项目，你可以学习如何模拟高并发请求，了解 Web 服务器在高负载情况下的表现。Webbench 代码简单，易于理解，非常适合初学者学习和掌握 Web 性能测试的基本概念和实现方法。</span><br></pre></td></tr></table></figure><p><a href="https://github.com/qinguoyi/TinyWebServer"><strong>TinyWebServer</strong></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux 下 C++ 轻量级 Web 服务器，助力初学者快速实践网络编程，搭建属于自己的服务器！</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Alinshans/MyTinySTL"><strong>迷你 STL 库 MyTinySTL</strong></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里推荐一个大神写的项目 MyTinySTL，它使用 C++11 重新复写了一个小型 STL（容器库＋算法库）。代码结构清晰规范、包含中文文档与注释，并且自带一个简单的测试框架，非常适合新手学习与参考！涉及技术：C++11 模板编程、内存管理技术、容器实现（如 vector、list、deque 等）、算法实现（如排序、查找等）、迭代器设计、适配器模式等。</span><br></pre></td></tr></table></figure><p><a href="https://github.com/mayerui/sudoku"><strong>sudoku</strong></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用 C++ 实现的命令行数独游戏，命令行操作易上手，600多行代码</span><br></pre></td></tr></table></figure><p><a href="https://github.com/microsoft/calculator"><strong>calculator</strong></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">系统预装的计算器工具开源了</span><br></pre></td></tr></table></figure><p><a href="https://github.com/yuesong-feng/30dayMakeCppServer"><strong>30dayMakeCppServer</strong></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本项目 30 天自制 C++ 服务器，包含图文教程和源码，教你在 30 天内入门 Linux 服务器开发，讲解了 Socket、epoll、线程池、CMake 等知识点。</span><br></pre></td></tr></table></figure><p><a href="https://github.com/SamyPesse/How-to-Make-a-Computer-Operating-System"><strong>How-to-Make-a-Computer-Operating-System</strong></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如何用 C++ 制作一个计算机操作系统，这个项目就告诉你。</span><br></pre></td></tr></table></figure><p><a href="https://github.com/aristocratos/btop"><strong>btop</strong></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">知道自己电脑的处理器、内存、磁盘这些硬件的使用情况，如何知道网络和进程的统计信息</span><br></pre></td></tr></table></figure><p><a href="https://github.com/alibaba/async_simple"><strong>async_simple</strong></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">async_simple 是阿里开源的轻量级 C++ 异步框架。 </span><br><span class="line">该项目提供了基于 C++20 无栈协程(Lazy)、有栈协程(Uthread) 以及 Future/Promise 等异步组件，能够轻松完成 C++ 异步的开发。 </span><br><span class="line">目前这个项目广泛应用于阿里的图计算引擎、时序数据库、搜索引擎等系统。</span><br></pre></td></tr></table></figure><p><a href="https://github.com/sogou/workflow"><strong>workflow</strong></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">workflow 是搜狗开源的 C++ 服务器引擎。</span><br><span class="line">这个项目有点东西，支撑搜狗几乎所有后端 C++ 在线服务： 搜索服务 云输入法 广告 ... 每日处理大概超过百亿的请求。 </span><br><span class="line">这是一个很棒的企业级程序引擎，可以满足大多数 C++ 后端开发需求。 </span><br></pre></td></tr></table></figure><p><a href="https://github.com/facebook/folly"><strong>folly</strong></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">folly 是 Facebook 开源的 C++ 工具库。 这个项目包含一系列高性能的 C++ 组件库，十分的方便且高效，而且是在 Facebook 内部被广泛应用。 该项目不仅代码规范测试用例充足，而且源码中包含丰富的注释。</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> practice problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 程序 </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World 系统化学习之旅</title>
      <link href="/posts/f9d777ad/"/>
      <url>/posts/f9d777ad/</url>
      
        <content type="html"><![CDATA[<img src="/img/PageCode/1.png" alt="Hello World 系统化学习之旅" style="width: 90%;height: auto;margin: 0 auto;display: block;border: 3px solid #f0f0f0;border-radius: 12px;box-shadow: 0 4px 8px rgba(0,0,0,0.1);"><hr><h1 id="🌟Welcome-to-My-Technical-Diary"><a href="#🌟Welcome-to-My-Technical-Diary" class="headerlink" title="🌟Welcome to My Technical Diary"></a>🌟Welcome to My Technical Diary</h1><blockquote><p>This is my first vlog! I’ll use this blog to document my journey from learning C to mastering Go (Golang). Over time, I hope to share insights, code snippets, and lessons learned along the way.</p></blockquote><blockquote><p>Let&#39;s engineer our way from &quot;Hello World&quot; to production-grade systems!</p></blockquote><h1 id="🧭-Navigation-System-Overview"><a href="#🧭-Navigation-System-Overview" class="headerlink" title="🧭 Navigation System Overview"></a>🧭 Navigation System Overview</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Home (Landing Page)</span><br><span class="line">- Daily progress reports | Technical retrospectives </span><br><span class="line"></span><br><span class="line">Tech Stack Panel (Sidebar)</span><br><span class="line">- **Tag Cloud**: `#Go` `#C`  </span><br><span class="line">  *(Click tags to filter content)*</span><br><span class="line">- **Chronology**: Full article timeline with timestamps  </span><br><span class="line"></span><br><span class="line">Resource Repository (Links)</span><br></pre></td></tr></table></figure><hr><h1 id="📌-Development-Discipline"><a href="#📌-Development-Discipline" class="headerlink" title="📌 Development Discipline"></a>📌 Development Discipline</h1><h2 id="核心理念"><a href="#核心理念" class="headerlink" title="核心理念"></a>核心理念</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ Core Doctrines:</span><br><span class="line">   1. Daily effective code (Minimum 3 production-ready lines)</span><br><span class="line">   2. Error log as primary learning artifact</span><br><span class="line">   3. Weekly code refactoring cycle</span><br><span class="line"></span><br><span class="line">! Anti-pattern Prohibitions:</span><br><span class="line">   ❌ Code pasting without comprehension  </span><br><span class="line">   ❌ Error message suppression  </span><br><span class="line">   ❌ Premature toolchain upgrades</span><br></pre></td></tr></table></figure><hr><h1 id="🚀-Immediate-Action-Plan"><a href="#🚀-Immediate-Action-Plan" class="headerlink" title="🚀 Immediate Action Plan"></a>🚀 Immediate Action Plan</h1><h2 id="Daily-Commitment-Checklist-✅"><a href="#Daily-Commitment-Checklist-✅" class="headerlink" title="Daily Commitment Checklist ✅"></a>Daily Commitment Checklist ✅</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">### Daily Commitments</span><br><span class="line">1. Submit valid code (even if only comments)</span><br><span class="line">2. Document debugging sessions (full error logs)</span><br><span class="line">3. Update progress metrics</span><br><span class="line"></span><br><span class="line">### Join the Journey</span><br><span class="line">&gt; &quot;Technology is not an island, but a guiding light&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>&quot;Technology is not an island, but a guiding light.&quot;</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Essays </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LearningJournal </tag>
            
            <tag> ProgrammingEducation </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
